/*! For license information please see main.js.LICENSE.txt */
(()=>{var e={424:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>o});var a=n(81),i=n.n(a),s=n(645),r=n.n(s)()(i());r.push([e.id,"@import url(https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;600;700&display=swap);"]),r.push([e.id,"\nhtml,\nbody {\n  font-family: 'Source Code Pro', monospace;\n}\n",""]);const o=r},645:e=>{"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",a=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),a&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),a&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,a,i,s){"string"==typeof e&&(e=[[null,e,void 0]]);var r={};if(a)for(var o=0;o<this.length;o++){var u=this[o][0];null!=u&&(r[u]=!0)}for(var p=0;p<e.length;p++){var d=[].concat(e[p]);a&&r[d[0]]||(void 0!==s&&(void 0===d[5]||(d[1]="@layer".concat(d[5].length>0?" ".concat(d[5]):""," {").concat(d[1],"}")),d[5]=s),n&&(d[2]?(d[1]="@media ".concat(d[2]," {").concat(d[1],"}"),d[2]=n):d[2]=n),i&&(d[4]?(d[1]="@supports (".concat(d[4],") {").concat(d[1],"}"),d[4]=i):d[4]="".concat(i)),t.push(d))}},t}},81:e=>{"use strict";e.exports=function(e){return e[1]}},838:(e,t,n)=>{var a=n(424);a.__esModule&&(a=a.default),"string"==typeof a&&(a=[[e.id,a,""]]),a.locals&&(e.exports=a.locals),(0,n(346).Z)("20211576",a,!1,{})},346:(e,t,n)=>{"use strict";function a(e,t){for(var n=[],a={},i=0;i<t.length;i++){var s=t[i],r=s[0],o={id:e+":"+i,css:s[1],media:s[2],sourceMap:s[3]};a[r]?a[r].parts.push(o):n.push(a[r]={id:r,parts:[o]})}return n}n.d(t,{Z:()=>m});var i="undefined"!=typeof document;if("undefined"!=typeof DEBUG&&DEBUG&&!i)throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var s={},r=i&&(document.head||document.getElementsByTagName("head")[0]),o=null,u=0,p=!1,d=function(){},l=null,y="data-vue-ssr-id",c="undefined"!=typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());function m(e,t,n,i){p=n,l=i||{};var r=a(e,t);return f(r),function(t){for(var n=[],i=0;i<r.length;i++){var o=r[i];(u=s[o.id]).refs--,n.push(u)}for(t?f(r=a(e,t)):r=[],i=0;i<n.length;i++){var u;if(0===(u=n[i]).refs){for(var p=0;p<u.parts.length;p++)u.parts[p]();delete s[u.id]}}}}function f(e){for(var t=0;t<e.length;t++){var n=e[t],a=s[n.id];if(a){a.refs++;for(var i=0;i<a.parts.length;i++)a.parts[i](n.parts[i]);for(;i<n.parts.length;i++)a.parts.push(h(n.parts[i]));a.parts.length>n.parts.length&&(a.parts.length=n.parts.length)}else{var r=[];for(i=0;i<n.parts.length;i++)r.push(h(n.parts[i]));s[n.id]={id:n.id,refs:1,parts:r}}}}function b(){var e=document.createElement("style");return e.type="text/css",r.appendChild(e),e}function h(e){var t,n,a=document.querySelector("style["+y+'~="'+e.id+'"]');if(a){if(p)return d;a.parentNode.removeChild(a)}if(c){var i=u++;a=o||(o=b()),t=w.bind(null,a,i,!1),n=w.bind(null,a,i,!0)}else a=b(),t=g.bind(null,a),n=function(){a.parentNode.removeChild(a)};return t(e),function(a){if(a){if(a.css===e.css&&a.media===e.media&&a.sourceMap===e.sourceMap)return;t(e=a)}else n()}}var T,v=(T=[],function(e,t){return T[e]=t,T.filter(Boolean).join("\n")});function w(e,t,n,a){var i=n?"":a.css;if(e.styleSheet)e.styleSheet.cssText=v(t,i);else{var s=document.createTextNode(i),r=e.childNodes;r[t]&&e.removeChild(r[t]),r.length?e.insertBefore(s,r[t]):e.appendChild(s)}}function g(e,t){var n=t.css,a=t.media,i=t.sourceMap;if(a&&e.setAttribute("media",a),l.ssrId&&e.setAttribute(y,t.id),i&&(n+="\n/*# sourceURL="+i.sources[0]+" */",n+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(i))))+" */"),e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}}},t={};function n(a){var i=t[a];if(void 0!==i)return i.exports;var s=t[a]={id:a,exports:{}};return e[a](s,s.exports,n),s.exports}n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{"use strict";var e=Object.freeze({}),t=Array.isArray;function a(e){return null==e}function i(e){return null!=e}function s(e){return!0===e}function r(e){return"string"==typeof e||"number"==typeof e||"symbol"==typeof e||"boolean"==typeof e}function o(e){return"function"==typeof e}function u(e){return null!==e&&"object"==typeof e}var p=Object.prototype.toString;function d(e){return"[object Object]"===p.call(e)}function l(e){var t=parseFloat(String(e));return t>=0&&Math.floor(t)===t&&isFinite(e)}function y(e){return i(e)&&"function"==typeof e.then&&"function"==typeof e.catch}function c(e){return null==e?"":Array.isArray(e)||d(e)&&e.toString===p?JSON.stringify(e,null,2):String(e)}function m(e){var t=parseFloat(e);return isNaN(t)?e:t}function f(e,t){for(var n=Object.create(null),a=e.split(","),i=0;i<a.length;i++)n[a[i]]=!0;return t?function(e){return n[e.toLowerCase()]}:function(e){return n[e]}}var b=f("slot,component",!0),h=f("key,ref,slot,slot-scope,is");function T(e,t){if(e.length){var n=e.indexOf(t);if(n>-1)return e.splice(n,1)}}var v=Object.prototype.hasOwnProperty;function w(e,t){return v.call(e,t)}function g(e){var t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}var k=/-(\w)/g,M=g((function(e){return e.replace(k,(function(e,t){return t?t.toUpperCase():""}))})),I=g((function(e){return e.charAt(0).toUpperCase()+e.slice(1)})),R=/\B([A-Z])/g,E=g((function(e){return e.replace(R,"-$1").toLowerCase()})),x=Function.prototype.bind?function(e,t){return e.bind(t)}:function(e,t){function n(n){var a=arguments.length;return a?a>1?e.apply(t,arguments):e.call(t,n):e.call(t)}return n._length=e.length,n};function _(e,t){t=t||0;for(var n=e.length-t,a=new Array(n);n--;)a[n]=e[n+t];return a}function F(e,t){for(var n in t)e[n]=t[n];return e}function A(e){for(var t={},n=0;n<e.length;n++)e[n]&&F(t,e[n]);return t}function C(e,t,n){}var S=function(e,t,n){return!1},O=function(e){return e};function N(e,t){if(e===t)return!0;var n=u(e),a=u(t);if(!n||!a)return!n&&!a&&String(e)===String(t);try{var i=Array.isArray(e),s=Array.isArray(t);if(i&&s)return e.length===t.length&&e.every((function(e,n){return N(e,t[n])}));if(e instanceof Date&&t instanceof Date)return e.getTime()===t.getTime();if(i||s)return!1;var r=Object.keys(e),o=Object.keys(t);return r.length===o.length&&r.every((function(n){return N(e[n],t[n])}))}catch(e){return!1}}function P(e,t){for(var n=0;n<e.length;n++)if(N(e[n],t))return n;return-1}function U(e){var t=!1;return function(){t||(t=!0,e.apply(this,arguments))}}function D(e,t){return e===t?0===e&&1/e!=1/t:e==e||t==t}var X="data-server-rendered",V=["component","directive","filter"],L=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],$={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:S,isReservedAttr:S,isUnknownElement:S,getTagNamespace:C,parsePlatformTagName:O,mustUseProp:S,async:!0,_lifecycleHooks:L},B=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function H(e){var t=(e+"").charCodeAt(0);return 36===t||95===t}function q(e,t,n,a){Object.defineProperty(e,t,{value:n,enumerable:!!a,writable:!0,configurable:!0})}var j=new RegExp("[^".concat(B.source,".$_\\d]")),z="__proto__"in{},G="undefined"!=typeof window,W=G&&window.navigator.userAgent.toLowerCase(),Z=W&&/msie|trident/.test(W),K=W&&W.indexOf("msie 9.0")>0,J=W&&W.indexOf("edge/")>0;W&&W.indexOf("android");var Y=W&&/iphone|ipad|ipod|ios/.test(W);W&&/chrome\/\d+/.test(W),W&&/phantomjs/.test(W);var Q,ee=W&&W.match(/firefox\/(\d+)/),te={}.watch,ne=!1;if(G)try{var ae={};Object.defineProperty(ae,"passive",{get:function(){ne=!0}}),window.addEventListener("test-passive",null,ae)}catch(e){}var ie=function(){return void 0===Q&&(Q=!G&&void 0!==n.g&&n.g.process&&"server"===n.g.process.env.VUE_ENV),Q},se=G&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function re(e){return"function"==typeof e&&/native code/.test(e.toString())}var oe,ue="undefined"!=typeof Symbol&&re(Symbol)&&"undefined"!=typeof Reflect&&re(Reflect.ownKeys);oe="undefined"!=typeof Set&&re(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return!0===this.set[e]},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var pe=null;function de(e){void 0===e&&(e=null),e||pe&&pe._scope.off(),pe=e,e&&e._scope.on()}var le=function(){function e(e,t,n,a,i,s,r,o){this.tag=e,this.data=t,this.children=n,this.text=a,this.elm=i,this.ns=void 0,this.context=s,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=t&&t.key,this.componentOptions=r,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=o,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(e.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),e}(),ye=function(e){void 0===e&&(e="");var t=new le;return t.text=e,t.isComment=!0,t};function ce(e){return new le(void 0,void 0,void 0,String(e))}function me(e){var t=new le(e.tag,e.data,e.children&&e.children.slice(),e.text,e.elm,e.context,e.componentOptions,e.asyncFactory);return t.ns=e.ns,t.isStatic=e.isStatic,t.key=e.key,t.isComment=e.isComment,t.fnContext=e.fnContext,t.fnOptions=e.fnOptions,t.fnScopeId=e.fnScopeId,t.asyncMeta=e.asyncMeta,t.isCloned=!0,t}var fe=0,be=function(){function e(){this.id=fe++,this.subs=[]}return e.prototype.addSub=function(e){this.subs.push(e)},e.prototype.removeSub=function(e){T(this.subs,e)},e.prototype.depend=function(t){e.target&&e.target.addDep(this)},e.prototype.notify=function(e){for(var t=this.subs.slice(),n=0,a=t.length;n<a;n++)t[n].update()},e}();be.target=null;var he=[];function Te(e){he.push(e),be.target=e}function ve(){he.pop(),be.target=he[he.length-1]}var we=Array.prototype,ge=Object.create(we);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(e){var t=we[e];q(ge,e,(function(){for(var n=[],a=0;a<arguments.length;a++)n[a]=arguments[a];var i,s=t.apply(this,n),r=this.__ob__;switch(e){case"push":case"unshift":i=n;break;case"splice":i=n.slice(2)}return i&&r.observeArray(i),r.dep.notify(),s}))}));var ke=Object.getOwnPropertyNames(ge),Me={},Ie=!0;function Re(e){Ie=e}var Ee={notify:C,depend:C,addSub:C,removeSub:C},xe=function(){function e(e,n,a){if(void 0===n&&(n=!1),void 0===a&&(a=!1),this.value=e,this.shallow=n,this.mock=a,this.dep=a?Ee:new be,this.vmCount=0,q(e,"__ob__",this),t(e)){if(!a)if(z)e.__proto__=ge;else for(var i=0,s=ke.length;i<s;i++)q(e,o=ke[i],ge[o]);n||this.observeArray(e)}else{var r=Object.keys(e);for(i=0;i<r.length;i++){var o;Fe(e,o=r[i],Me,void 0,n,a)}}}return e.prototype.observeArray=function(e){for(var t=0,n=e.length;t<n;t++)_e(e[t],!1,this.mock)},e}();function _e(e,n,a){var i;if(!(!u(e)||Pe(e)||e instanceof le))return w(e,"__ob__")&&e.__ob__ instanceof xe?i=e.__ob__:!Ie||!a&&ie()||!t(e)&&!d(e)||!Object.isExtensible(e)||e.__v_skip||(i=new xe(e,n,a)),i}function Fe(e,n,a,i,s,r){var o=new be,u=Object.getOwnPropertyDescriptor(e,n);if(!u||!1!==u.configurable){var p=u&&u.get,d=u&&u.set;p&&!d||a!==Me&&2!==arguments.length||(a=e[n]);var l=!s&&_e(a,!1,r);return Object.defineProperty(e,n,{enumerable:!0,configurable:!0,get:function(){var n=p?p.call(e):a;return be.target&&(o.depend(),l&&(l.dep.depend(),t(n)&&Se(n))),Pe(n)&&!s?n.value:n},set:function(t){var n=p?p.call(e):a;if(D(n,t)){if(d)d.call(e,t);else{if(p)return;if(!s&&Pe(n)&&!Pe(t))return void(n.value=t);a=t}l=!s&&_e(t,!1,r),o.notify()}}}),o}}function Ae(e,n,a){if(!Ne(e)){var i=e.__ob__;return t(e)&&l(n)?(e.length=Math.max(e.length,n),e.splice(n,1,a),i&&!i.shallow&&i.mock&&_e(a,!1,!0),a):n in e&&!(n in Object.prototype)?(e[n]=a,a):e._isVue||i&&i.vmCount?a:i?(Fe(i.value,n,a,void 0,i.shallow,i.mock),i.dep.notify(),a):(e[n]=a,a)}}function Ce(e,n){if(t(e)&&l(n))e.splice(n,1);else{var a=e.__ob__;e._isVue||a&&a.vmCount||Ne(e)||w(e,n)&&(delete e[n],a&&a.dep.notify())}}function Se(e){for(var n=void 0,a=0,i=e.length;a<i;a++)(n=e[a])&&n.__ob__&&n.__ob__.dep.depend(),t(n)&&Se(n)}function Oe(e){return function(e,t){Ne(e)||_e(e,t,ie())}(e,!0),q(e,"__v_isShallow",!0),e}function Ne(e){return!(!e||!e.__v_isReadonly)}function Pe(e){return!(!e||!0!==e.__v_isRef)}function Ue(e,t,n){Object.defineProperty(e,n,{enumerable:!0,configurable:!0,get:function(){var e=t[n];if(Pe(e))return e.value;var a=e&&e.__ob__;return a&&a.dep.depend(),e},set:function(e){var a=t[n];Pe(a)&&!Pe(e)?a.value=e:t[n]=e}})}var De=g((function(e){var t="&"===e.charAt(0),n="~"===(e=t?e.slice(1):e).charAt(0),a="!"===(e=n?e.slice(1):e).charAt(0);return{name:e=a?e.slice(1):e,once:n,capture:a,passive:t}}));function Xe(e,n){function a(){var e=a.fns;if(!t(e))return zt(e,null,arguments,n,"v-on handler");for(var i=e.slice(),s=0;s<i.length;s++)zt(i[s],null,arguments,n,"v-on handler")}return a.fns=e,a}function Ve(e,t,n,i,r,o){var u,p,d,l;for(u in e)p=e[u],d=t[u],l=De(u),a(p)||(a(d)?(a(p.fns)&&(p=e[u]=Xe(p,o)),s(l.once)&&(p=e[u]=r(l.name,p,l.capture)),n(l.name,p,l.capture,l.passive,l.params)):p!==d&&(d.fns=p,e[u]=d));for(u in t)a(e[u])&&i((l=De(u)).name,t[u],l.capture)}function Le(e,t,n){var r;e instanceof le&&(e=e.data.hook||(e.data.hook={}));var o=e[t];function u(){n.apply(this,arguments),T(r.fns,u)}a(o)?r=Xe([u]):i(o.fns)&&s(o.merged)?(r=o).fns.push(u):r=Xe([o,u]),r.merged=!0,e[t]=r}function $e(e,t,n,a,s){if(i(t)){if(w(t,n))return e[n]=t[n],s||delete t[n],!0;if(w(t,a))return e[n]=t[a],s||delete t[a],!0}return!1}function Be(e){return r(e)?[ce(e)]:t(e)?qe(e):void 0}function He(e){return i(e)&&i(e.text)&&!1===e.isComment}function qe(e,n){var o,u,p,d,l=[];for(o=0;o<e.length;o++)a(u=e[o])||"boolean"==typeof u||(d=l[p=l.length-1],t(u)?u.length>0&&(He((u=qe(u,"".concat(n||"","_").concat(o)))[0])&&He(d)&&(l[p]=ce(d.text+u[0].text),u.shift()),l.push.apply(l,u)):r(u)?He(d)?l[p]=ce(d.text+u):""!==u&&l.push(ce(u)):He(u)&&He(d)?l[p]=ce(d.text+u.text):(s(e._isVList)&&i(u.tag)&&a(u.key)&&i(n)&&(u.key="__vlist".concat(n,"_").concat(o,"__")),l.push(u)));return l}function je(e,n,a,p,d,l){return(t(a)||r(a))&&(d=p,p=a,a=void 0),s(l)&&(d=2),function(e,n,a,s,r){if(i(a)&&i(a.__ob__))return ye();if(i(a)&&i(a.is)&&(n=a.is),!n)return ye();var p,d;if(t(s)&&o(s[0])&&((a=a||{}).scopedSlots={default:s[0]},s.length=0),2===r?s=Be(s):1===r&&(s=function(e){for(var n=0;n<e.length;n++)if(t(e[n]))return Array.prototype.concat.apply([],e);return e}(s)),"string"==typeof n){var l=void 0;d=e.$vnode&&e.$vnode.ns||$.getTagNamespace(n),p=$.isReservedTag(n)?new le($.parsePlatformTagName(n),a,s,void 0,void 0,e):a&&a.pre||!i(l=Vn(e.$options,"components",n))?new le(n,a,s,void 0,void 0,e):Fn(l,a,e,s,n)}else p=Fn(n,a,e,s);return t(p)?p:i(p)?(i(d)&&ze(p,d),i(a)&&function(e){u(e.style)&&un(e.style),u(e.class)&&un(e.class)}(a),p):ye()}(e,n,a,p,d)}function ze(e,t,n){if(e.ns=t,"foreignObject"===e.tag&&(t=void 0,n=!0),i(e.children))for(var r=0,o=e.children.length;r<o;r++){var u=e.children[r];i(u.tag)&&(a(u.ns)||s(n)&&"svg"!==u.tag)&&ze(u,t,n)}}function Ge(e,n){var a,s,r,o,p=null;if(t(e)||"string"==typeof e)for(p=new Array(e.length),a=0,s=e.length;a<s;a++)p[a]=n(e[a],a);else if("number"==typeof e)for(p=new Array(e),a=0;a<e;a++)p[a]=n(a+1,a);else if(u(e))if(ue&&e[Symbol.iterator]){p=[];for(var d=e[Symbol.iterator](),l=d.next();!l.done;)p.push(n(l.value,p.length)),l=d.next()}else for(r=Object.keys(e),p=new Array(r.length),a=0,s=r.length;a<s;a++)o=r[a],p[a]=n(e[o],o,a);return i(p)||(p=[]),p._isVList=!0,p}function We(e,t,n,a){var i,s=this.$scopedSlots[e];s?(n=n||{},a&&(n=F(F({},a),n)),i=s(n)||(o(t)?t():t)):i=this.$slots[e]||(o(t)?t():t);var r=n&&n.slot;return r?this.$createElement("template",{slot:r},i):i}function Ze(e){return Vn(this.$options,"filters",e)||O}function Ke(e,n){return t(e)?-1===e.indexOf(n):e!==n}function Je(e,t,n,a,i){var s=$.keyCodes[t]||n;return i&&a&&!$.keyCodes[t]?Ke(i,a):s?Ke(s,e):a?E(a)!==t:void 0===e}function Ye(e,n,a,i,s){if(a&&u(a)){t(a)&&(a=A(a));var r=void 0,o=function(t){if("class"===t||"style"===t||h(t))r=e;else{var o=e.attrs&&e.attrs.type;r=i||$.mustUseProp(n,o,t)?e.domProps||(e.domProps={}):e.attrs||(e.attrs={})}var u=M(t),p=E(t);u in r||p in r||(r[t]=a[t],s&&((e.on||(e.on={}))["update:".concat(t)]=function(e){a[t]=e}))};for(var p in a)o(p)}return e}function Qe(e,t){var n=this._staticTrees||(this._staticTrees=[]),a=n[e];return a&&!t||tt(a=n[e]=this.$options.staticRenderFns[e].call(this._renderProxy,this._c,this),"__static__".concat(e),!1),a}function et(e,t,n){return tt(e,"__once__".concat(t).concat(n?"_".concat(n):""),!0),e}function tt(e,n,a){if(t(e))for(var i=0;i<e.length;i++)e[i]&&"string"!=typeof e[i]&&nt(e[i],"".concat(n,"_").concat(i),a);else nt(e,n,a)}function nt(e,t,n){e.isStatic=!0,e.key=t,e.isOnce=n}function at(e,t){if(t&&d(t)){var n=e.on=e.on?F({},e.on):{};for(var a in t){var i=n[a],s=t[a];n[a]=i?[].concat(i,s):s}}return e}function it(e,n,a,i){n=n||{$stable:!a};for(var s=0;s<e.length;s++){var r=e[s];t(r)?it(r,n,a):r&&(r.proxy&&(r.fn.proxy=!0),n[r.key]=r.fn)}return i&&(n.$key=i),n}function st(e,t){for(var n=0;n<t.length;n+=2){var a=t[n];"string"==typeof a&&a&&(e[t[n]]=t[n+1])}return e}function rt(e,t){return"string"==typeof e?t+e:e}function ot(e){e._o=et,e._n=m,e._s=c,e._l=Ge,e._t=We,e._q=N,e._i=P,e._m=Qe,e._f=Ze,e._k=Je,e._b=Ye,e._v=ce,e._e=ye,e._u=it,e._g=at,e._d=st,e._p=rt}function ut(e,t){if(!e||!e.length)return{};for(var n={},a=0,i=e.length;a<i;a++){var s=e[a],r=s.data;if(r&&r.attrs&&r.attrs.slot&&delete r.attrs.slot,s.context!==t&&s.fnContext!==t||!r||null==r.slot)(n.default||(n.default=[])).push(s);else{var o=r.slot,u=n[o]||(n[o]=[]);"template"===s.tag?u.push.apply(u,s.children||[]):u.push(s)}}for(var p in n)n[p].every(pt)&&delete n[p];return n}function pt(e){return e.isComment&&!e.asyncFactory||" "===e.text}function dt(e){return e.isComment&&e.asyncFactory}function lt(t,n,a,i){var s,r=Object.keys(a).length>0,o=n?!!n.$stable:!r,u=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(o&&i&&i!==e&&u===i.$key&&!r&&!i.$hasNormal)return i;for(var p in s={},n)n[p]&&"$"!==p[0]&&(s[p]=yt(t,a,p,n[p]))}else s={};for(var d in a)d in s||(s[d]=ct(a,d));return n&&Object.isExtensible(n)&&(n._normalized=s),q(s,"$stable",o),q(s,"$key",u),q(s,"$hasNormal",r),s}function yt(e,n,a,i){var s=function(){var n=pe;de(e);var a=arguments.length?i.apply(null,arguments):i({}),s=(a=a&&"object"==typeof a&&!t(a)?[a]:Be(a))&&a[0];return de(n),a&&(!s||1===a.length&&s.isComment&&!dt(s))?void 0:a};return i.proxy&&Object.defineProperty(n,a,{get:s,enumerable:!0,configurable:!0}),s}function ct(e,t){return function(){return e[t]}}function mt(e,t,n,a,i){var s=!1;for(var r in t)r in e?t[r]!==n[r]&&(s=!0):(s=!0,ft(e,r,a,i));for(var r in e)r in t||(s=!0,delete e[r]);return s}function ft(e,t,n,a){Object.defineProperty(e,t,{enumerable:!0,configurable:!0,get:function(){return n[a][t]}})}function bt(e,t){for(var n in t)e[n]=t[n];for(var n in e)n in t||delete e[n]}var ht,Tt=null;function vt(e,t){return(e.__esModule||ue&&"Module"===e[Symbol.toStringTag])&&(e=e.default),u(e)?t.extend(e):e}function wt(e){if(t(e))for(var n=0;n<e.length;n++){var a=e[n];if(i(a)&&(i(a.componentOptions)||dt(a)))return a}}function gt(e,t){ht.$on(e,t)}function kt(e,t){ht.$off(e,t)}function Mt(e,t){var n=ht;return function a(){var i=t.apply(null,arguments);null!==i&&n.$off(e,a)}}function It(e,t,n){ht=e,Ve(t,n||{},gt,kt,Mt,e),ht=void 0}var Rt=null;function Et(e){var t=Rt;return Rt=e,function(){Rt=t}}function xt(e){for(;e&&(e=e.$parent);)if(e._inactive)return!0;return!1}function _t(e,t){if(t){if(e._directInactive=!1,xt(e))return}else if(e._directInactive)return;if(e._inactive||null===e._inactive){e._inactive=!1;for(var n=0;n<e.$children.length;n++)_t(e.$children[n]);At(e,"activated")}}function Ft(e,t){if(!(t&&(e._directInactive=!0,xt(e))||e._inactive)){e._inactive=!0;for(var n=0;n<e.$children.length;n++)Ft(e.$children[n]);At(e,"deactivated")}}function At(e,t,n,a){void 0===a&&(a=!0),Te();var i=pe;a&&de(e);var s=e.$options[t],r="".concat(t," hook");if(s)for(var o=0,u=s.length;o<u;o++)zt(s[o],e,n||null,e,r);e._hasHookEvent&&e.$emit("hook:"+t),a&&de(i),ve()}var Ct=[],St=[],Ot={},Nt=!1,Pt=!1,Ut=0,Dt=0,Xt=Date.now;if(G&&!Z){var Vt=window.performance;Vt&&"function"==typeof Vt.now&&Xt()>document.createEvent("Event").timeStamp&&(Xt=function(){return Vt.now()})}var Lt=function(e,t){if(e.post){if(!t.post)return 1}else if(t.post)return-1;return e.id-t.id};function $t(){var e,t;for(Dt=Xt(),Pt=!0,Ct.sort(Lt),Ut=0;Ut<Ct.length;Ut++)(e=Ct[Ut]).before&&e.before(),t=e.id,Ot[t]=null,e.run();var n=St.slice(),a=Ct.slice();Ut=Ct.length=St.length=0,Ot={},Nt=Pt=!1,function(e){for(var t=0;t<e.length;t++)e[t]._inactive=!0,_t(e[t],!0)}(n),function(e){for(var t=e.length;t--;){var n=e[t],a=n.vm;a&&a._watcher===n&&a._isMounted&&!a._isDestroyed&&At(a,"updated")}}(a),se&&$.devtools&&se.emit("flush")}var Bt,Ht="watcher";"".concat(Ht," callback"),"".concat(Ht," getter"),"".concat(Ht," cleanup");var qt=function(){function e(e){void 0===e&&(e=!1),this.active=!0,this.effects=[],this.cleanups=[],!e&&Bt&&(this.parent=Bt,this.index=(Bt.scopes||(Bt.scopes=[])).push(this)-1)}return e.prototype.run=function(e){if(this.active){var t=Bt;try{return Bt=this,e()}finally{Bt=t}}},e.prototype.on=function(){Bt=this},e.prototype.off=function(){Bt=this.parent},e.prototype.stop=function(e){if(this.active){var t=void 0,n=void 0;for(t=0,n=this.effects.length;t<n;t++)this.effects[t].teardown();for(t=0,n=this.cleanups.length;t<n;t++)this.cleanups[t]();if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].stop(!0);if(this.parent&&!e){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.active=!1}},e}();function jt(e,t,n){Te();try{if(t)for(var a=t;a=a.$parent;){var i=a.$options.errorCaptured;if(i)for(var s=0;s<i.length;s++)try{if(!1===i[s].call(a,e,t,n))return}catch(e){Gt(e,a,"errorCaptured hook")}}Gt(e,t,n)}finally{ve()}}function zt(e,t,n,a,i){var s;try{(s=n?e.apply(t,n):e.call(t))&&!s._isVue&&y(s)&&!s._handled&&(s.catch((function(e){return jt(e,a,i+" (Promise/async)")})),s._handled=!0)}catch(e){jt(e,a,i)}return s}function Gt(e,t,n){if($.errorHandler)try{return $.errorHandler.call(null,e,t,n)}catch(t){t!==e&&Wt(t)}Wt(e)}function Wt(e,t,n){if(!G||"undefined"==typeof console)throw e;console.error(e)}var Zt,Kt=!1,Jt=[],Yt=!1;function Qt(){Yt=!1;var e=Jt.slice(0);Jt.length=0;for(var t=0;t<e.length;t++)e[t]()}if("undefined"!=typeof Promise&&re(Promise)){var en=Promise.resolve();Zt=function(){en.then(Qt),Y&&setTimeout(C)},Kt=!0}else if(Z||"undefined"==typeof MutationObserver||!re(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Zt="undefined"!=typeof setImmediate&&re(setImmediate)?function(){setImmediate(Qt)}:function(){setTimeout(Qt,0)};else{var tn=1,nn=new MutationObserver(Qt),an=document.createTextNode(String(tn));nn.observe(an,{characterData:!0}),Zt=function(){tn=(tn+1)%2,an.data=String(tn)},Kt=!0}function sn(e,t){var n;if(Jt.push((function(){if(e)try{e.call(t)}catch(e){jt(e,t,"nextTick")}else n&&n(t)})),Yt||(Yt=!0,Zt()),!e&&"undefined"!=typeof Promise)return new Promise((function(e){n=e}))}function rn(e){return function(t,n){if(void 0===n&&(n=pe),n)return function(e,t,n){var a=e.$options;a[t]=Pn(a[t],n)}(n,e,t)}}rn("beforeMount"),rn("mounted"),rn("beforeUpdate"),rn("updated"),rn("beforeDestroy"),rn("destroyed"),rn("errorCaptured"),rn("activated"),rn("deactivated"),rn("serverPrefetch"),rn("renderTracked"),rn("renderTriggered");var on=new oe;function un(e){return pn(e,on),on.clear(),e}function pn(e,n){var a,i,s=t(e);if(!(!s&&!u(e)||Object.isFrozen(e)||e instanceof le)){if(e.__ob__){var r=e.__ob__.dep.id;if(n.has(r))return;n.add(r)}if(s)for(a=e.length;a--;)pn(e[a],n);else if(Pe(e))pn(e.value,n);else for(a=(i=Object.keys(e)).length;a--;)pn(e[i[a]],n)}}var dn=0,ln=function(){function e(e,t,n,a,i){var s;void 0===(s=Bt||(e?e._scope:void 0))&&(s=Bt),s&&s.active&&s.effects.push(this),(this.vm=e)&&i&&(e._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++dn,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new oe,this.newDepIds=new oe,this.expression="",o(t)?this.getter=t:(this.getter=function(e){if(!j.test(e)){var t=e.split(".");return function(e){for(var n=0;n<t.length;n++){if(!e)return;e=e[t[n]]}return e}}}(t),this.getter||(this.getter=C)),this.value=this.lazy?void 0:this.get()}return e.prototype.get=function(){var e;Te(this);var t=this.vm;try{e=this.getter.call(t,t)}catch(e){if(!this.user)throw e;jt(e,t,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&un(e),ve(),this.cleanupDeps()}return e},e.prototype.addDep=function(e){var t=e.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(e),this.depIds.has(t)||e.addSub(this))},e.prototype.cleanupDeps=function(){for(var e=this.deps.length;e--;){var t=this.deps[e];this.newDepIds.has(t.id)||t.removeSub(this)}var n=this.depIds;this.depIds=this.newDepIds,this.newDepIds=n,this.newDepIds.clear(),n=this.deps,this.deps=this.newDeps,this.newDeps=n,this.newDeps.length=0},e.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(e){var t=e.id;if(null==Ot[t]&&(e!==be.target||!e.noRecurse)){if(Ot[t]=!0,Pt){for(var n=Ct.length-1;n>Ut&&Ct[n].id>e.id;)n--;Ct.splice(n+1,0,e)}else Ct.push(e);Nt||(Nt=!0,sn($t))}}(this)},e.prototype.run=function(){if(this.active){var e=this.get();if(e!==this.value||u(e)||this.deep){var t=this.value;if(this.value=e,this.user){var n='callback for watcher "'.concat(this.expression,'"');zt(this.cb,this.vm,[e,t],this.vm,n)}else this.cb.call(this.vm,e,t)}}},e.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},e.prototype.depend=function(){for(var e=this.deps.length;e--;)this.deps[e].depend()},e.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&T(this.vm._scope.effects,this),this.active){for(var e=this.deps.length;e--;)this.deps[e].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},e}(),yn={enumerable:!0,configurable:!0,get:C,set:C};function cn(e,t,n){yn.get=function(){return this[t][n]},yn.set=function(e){this[t][n]=e},Object.defineProperty(e,n,yn)}function mn(n){var a=n.$options;if(a.props&&function(e,t){var n=e.$options.propsData||{},a=e._props=Oe({}),i=e.$options._propKeys=[];e.$parent&&Re(!1);var s=function(s){i.push(s);var r=Ln(s,t,n,e);Fe(a,s,r),s in e||cn(e,"_props",s)};for(var r in t)s(r);Re(!0)}(n,a.props),function(t){var n=t.$options,a=n.setup;if(a){var i=t._setupContext=function(t){return{get attrs(){if(!t._attrsProxy){var n=t._attrsProxy={};q(n,"_v_attr_proxy",!0),mt(n,t.$attrs,e,t,"$attrs")}return t._attrsProxy},get listeners(){return t._listenersProxy||mt(t._listenersProxy={},t.$listeners,e,t,"$listeners"),t._listenersProxy},get slots(){return function(e){return e._slotsProxy||bt(e._slotsProxy={},e.$scopedSlots),e._slotsProxy}(t)},emit:x(t.$emit,t),expose:function(e){e&&Object.keys(e).forEach((function(n){return Ue(t,e,n)}))}}}(t);de(t),Te();var s=zt(a,null,[t._props||Oe({}),i],t,"setup");if(ve(),de(),o(s))n.render=s;else if(u(s))if(t._setupState=s,s.__sfc){var r=t._setupProxy={};for(var p in s)"__sfc"!==p&&Ue(r,s,p)}else for(var p in s)H(p)||Ue(t,s,p)}}(n),a.methods&&function(e,t){for(var n in e.$options.props,t)e[n]="function"!=typeof t[n]?C:x(t[n],e)}(n,a.methods),a.data)!function(e){var t=e.$options.data;d(t=e._data=o(t)?function(e,t){Te();try{return e.call(t,t)}catch(e){return jt(e,t,"data()"),{}}finally{ve()}}(t,e):t||{})||(t={});for(var n=Object.keys(t),a=e.$options.props,i=(e.$options.methods,n.length);i--;){var s=n[i];a&&w(a,s)||H(s)||cn(e,"_data",s)}var r=_e(t);r&&r.vmCount++}(n);else{var i=_e(n._data={});i&&i.vmCount++}a.computed&&function(e,t){var n=e._computedWatchers=Object.create(null),a=ie();for(var i in t){var s=t[i],r=o(s)?s:s.get;a||(n[i]=new ln(e,r||C,C,fn)),i in e||bn(e,i,s)}}(n,a.computed),a.watch&&a.watch!==te&&function(e,n){for(var a in n){var i=n[a];if(t(i))for(var s=0;s<i.length;s++)vn(e,a,i[s]);else vn(e,a,i)}}(n,a.watch)}var fn={lazy:!0};function bn(e,t,n){var a=!ie();o(n)?(yn.get=a?hn(t):Tn(n),yn.set=C):(yn.get=n.get?a&&!1!==n.cache?hn(t):Tn(n.get):C,yn.set=n.set||C),Object.defineProperty(e,t,yn)}function hn(e){return function(){var t=this._computedWatchers&&this._computedWatchers[e];if(t)return t.dirty&&t.evaluate(),be.target&&t.depend(),t.value}}function Tn(e){return function(){return e.call(this,this)}}function vn(e,t,n,a){return d(n)&&(a=n,n=n.handler),"string"==typeof n&&(n=e[n]),e.$watch(t,n,a)}function wn(e,t){if(e){for(var n=Object.create(null),a=ue?Reflect.ownKeys(e):Object.keys(e),i=0;i<a.length;i++){var s=a[i];if("__ob__"!==s){var r=e[s].from;if(r in t._provided)n[s]=t._provided[r];else if("default"in e[s]){var u=e[s].default;n[s]=o(u)?u.call(t):u}}}return n}}var gn=0;function kn(e){var t=e.options;if(e.super){var n=kn(e.super);if(n!==e.superOptions){e.superOptions=n;var a=function(e){var t,n=e.options,a=e.sealedOptions;for(var i in n)n[i]!==a[i]&&(t||(t={}),t[i]=n[i]);return t}(e);a&&F(e.extendOptions,a),(t=e.options=Xn(n,e.extendOptions)).name&&(t.components[t.name]=e)}}return t}function Mn(n,a,i,r,o){var u,p=this,d=o.options;w(r,"_uid")?(u=Object.create(r))._original=r:(u=r,r=r._original);var l=s(d._compiled),y=!l;this.data=n,this.props=a,this.children=i,this.parent=r,this.listeners=n.on||e,this.injections=wn(d.inject,r),this.slots=function(){return p.$slots||lt(r,n.scopedSlots,p.$slots=ut(i,r)),p.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return lt(r,n.scopedSlots,this.slots())}}),l&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=lt(r,n.scopedSlots,this.$slots)),d._scopeId?this._c=function(e,n,a,i){var s=je(u,e,n,a,i,y);return s&&!t(s)&&(s.fnScopeId=d._scopeId,s.fnContext=r),s}:this._c=function(e,t,n,a){return je(u,e,t,n,a,y)}}function In(e,t,n,a,i){var s=me(e);return s.fnContext=n,s.fnOptions=a,t.slot&&((s.data||(s.data={})).slot=t.slot),s}function Rn(e,t){for(var n in t)e[M(n)]=t[n]}function En(e){return e.name||e.__name||e._componentTag}ot(Mn.prototype);var xn={init:function(e,t){if(e.componentInstance&&!e.componentInstance._isDestroyed&&e.data.keepAlive){var n=e;xn.prepatch(n,n)}else(e.componentInstance=function(e,t){var n={_isComponent:!0,_parentVnode:e,parent:t},a=e.data.inlineTemplate;return i(a)&&(n.render=a.render,n.staticRenderFns=a.staticRenderFns),new e.componentOptions.Ctor(n)}(e,Rt)).$mount(t?e.elm:void 0,t)},prepatch:function(t,n){var a=n.componentOptions;!function(t,n,a,i,s){var r=i.data.scopedSlots,o=t.$scopedSlots,u=!!(r&&!r.$stable||o!==e&&!o.$stable||r&&t.$scopedSlots.$key!==r.$key||!r&&t.$scopedSlots.$key),p=!!(s||t.$options._renderChildren||u),d=t.$vnode;t.$options._parentVnode=i,t.$vnode=i,t._vnode&&(t._vnode.parent=i),t.$options._renderChildren=s;var l=i.data.attrs||e;t._attrsProxy&&mt(t._attrsProxy,l,d.data&&d.data.attrs||e,t,"$attrs")&&(p=!0),t.$attrs=l,a=a||e;var y=t.$options._parentListeners;if(t._listenersProxy&&mt(t._listenersProxy,a,y||e,t,"$listeners"),t.$listeners=t.$options._parentListeners=a,It(t,a,y),n&&t.$options.props){Re(!1);for(var c=t._props,m=t.$options._propKeys||[],f=0;f<m.length;f++){var b=m[f],h=t.$options.props;c[b]=Ln(b,h,n,t)}Re(!0),t.$options.propsData=n}p&&(t.$slots=ut(s,i.context),t.$forceUpdate())}(n.componentInstance=t.componentInstance,a.propsData,a.listeners,n,a.children)},insert:function(e){var t,n=e.context,a=e.componentInstance;a._isMounted||(a._isMounted=!0,At(a,"mounted")),e.data.keepAlive&&(n._isMounted?((t=a)._inactive=!1,St.push(t)):_t(a,!0))},destroy:function(e){var t=e.componentInstance;t._isDestroyed||(e.data.keepAlive?Ft(t,!0):t.$destroy())}},_n=Object.keys(xn);function Fn(n,r,o,p,d){if(!a(n)){var l=o.$options._base;if(u(n)&&(n=l.extend(n)),"function"==typeof n){var c;if(a(n.cid)&&(n=function(e,t){if(s(e.error)&&i(e.errorComp))return e.errorComp;if(i(e.resolved))return e.resolved;var n=Tt;if(n&&i(e.owners)&&-1===e.owners.indexOf(n)&&e.owners.push(n),s(e.loading)&&i(e.loadingComp))return e.loadingComp;if(n&&!i(e.owners)){var r=e.owners=[n],o=!0,p=null,d=null;n.$on("hook:destroyed",(function(){return T(r,n)}));var l=function(e){for(var t=0,n=r.length;t<n;t++)r[t].$forceUpdate();e&&(r.length=0,null!==p&&(clearTimeout(p),p=null),null!==d&&(clearTimeout(d),d=null))},c=U((function(n){e.resolved=vt(n,t),o?r.length=0:l(!0)})),m=U((function(t){i(e.errorComp)&&(e.error=!0,l(!0))})),f=e(c,m);return u(f)&&(y(f)?a(e.resolved)&&f.then(c,m):y(f.component)&&(f.component.then(c,m),i(f.error)&&(e.errorComp=vt(f.error,t)),i(f.loading)&&(e.loadingComp=vt(f.loading,t),0===f.delay?e.loading=!0:p=setTimeout((function(){p=null,a(e.resolved)&&a(e.error)&&(e.loading=!0,l(!1))}),f.delay||200)),i(f.timeout)&&(d=setTimeout((function(){d=null,a(e.resolved)&&m(null)}),f.timeout)))),o=!1,e.loading?e.loadingComp:e.resolved}}(c=n,l),void 0===n))return function(e,t,n,a,i){var s=ye();return s.asyncFactory=e,s.asyncMeta={data:t,context:n,children:a,tag:i},s}(c,r,o,p,d);r=r||{},kn(n),i(r.model)&&function(e,n){var a=e.model&&e.model.prop||"value",s=e.model&&e.model.event||"input";(n.attrs||(n.attrs={}))[a]=n.model.value;var r=n.on||(n.on={}),o=r[s],u=n.model.callback;i(o)?(t(o)?-1===o.indexOf(u):o!==u)&&(r[s]=[u].concat(o)):r[s]=u}(n.options,r);var m=function(e,t,n){var s=t.options.props;if(!a(s)){var r={},o=e.attrs,u=e.props;if(i(o)||i(u))for(var p in s){var d=E(p);$e(r,u,p,d,!0)||$e(r,o,p,d,!1)}return r}}(r,n);if(s(n.options.functional))return function(n,a,s,r,o){var u=n.options,p={},d=u.props;if(i(d))for(var l in d)p[l]=Ln(l,d,a||e);else i(s.attrs)&&Rn(p,s.attrs),i(s.props)&&Rn(p,s.props);var y=new Mn(s,p,o,r,n),c=u.render.call(null,y._c,y);if(c instanceof le)return In(c,s,y.parent,u);if(t(c)){for(var m=Be(c)||[],f=new Array(m.length),b=0;b<m.length;b++)f[b]=In(m[b],s,y.parent,u);return f}}(n,m,r,o,p);var f=r.on;if(r.on=r.nativeOn,s(n.options.abstract)){var b=r.slot;r={},b&&(r.slot=b)}!function(e){for(var t=e.hook||(e.hook={}),n=0;n<_n.length;n++){var a=_n[n],i=t[a],s=xn[a];i===s||i&&i._merged||(t[a]=i?An(s,i):s)}}(r);var h=En(n.options)||d;return new le("vue-component-".concat(n.cid).concat(h?"-".concat(h):""),r,void 0,void 0,void 0,o,{Ctor:n,propsData:m,listeners:f,tag:d,children:p},c)}}}function An(e,t){var n=function(n,a){e(n,a),t(n,a)};return n._merged=!0,n}var Cn=C,Sn=$.optionMergeStrategies;function On(e,t){if(!t)return e;for(var n,a,i,s=ue?Reflect.ownKeys(t):Object.keys(t),r=0;r<s.length;r++)"__ob__"!==(n=s[r])&&(a=e[n],i=t[n],w(e,n)?a!==i&&d(a)&&d(i)&&On(a,i):Ae(e,n,i));return e}function Nn(e,t,n){return n?function(){var a=o(t)?t.call(n,n):t,i=o(e)?e.call(n,n):e;return a?On(a,i):i}:t?e?function(){return On(o(t)?t.call(this,this):t,o(e)?e.call(this,this):e)}:t:e}function Pn(e,n){var a=n?e?e.concat(n):t(n)?n:[n]:e;return a?function(e){for(var t=[],n=0;n<e.length;n++)-1===t.indexOf(e[n])&&t.push(e[n]);return t}(a):a}function Un(e,t,n,a){var i=Object.create(e||null);return t?F(i,t):i}Sn.data=function(e,t,n){return n?Nn(e,t,n):t&&"function"!=typeof t?e:Nn(e,t)},L.forEach((function(e){Sn[e]=Pn})),V.forEach((function(e){Sn[e+"s"]=Un})),Sn.watch=function(e,n,a,i){if(e===te&&(e=void 0),n===te&&(n=void 0),!n)return Object.create(e||null);if(!e)return n;var s={};for(var r in F(s,e),n){var o=s[r],u=n[r];o&&!t(o)&&(o=[o]),s[r]=o?o.concat(u):t(u)?u:[u]}return s},Sn.props=Sn.methods=Sn.inject=Sn.computed=function(e,t,n,a){if(!e)return t;var i=Object.create(null);return F(i,e),t&&F(i,t),i},Sn.provide=Nn;var Dn=function(e,t){return void 0===t?e:t};function Xn(e,n,a){if(o(n)&&(n=n.options),function(e,n){var a=e.props;if(a){var i,s,r={};if(t(a))for(i=a.length;i--;)"string"==typeof(s=a[i])&&(r[M(s)]={type:null});else if(d(a))for(var o in a)s=a[o],r[M(o)]=d(s)?s:{type:s};e.props=r}}(n),function(e,n){var a=e.inject;if(a){var i=e.inject={};if(t(a))for(var s=0;s<a.length;s++)i[a[s]]={from:a[s]};else if(d(a))for(var r in a){var o=a[r];i[r]=d(o)?F({from:r},o):{from:o}}}}(n),function(e){var t=e.directives;if(t)for(var n in t){var a=t[n];o(a)&&(t[n]={bind:a,update:a})}}(n),!n._base&&(n.extends&&(e=Xn(e,n.extends,a)),n.mixins))for(var i=0,s=n.mixins.length;i<s;i++)e=Xn(e,n.mixins[i],a);var r,u={};for(r in e)p(r);for(r in n)w(e,r)||p(r);function p(t){var i=Sn[t]||Dn;u[t]=i(e[t],n[t],a,t)}return u}function Vn(e,t,n,a){if("string"==typeof n){var i=e[t];if(w(i,n))return i[n];var s=M(n);if(w(i,s))return i[s];var r=I(s);return w(i,r)?i[r]:i[n]||i[s]||i[r]}}function Ln(e,t,n,a){var i=t[e],s=!w(n,e),r=n[e],u=qn(Boolean,i.type);if(u>-1)if(s&&!w(i,"default"))r=!1;else if(""===r||r===E(e)){var p=qn(String,i.type);(p<0||u<p)&&(r=!0)}if(void 0===r){r=function(e,t,n){if(w(t,"default")){var a=t.default;return e&&e.$options.propsData&&void 0===e.$options.propsData[n]&&void 0!==e._props[n]?e._props[n]:o(a)&&"Function"!==Bn(t.type)?a.call(e):a}}(a,i,e);var d=Ie;Re(!0),_e(r),Re(d)}return r}var $n=/^\s*function (\w+)/;function Bn(e){var t=e&&e.toString().match($n);return t?t[1]:""}function Hn(e,t){return Bn(e)===Bn(t)}function qn(e,n){if(!t(n))return Hn(n,e)?0:-1;for(var a=0,i=n.length;a<i;a++)if(Hn(n[a],e))return a;return-1}function jn(e){this._init(e)}function zn(e){return e&&(En(e.Ctor.options)||e.tag)}function Gn(e,n){return t(e)?e.indexOf(n)>-1:"string"==typeof e?e.split(",").indexOf(n)>-1:(a=e,!("[object RegExp]"!==p.call(a))&&e.test(n));var a}function Wn(e,t){var n=e.cache,a=e.keys,i=e._vnode;for(var s in n){var r=n[s];if(r){var o=r.name;o&&!t(o)&&Zn(n,s,a,i)}}}function Zn(e,t,n,a){var i=e[t];!i||a&&i.tag===a.tag||i.componentInstance.$destroy(),e[t]=null,T(n,t)}!function(t){t.prototype._init=function(t){var n=this;n._uid=gn++,n._isVue=!0,n.__v_skip=!0,n._scope=new qt(!0),t&&t._isComponent?function(e,t){var n=e.$options=Object.create(e.constructor.options),a=t._parentVnode;n.parent=t.parent,n._parentVnode=a;var i=a.componentOptions;n.propsData=i.propsData,n._parentListeners=i.listeners,n._renderChildren=i.children,n._componentTag=i.tag,t.render&&(n.render=t.render,n.staticRenderFns=t.staticRenderFns)}(n,t):n.$options=Xn(kn(n.constructor),t||{},n),n._renderProxy=n,n._self=n,function(e){var t=e.$options,n=t.parent;if(n&&!t.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(e)}e.$parent=n,e.$root=n?n.$root:e,e.$children=[],e.$refs={},e._provided=n?n._provided:Object.create(null),e._watcher=null,e._inactive=null,e._directInactive=!1,e._isMounted=!1,e._isDestroyed=!1,e._isBeingDestroyed=!1}(n),function(e){e._events=Object.create(null),e._hasHookEvent=!1;var t=e.$options._parentListeners;t&&It(e,t)}(n),function(t){t._vnode=null,t._staticTrees=null;var n=t.$options,a=t.$vnode=n._parentVnode,i=a&&a.context;t.$slots=ut(n._renderChildren,i),t.$scopedSlots=a?lt(t.$parent,a.data.scopedSlots,t.$slots):e,t._c=function(e,n,a,i){return je(t,e,n,a,i,!1)},t.$createElement=function(e,n,a,i){return je(t,e,n,a,i,!0)};var s=a&&a.data;Fe(t,"$attrs",s&&s.attrs||e,null,!0),Fe(t,"$listeners",n._parentListeners||e,null,!0)}(n),At(n,"beforeCreate",void 0,!1),function(e){var t=wn(e.$options.inject,e);t&&(Re(!1),Object.keys(t).forEach((function(n){Fe(e,n,t[n])})),Re(!0))}(n),mn(n),function(e){var t=e.$options.provide;if(t){var n=o(t)?t.call(e):t;if(!u(n))return;for(var a=function(e){var t=e._provided,n=e.$parent&&e.$parent._provided;return n===t?e._provided=Object.create(n):t}(e),i=ue?Reflect.ownKeys(n):Object.keys(n),s=0;s<i.length;s++){var r=i[s];Object.defineProperty(a,r,Object.getOwnPropertyDescriptor(n,r))}}}(n),At(n,"created"),n.$options.el&&n.$mount(n.$options.el)}}(jn),function(e){Object.defineProperty(e.prototype,"$data",{get:function(){return this._data}}),Object.defineProperty(e.prototype,"$props",{get:function(){return this._props}}),e.prototype.$set=Ae,e.prototype.$delete=Ce,e.prototype.$watch=function(e,t,n){var a=this;if(d(t))return vn(a,e,t,n);(n=n||{}).user=!0;var i=new ln(a,e,t,n);if(n.immediate){var s='callback for immediate watcher "'.concat(i.expression,'"');Te(),zt(t,a,[i.value],a,s),ve()}return function(){i.teardown()}}}(jn),function(e){var n=/^hook:/;e.prototype.$on=function(e,a){var i=this;if(t(e))for(var s=0,r=e.length;s<r;s++)i.$on(e[s],a);else(i._events[e]||(i._events[e]=[])).push(a),n.test(e)&&(i._hasHookEvent=!0);return i},e.prototype.$once=function(e,t){var n=this;function a(){n.$off(e,a),t.apply(n,arguments)}return a.fn=t,n.$on(e,a),n},e.prototype.$off=function(e,n){var a=this;if(!arguments.length)return a._events=Object.create(null),a;if(t(e)){for(var i=0,s=e.length;i<s;i++)a.$off(e[i],n);return a}var r,o=a._events[e];if(!o)return a;if(!n)return a._events[e]=null,a;for(var u=o.length;u--;)if((r=o[u])===n||r.fn===n){o.splice(u,1);break}return a},e.prototype.$emit=function(e){var t=this,n=t._events[e];if(n){n=n.length>1?_(n):n;for(var a=_(arguments,1),i='event handler for "'.concat(e,'"'),s=0,r=n.length;s<r;s++)zt(n[s],t,a,t,i)}return t}}(jn),function(e){e.prototype._update=function(e,t){var n=this,a=n.$el,i=n._vnode,s=Et(n);n._vnode=e,n.$el=i?n.__patch__(i,e):n.__patch__(n.$el,e,t,!1),s(),a&&(a.__vue__=null),n.$el&&(n.$el.__vue__=n),n.$vnode&&n.$parent&&n.$vnode===n.$parent._vnode&&(n.$parent.$el=n.$el)},e.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},e.prototype.$destroy=function(){var e=this;if(!e._isBeingDestroyed){At(e,"beforeDestroy"),e._isBeingDestroyed=!0;var t=e.$parent;!t||t._isBeingDestroyed||e.$options.abstract||T(t.$children,e),e._scope.stop(),e._data.__ob__&&e._data.__ob__.vmCount--,e._isDestroyed=!0,e.__patch__(e._vnode,null),At(e,"destroyed"),e.$off(),e.$el&&(e.$el.__vue__=null),e.$vnode&&(e.$vnode.parent=null)}}}(jn),function(e){ot(e.prototype),e.prototype.$nextTick=function(e){return sn(e,this)},e.prototype._render=function(){var e,n=this,a=n.$options,i=a.render,s=a._parentVnode;s&&n._isMounted&&(n.$scopedSlots=lt(n.$parent,s.data.scopedSlots,n.$slots,n.$scopedSlots),n._slotsProxy&&bt(n._slotsProxy,n.$scopedSlots)),n.$vnode=s;try{de(n),Tt=n,e=i.call(n._renderProxy,n.$createElement)}catch(t){jt(t,n,"render"),e=n._vnode}finally{Tt=null,de()}return t(e)&&1===e.length&&(e=e[0]),e instanceof le||(e=ye()),e.parent=s,e}}(jn);var Kn=[String,RegExp,Array],Jn={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Kn,exclude:Kn,max:[String,Number]},methods:{cacheVNode:function(){var e=this,t=e.cache,n=e.keys,a=e.vnodeToCache,i=e.keyToCache;if(a){var s=a.tag,r=a.componentInstance,o=a.componentOptions;t[i]={name:zn(o),tag:s,componentInstance:r},n.push(i),this.max&&n.length>parseInt(this.max)&&Zn(t,n[0],n,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var e in this.cache)Zn(this.cache,e,this.keys)},mounted:function(){var e=this;this.cacheVNode(),this.$watch("include",(function(t){Wn(e,(function(e){return Gn(t,e)}))})),this.$watch("exclude",(function(t){Wn(e,(function(e){return!Gn(t,e)}))}))},updated:function(){this.cacheVNode()},render:function(){var e=this.$slots.default,t=wt(e),n=t&&t.componentOptions;if(n){var a=zn(n),i=this.include,s=this.exclude;if(i&&(!a||!Gn(i,a))||s&&a&&Gn(s,a))return t;var r=this.cache,o=this.keys,u=null==t.key?n.Ctor.cid+(n.tag?"::".concat(n.tag):""):t.key;r[u]?(t.componentInstance=r[u].componentInstance,T(o,u),o.push(u)):(this.vnodeToCache=t,this.keyToCache=u),t.data.keepAlive=!0}return t||e&&e[0]}}};!function(e){var t={get:function(){return $}};Object.defineProperty(e,"config",t),e.util={warn:Cn,extend:F,mergeOptions:Xn,defineReactive:Fe},e.set=Ae,e.delete=Ce,e.nextTick=sn,e.observable=function(e){return _e(e),e},e.options=Object.create(null),V.forEach((function(t){e.options[t+"s"]=Object.create(null)})),e.options._base=e,F(e.options.components,Jn),function(e){e.use=function(e){var t=this._installedPlugins||(this._installedPlugins=[]);if(t.indexOf(e)>-1)return this;var n=_(arguments,1);return n.unshift(this),o(e.install)?e.install.apply(e,n):o(e)&&e.apply(null,n),t.push(e),this}}(e),function(e){e.mixin=function(e){return this.options=Xn(this.options,e),this}}(e),function(e){e.cid=0;var t=1;e.extend=function(e){e=e||{};var n=this,a=n.cid,i=e._Ctor||(e._Ctor={});if(i[a])return i[a];var s=En(e)||En(n.options),r=function(e){this._init(e)};return(r.prototype=Object.create(n.prototype)).constructor=r,r.cid=t++,r.options=Xn(n.options,e),r.super=n,r.options.props&&function(e){var t=e.options.props;for(var n in t)cn(e.prototype,"_props",n)}(r),r.options.computed&&function(e){var t=e.options.computed;for(var n in t)bn(e.prototype,n,t[n])}(r),r.extend=n.extend,r.mixin=n.mixin,r.use=n.use,V.forEach((function(e){r[e]=n[e]})),s&&(r.options.components[s]=r),r.superOptions=n.options,r.extendOptions=e,r.sealedOptions=F({},r.options),i[a]=r,r}}(e),function(e){V.forEach((function(t){e[t]=function(e,n){return n?("component"===t&&d(n)&&(n.name=n.name||e,n=this.options._base.extend(n)),"directive"===t&&o(n)&&(n={bind:n,update:n}),this.options[t+"s"][e]=n,n):this.options[t+"s"][e]}}))}(e)}(jn),Object.defineProperty(jn.prototype,"$isServer",{get:ie}),Object.defineProperty(jn.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(jn,"FunctionalRenderContext",{value:Mn}),jn.version="2.7.8";var Yn=f("style,class"),Qn=f("input,textarea,option,select,progress"),ea=function(e,t,n){return"value"===n&&Qn(e)&&"button"!==t||"selected"===n&&"option"===e||"checked"===n&&"input"===e||"muted"===n&&"video"===e},ta=f("contenteditable,draggable,spellcheck"),na=f("events,caret,typing,plaintext-only"),aa=f("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ia="http://www.w3.org/1999/xlink",sa=function(e){return":"===e.charAt(5)&&"xlink"===e.slice(0,5)},ra=function(e){return sa(e)?e.slice(6,e.length):""},oa=function(e){return null==e||!1===e};function ua(e,t){return{staticClass:pa(e.staticClass,t.staticClass),class:i(e.class)?[e.class,t.class]:t.class}}function pa(e,t){return e?t?e+" "+t:e:t||""}function da(e){return Array.isArray(e)?function(e){for(var t,n="",a=0,s=e.length;a<s;a++)i(t=da(e[a]))&&""!==t&&(n&&(n+=" "),n+=t);return n}(e):u(e)?function(e){var t="";for(var n in e)e[n]&&(t&&(t+=" "),t+=n);return t}(e):"string"==typeof e?e:""}var la={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ya=f("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),ca=f("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),ma=function(e){return ya(e)||ca(e)};function fa(e){return ca(e)?"svg":"math"===e?"math":void 0}var ba=Object.create(null),ha=f("text,number,password,search,email,tel,url");function Ta(e){return"string"==typeof e?document.querySelector(e)||document.createElement("div"):e}var va=Object.freeze({__proto__:null,createElement:function(e,t){var n=document.createElement(e);return"select"!==e||t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n},createElementNS:function(e,t){return document.createElementNS(la[e],t)},createTextNode:function(e){return document.createTextNode(e)},createComment:function(e){return document.createComment(e)},insertBefore:function(e,t,n){e.insertBefore(t,n)},removeChild:function(e,t){e.removeChild(t)},appendChild:function(e,t){e.appendChild(t)},parentNode:function(e){return e.parentNode},nextSibling:function(e){return e.nextSibling},tagName:function(e){return e.tagName},setTextContent:function(e,t){e.textContent=t},setStyleScope:function(e,t){e.setAttribute(t,"")}}),wa={create:function(e,t){ga(t)},update:function(e,t){e.data.ref!==t.data.ref&&(ga(e,!0),ga(t))},destroy:function(e){ga(e,!0)}};function ga(e,n){var a=e.data.ref;if(i(a)){var s=e.context,r=e.componentInstance||e.elm,u=n?null:r,p=n?void 0:r;if(o(a))zt(a,s,[u],s,"template ref function");else{var d=e.data.refInFor,l="string"==typeof a||"number"==typeof a,y=Pe(a),c=s.$refs;if(l||y)if(d){var m=l?c[a]:a.value;n?t(m)&&T(m,r):t(m)?m.includes(r)||m.push(r):l?(c[a]=[r],ka(s,a,c[a])):a.value=[r]}else if(l){if(n&&c[a]!==r)return;c[a]=p,ka(s,a,u)}else if(y){if(n&&a.value!==r)return;a.value=u}}}}function ka(e,t,n){var a=e._setupState;a&&w(a,t)&&(Pe(a[t])?a[t].value=n:a[t]=n)}var Ma=new le("",{},[]),Ia=["create","activate","update","remove","destroy"];function Ra(e,t){return e.key===t.key&&e.asyncFactory===t.asyncFactory&&(e.tag===t.tag&&e.isComment===t.isComment&&i(e.data)===i(t.data)&&function(e,t){if("input"!==e.tag)return!0;var n,a=i(n=e.data)&&i(n=n.attrs)&&n.type,s=i(n=t.data)&&i(n=n.attrs)&&n.type;return a===s||ha(a)&&ha(s)}(e,t)||s(e.isAsyncPlaceholder)&&a(t.asyncFactory.error))}function Ea(e,t,n){var a,s,r={};for(a=t;a<=n;++a)i(s=e[a].key)&&(r[s]=a);return r}var xa={create:_a,update:_a,destroy:function(e){_a(e,Ma)}};function _a(e,t){(e.data.directives||t.data.directives)&&function(e,t){var n,a,i,s=e===Ma,r=t===Ma,o=Aa(e.data.directives,e.context),u=Aa(t.data.directives,t.context),p=[],d=[];for(n in u)a=o[n],i=u[n],a?(i.oldValue=a.value,i.oldArg=a.arg,Sa(i,"update",t,e),i.def&&i.def.componentUpdated&&d.push(i)):(Sa(i,"bind",t,e),i.def&&i.def.inserted&&p.push(i));if(p.length){var l=function(){for(var n=0;n<p.length;n++)Sa(p[n],"inserted",t,e)};s?Le(t,"insert",l):l()}if(d.length&&Le(t,"postpatch",(function(){for(var n=0;n<d.length;n++)Sa(d[n],"componentUpdated",t,e)})),!s)for(n in o)u[n]||Sa(o[n],"unbind",e,e,r)}(e,t)}var Fa=Object.create(null);function Aa(e,t){var n,a,i=Object.create(null);if(!e)return i;for(n=0;n<e.length;n++)(a=e[n]).modifiers||(a.modifiers=Fa),i[Ca(a)]=a,t._setupState&&t._setupState.__sfc&&(a.def=a.def||Vn(t,"_setupState","v-"+a.name)),a.def=a.def||Vn(t.$options,"directives",a.name);return i}function Ca(e){return e.rawName||"".concat(e.name,".").concat(Object.keys(e.modifiers||{}).join("."))}function Sa(e,t,n,a,i){var s=e.def&&e.def[t];if(s)try{s(n.elm,e,n,a,i)}catch(a){jt(a,n.context,"directive ".concat(e.name," ").concat(t," hook"))}}var Oa=[wa,xa];function Na(e,t){var n=t.componentOptions;if(!(i(n)&&!1===n.Ctor.options.inheritAttrs||a(e.data.attrs)&&a(t.data.attrs))){var r,o,u=t.elm,p=e.data.attrs||{},d=t.data.attrs||{};for(r in(i(d.__ob__)||s(d._v_attr_proxy))&&(d=t.data.attrs=F({},d)),d)o=d[r],p[r]!==o&&Pa(u,r,o,t.data.pre);for(r in(Z||J)&&d.value!==p.value&&Pa(u,"value",d.value),p)a(d[r])&&(sa(r)?u.removeAttributeNS(ia,ra(r)):ta(r)||u.removeAttribute(r))}}function Pa(e,t,n,a){a||e.tagName.indexOf("-")>-1?Ua(e,t,n):aa(t)?oa(n)?e.removeAttribute(t):(n="allowfullscreen"===t&&"EMBED"===e.tagName?"true":t,e.setAttribute(t,n)):ta(t)?e.setAttribute(t,function(e,t){return oa(t)||"false"===t?"false":"contenteditable"===e&&na(t)?t:"true"}(t,n)):sa(t)?oa(n)?e.removeAttributeNS(ia,ra(t)):e.setAttributeNS(ia,t,n):Ua(e,t,n)}function Ua(e,t,n){if(oa(n))e.removeAttribute(t);else{if(Z&&!K&&"TEXTAREA"===e.tagName&&"placeholder"===t&&""!==n&&!e.__ieph){var a=function(t){t.stopImmediatePropagation(),e.removeEventListener("input",a)};e.addEventListener("input",a),e.__ieph=!0}e.setAttribute(t,n)}}var Da={create:Na,update:Na};function Xa(e,t){var n=t.elm,s=t.data,r=e.data;if(!(a(s.staticClass)&&a(s.class)&&(a(r)||a(r.staticClass)&&a(r.class)))){var o=function(e){for(var t=e.data,n=e,a=e;i(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(t=ua(a.data,t));for(;i(n=n.parent);)n&&n.data&&(t=ua(t,n.data));return s=t.staticClass,r=t.class,i(s)||i(r)?pa(s,da(r)):"";var s,r}(t),u=n._transitionClasses;i(u)&&(o=pa(o,da(u))),o!==n._prevClass&&(n.setAttribute("class",o),n._prevClass=o)}}var Va,La,$a,Ba,Ha,qa,ja={create:Xa,update:Xa},za=/[\w).+\-_$\]]/;function Ga(e){var t,n,a,i,s,r=!1,o=!1,u=!1,p=!1,d=0,l=0,y=0,c=0;for(a=0;a<e.length;a++)if(n=t,t=e.charCodeAt(a),r)39===t&&92!==n&&(r=!1);else if(o)34===t&&92!==n&&(o=!1);else if(u)96===t&&92!==n&&(u=!1);else if(p)47===t&&92!==n&&(p=!1);else if(124!==t||124===e.charCodeAt(a+1)||124===e.charCodeAt(a-1)||d||l||y){switch(t){case 34:o=!0;break;case 39:r=!0;break;case 96:u=!0;break;case 40:y++;break;case 41:y--;break;case 91:l++;break;case 93:l--;break;case 123:d++;break;case 125:d--}if(47===t){for(var m=a-1,f=void 0;m>=0&&" "===(f=e.charAt(m));m--);f&&za.test(f)||(p=!0)}}else void 0===i?(c=a+1,i=e.slice(0,a).trim()):b();function b(){(s||(s=[])).push(e.slice(c,a).trim()),c=a+1}if(void 0===i?i=e.slice(0,a).trim():0!==c&&b(),s)for(a=0;a<s.length;a++)i=Wa(i,s[a]);return i}function Wa(e,t){var n=t.indexOf("(");if(n<0)return'_f("'.concat(t,'")(').concat(e,")");var a=t.slice(0,n),i=t.slice(n+1);return'_f("'.concat(a,'")(').concat(e).concat(")"!==i?","+i:i)}function Za(e,t){console.error("[Vue compiler]: ".concat(e))}function Ka(e,t){return e?e.map((function(e){return e[t]})).filter((function(e){return e})):[]}function Ja(e,t,n,a,i){(e.props||(e.props=[])).push(ri({name:t,value:n,dynamic:i},a)),e.plain=!1}function Ya(e,t,n,a,i){(i?e.dynamicAttrs||(e.dynamicAttrs=[]):e.attrs||(e.attrs=[])).push(ri({name:t,value:n,dynamic:i},a)),e.plain=!1}function Qa(e,t,n,a){e.attrsMap[t]=n,e.attrsList.push(ri({name:t,value:n},a))}function ei(e,t,n,a,i,s,r,o){(e.directives||(e.directives=[])).push(ri({name:t,rawName:n,value:a,arg:i,isDynamicArg:s,modifiers:r},o)),e.plain=!1}function ti(e,t,n){return n?"_p(".concat(t,',"').concat(e,'")'):e+t}function ni(t,n,a,i,s,r,o,u){var p;(i=i||e).right?u?n="(".concat(n,")==='click'?'contextmenu':(").concat(n,")"):"click"===n&&(n="contextmenu",delete i.right):i.middle&&(u?n="(".concat(n,")==='click'?'mouseup':(").concat(n,")"):"click"===n&&(n="mouseup")),i.capture&&(delete i.capture,n=ti("!",n,u)),i.once&&(delete i.once,n=ti("~",n,u)),i.passive&&(delete i.passive,n=ti("&",n,u)),i.native?(delete i.native,p=t.nativeEvents||(t.nativeEvents={})):p=t.events||(t.events={});var d=ri({value:a.trim(),dynamic:u},o);i!==e&&(d.modifiers=i);var l=p[n];Array.isArray(l)?s?l.unshift(d):l.push(d):p[n]=l?s?[d,l]:[l,d]:d,t.plain=!1}function ai(e,t,n){var a=ii(e,":"+t)||ii(e,"v-bind:"+t);if(null!=a)return Ga(a);if(!1!==n){var i=ii(e,t);if(null!=i)return JSON.stringify(i)}}function ii(e,t,n){var a;if(null!=(a=e.attrsMap[t]))for(var i=e.attrsList,s=0,r=i.length;s<r;s++)if(i[s].name===t){i.splice(s,1);break}return n&&delete e.attrsMap[t],a}function si(e,t){for(var n=e.attrsList,a=0,i=n.length;a<i;a++){var s=n[a];if(t.test(s.name))return n.splice(a,1),s}}function ri(e,t){return t&&(null!=t.start&&(e.start=t.start),null!=t.end&&(e.end=t.end)),e}function oi(e,t,n){var a=n||{},i=a.number,s="$$v",r=s;a.trim&&(r="(typeof ".concat(s," === 'string'")+"? ".concat(s,".trim()")+": ".concat(s,")")),i&&(r="_n(".concat(r,")"));var o=ui(t,r);e.model={value:"(".concat(t,")"),expression:JSON.stringify(t),callback:"function (".concat(s,") {").concat(o,"}")}}function ui(e,t){var n=function(e){if(e=e.trim(),Va=e.length,e.indexOf("[")<0||e.lastIndexOf("]")<Va-1)return(Ba=e.lastIndexOf("."))>-1?{exp:e.slice(0,Ba),key:'"'+e.slice(Ba+1)+'"'}:{exp:e,key:null};for(La=e,Ba=Ha=qa=0;!di();)li($a=pi())?ci($a):91===$a&&yi($a);return{exp:e.slice(0,Ha),key:e.slice(Ha+1,qa)}}(e);return null===n.key?"".concat(e,"=").concat(t):"$set(".concat(n.exp,", ").concat(n.key,", ").concat(t,")")}function pi(){return La.charCodeAt(++Ba)}function di(){return Ba>=Va}function li(e){return 34===e||39===e}function yi(e){var t=1;for(Ha=Ba;!di();)if(li(e=pi()))ci(e);else if(91===e&&t++,93===e&&t--,0===t){qa=Ba;break}}function ci(e){for(var t=e;!di()&&(e=pi())!==t;);}var mi;function fi(e,t,n){var a=mi;return function i(){var s=t.apply(null,arguments);null!==s&&Ti(e,i,n,a)}}var bi=Kt&&!(ee&&Number(ee[1])<=53);function hi(e,t,n,a){if(bi){var i=Dt,s=t;t=s._wrapper=function(e){if(e.target===e.currentTarget||e.timeStamp>=i||e.timeStamp<=0||e.target.ownerDocument!==document)return s.apply(this,arguments)}}mi.addEventListener(e,t,ne?{capture:n,passive:a}:n)}function Ti(e,t,n,a){(a||mi).removeEventListener(e,t._wrapper||t,n)}function vi(e,t){if(!a(e.data.on)||!a(t.data.on)){var n=t.data.on||{},s=e.data.on||{};mi=t.elm||e.elm,function(e){if(i(e.__r)){var t=Z?"change":"input";e[t]=[].concat(e.__r,e[t]||[]),delete e.__r}i(e.__c)&&(e.change=[].concat(e.__c,e.change||[]),delete e.__c)}(n),Ve(n,s,hi,Ti,fi,t.context),mi=void 0}}var wi,gi={create:vi,update:vi,destroy:function(e){return vi(e,Ma)}};function ki(e,t){if(!a(e.data.domProps)||!a(t.data.domProps)){var n,r,o=t.elm,u=e.data.domProps||{},p=t.data.domProps||{};for(n in(i(p.__ob__)||s(p._v_attr_proxy))&&(p=t.data.domProps=F({},p)),u)n in p||(o[n]="");for(n in p){if(r=p[n],"textContent"===n||"innerHTML"===n){if(t.children&&(t.children.length=0),r===u[n])continue;1===o.childNodes.length&&o.removeChild(o.childNodes[0])}if("value"===n&&"PROGRESS"!==o.tagName){o._value=r;var d=a(r)?"":String(r);Mi(o,d)&&(o.value=d)}else if("innerHTML"===n&&ca(o.tagName)&&a(o.innerHTML)){(wi=wi||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var l=wi.firstChild;o.firstChild;)o.removeChild(o.firstChild);for(;l.firstChild;)o.appendChild(l.firstChild)}else if(r!==u[n])try{o[n]=r}catch(e){}}}}function Mi(e,t){return!e.composing&&("OPTION"===e.tagName||function(e,t){var n=!0;try{n=document.activeElement!==e}catch(e){}return n&&e.value!==t}(e,t)||function(e,t){var n=e.value,a=e._vModifiers;if(i(a)){if(a.number)return m(n)!==m(t);if(a.trim)return n.trim()!==t.trim()}return n!==t}(e,t))}var Ii={create:ki,update:ki},Ri=g((function(e){var t={},n=/:(.+)/;return e.split(/;(?![^(]*\))/g).forEach((function(e){if(e){var a=e.split(n);a.length>1&&(t[a[0].trim()]=a[1].trim())}})),t}));function Ei(e){var t=xi(e.style);return e.staticStyle?F(e.staticStyle,t):t}function xi(e){return Array.isArray(e)?A(e):"string"==typeof e?Ri(e):e}var _i,Fi=/^--/,Ai=/\s*!important$/,Ci=function(e,t,n){if(Fi.test(t))e.style.setProperty(t,n);else if(Ai.test(n))e.style.setProperty(E(t),n.replace(Ai,""),"important");else{var a=Oi(t);if(Array.isArray(n))for(var i=0,s=n.length;i<s;i++)e.style[a]=n[i];else e.style[a]=n}},Si=["Webkit","Moz","ms"],Oi=g((function(e){if(_i=_i||document.createElement("div").style,"filter"!==(e=M(e))&&e in _i)return e;for(var t=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<Si.length;n++){var a=Si[n]+t;if(a in _i)return a}}));function Ni(e,t){var n=t.data,s=e.data;if(!(a(n.staticStyle)&&a(n.style)&&a(s.staticStyle)&&a(s.style))){var r,o,u=t.elm,p=s.staticStyle,d=s.normalizedStyle||s.style||{},l=p||d,y=xi(t.data.style)||{};t.data.normalizedStyle=i(y.__ob__)?F({},y):y;var c=function(e,t){for(var n,a={},i=e;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(n=Ei(i.data))&&F(a,n);(n=Ei(e.data))&&F(a,n);for(var s=e;s=s.parent;)s.data&&(n=Ei(s.data))&&F(a,n);return a}(t);for(o in l)a(c[o])&&Ci(u,o,"");for(o in c)(r=c[o])!==l[o]&&Ci(u,o,null==r?"":r)}}var Pi={create:Ni,update:Ni},Ui=/\s+/;function Di(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(Ui).forEach((function(t){return e.classList.add(t)})):e.classList.add(t);else{var n=" ".concat(e.getAttribute("class")||""," ");n.indexOf(" "+t+" ")<0&&e.setAttribute("class",(n+t).trim())}}function Xi(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(Ui).forEach((function(t){return e.classList.remove(t)})):e.classList.remove(t),e.classList.length||e.removeAttribute("class");else{for(var n=" ".concat(e.getAttribute("class")||""," "),a=" "+t+" ";n.indexOf(a)>=0;)n=n.replace(a," ");(n=n.trim())?e.setAttribute("class",n):e.removeAttribute("class")}}function Vi(e){if(e){if("object"==typeof e){var t={};return!1!==e.css&&F(t,Li(e.name||"v")),F(t,e),t}return"string"==typeof e?Li(e):void 0}}var Li=g((function(e){return{enterClass:"".concat(e,"-enter"),enterToClass:"".concat(e,"-enter-to"),enterActiveClass:"".concat(e,"-enter-active"),leaveClass:"".concat(e,"-leave"),leaveToClass:"".concat(e,"-leave-to"),leaveActiveClass:"".concat(e,"-leave-active")}})),$i=G&&!K,Bi="transition",Hi="animation",qi="transition",ji="transitionend",zi="animation",Gi="animationend";$i&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(qi="WebkitTransition",ji="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(zi="WebkitAnimation",Gi="webkitAnimationEnd"));var Wi=G?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(e){return e()};function Zi(e){Wi((function(){Wi(e)}))}function Ki(e,t){var n=e._transitionClasses||(e._transitionClasses=[]);n.indexOf(t)<0&&(n.push(t),Di(e,t))}function Ji(e,t){e._transitionClasses&&T(e._transitionClasses,t),Xi(e,t)}function Yi(e,t,n){var a=es(e,t),i=a.type,s=a.timeout,r=a.propCount;if(!i)return n();var o=i===Bi?ji:Gi,u=0,p=function(){e.removeEventListener(o,d),n()},d=function(t){t.target===e&&++u>=r&&p()};setTimeout((function(){u<r&&p()}),s+1),e.addEventListener(o,d)}var Qi=/\b(transform|all)(,|$)/;function es(e,t){var n,a=window.getComputedStyle(e),i=(a[qi+"Delay"]||"").split(", "),s=(a[qi+"Duration"]||"").split(", "),r=ts(i,s),o=(a[zi+"Delay"]||"").split(", "),u=(a[zi+"Duration"]||"").split(", "),p=ts(o,u),d=0,l=0;return t===Bi?r>0&&(n=Bi,d=r,l=s.length):t===Hi?p>0&&(n=Hi,d=p,l=u.length):l=(n=(d=Math.max(r,p))>0?r>p?Bi:Hi:null)?n===Bi?s.length:u.length:0,{type:n,timeout:d,propCount:l,hasTransform:n===Bi&&Qi.test(a[qi+"Property"])}}function ts(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max.apply(null,t.map((function(t,n){return ns(t)+ns(e[n])})))}function ns(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function as(e,t){var n=e.elm;i(n._leaveCb)&&(n._leaveCb.cancelled=!0,n._leaveCb());var s=Vi(e.data.transition);if(!a(s)&&!i(n._enterCb)&&1===n.nodeType){for(var r=s.css,p=s.type,d=s.enterClass,l=s.enterToClass,y=s.enterActiveClass,c=s.appearClass,f=s.appearToClass,b=s.appearActiveClass,h=s.beforeEnter,T=s.enter,v=s.afterEnter,w=s.enterCancelled,g=s.beforeAppear,k=s.appear,M=s.afterAppear,I=s.appearCancelled,R=s.duration,E=Rt,x=Rt.$vnode;x&&x.parent;)E=x.context,x=x.parent;var _=!E._isMounted||!e.isRootInsert;if(!_||k||""===k){var F=_&&c?c:d,A=_&&b?b:y,C=_&&f?f:l,S=_&&g||h,O=_&&o(k)?k:T,N=_&&M||v,P=_&&I||w,D=m(u(R)?R.enter:R),X=!1!==r&&!K,V=rs(O),L=n._enterCb=U((function(){X&&(Ji(n,C),Ji(n,A)),L.cancelled?(X&&Ji(n,F),P&&P(n)):N&&N(n),n._enterCb=null}));e.data.show||Le(e,"insert",(function(){var t=n.parentNode,a=t&&t._pending&&t._pending[e.key];a&&a.tag===e.tag&&a.elm._leaveCb&&a.elm._leaveCb(),O&&O(n,L)})),S&&S(n),X&&(Ki(n,F),Ki(n,A),Zi((function(){Ji(n,F),L.cancelled||(Ki(n,C),V||(ss(D)?setTimeout(L,D):Yi(n,p,L)))}))),e.data.show&&(t&&t(),O&&O(n,L)),X||V||L()}}}function is(e,t){var n=e.elm;i(n._enterCb)&&(n._enterCb.cancelled=!0,n._enterCb());var s=Vi(e.data.transition);if(a(s)||1!==n.nodeType)return t();if(!i(n._leaveCb)){var r=s.css,o=s.type,p=s.leaveClass,d=s.leaveToClass,l=s.leaveActiveClass,y=s.beforeLeave,c=s.leave,f=s.afterLeave,b=s.leaveCancelled,h=s.delayLeave,T=s.duration,v=!1!==r&&!K,w=rs(c),g=m(u(T)?T.leave:T),k=n._leaveCb=U((function(){n.parentNode&&n.parentNode._pending&&(n.parentNode._pending[e.key]=null),v&&(Ji(n,d),Ji(n,l)),k.cancelled?(v&&Ji(n,p),b&&b(n)):(t(),f&&f(n)),n._leaveCb=null}));h?h(M):M()}function M(){k.cancelled||(!e.data.show&&n.parentNode&&((n.parentNode._pending||(n.parentNode._pending={}))[e.key]=e),y&&y(n),v&&(Ki(n,p),Ki(n,l),Zi((function(){Ji(n,p),k.cancelled||(Ki(n,d),w||(ss(g)?setTimeout(k,g):Yi(n,o,k)))}))),c&&c(n,k),v||w||k())}}function ss(e){return"number"==typeof e&&!isNaN(e)}function rs(e){if(a(e))return!1;var t=e.fns;return i(t)?rs(Array.isArray(t)?t[0]:t):(e._length||e.length)>1}function os(e,t){!0!==t.data.show&&as(t)}var us=function(e){var n,o,u={},p=e.modules,d=e.nodeOps;for(n=0;n<Ia.length;++n)for(u[Ia[n]]=[],o=0;o<p.length;++o)i(p[o][Ia[n]])&&u[Ia[n]].push(p[o][Ia[n]]);function l(e){var t=d.parentNode(e);i(t)&&d.removeChild(t,e)}function y(e,t,n,a,r,o,p){if(i(e.elm)&&i(o)&&(e=o[p]=me(e)),e.isRootInsert=!r,!function(e,t,n,a){var r=e.data;if(i(r)){var o=i(e.componentInstance)&&r.keepAlive;if(i(r=r.hook)&&i(r=r.init)&&r(e,!1),i(e.componentInstance))return c(e,t),m(n,e.elm,a),s(o)&&function(e,t,n,a){for(var s,r=e;r.componentInstance;)if(i(s=(r=r.componentInstance._vnode).data)&&i(s=s.transition)){for(s=0;s<u.activate.length;++s)u.activate[s](Ma,r);t.push(r);break}m(n,e.elm,a)}(e,t,n,a),!0}}(e,t,n,a)){var l=e.data,y=e.children,f=e.tag;i(f)?(e.elm=e.ns?d.createElementNS(e.ns,f):d.createElement(f,e),v(e),b(e,y,t),i(l)&&T(e,t),m(n,e.elm,a)):s(e.isComment)?(e.elm=d.createComment(e.text),m(n,e.elm,a)):(e.elm=d.createTextNode(e.text),m(n,e.elm,a))}}function c(e,t){i(e.data.pendingInsert)&&(t.push.apply(t,e.data.pendingInsert),e.data.pendingInsert=null),e.elm=e.componentInstance.$el,h(e)?(T(e,t),v(e)):(ga(e),t.push(e))}function m(e,t,n){i(e)&&(i(n)?d.parentNode(n)===e&&d.insertBefore(e,t,n):d.appendChild(e,t))}function b(e,n,a){if(t(n))for(var i=0;i<n.length;++i)y(n[i],a,e.elm,null,!0,n,i);else r(e.text)&&d.appendChild(e.elm,d.createTextNode(String(e.text)))}function h(e){for(;e.componentInstance;)e=e.componentInstance._vnode;return i(e.tag)}function T(e,t){for(var a=0;a<u.create.length;++a)u.create[a](Ma,e);i(n=e.data.hook)&&(i(n.create)&&n.create(Ma,e),i(n.insert)&&t.push(e))}function v(e){var t;if(i(t=e.fnScopeId))d.setStyleScope(e.elm,t);else for(var n=e;n;)i(t=n.context)&&i(t=t.$options._scopeId)&&d.setStyleScope(e.elm,t),n=n.parent;i(t=Rt)&&t!==e.context&&t!==e.fnContext&&i(t=t.$options._scopeId)&&d.setStyleScope(e.elm,t)}function w(e,t,n,a,i,s){for(;a<=i;++a)y(n[a],s,e,t,!1,n,a)}function g(e){var t,n,a=e.data;if(i(a))for(i(t=a.hook)&&i(t=t.destroy)&&t(e),t=0;t<u.destroy.length;++t)u.destroy[t](e);if(i(t=e.children))for(n=0;n<e.children.length;++n)g(e.children[n])}function k(e,t,n){for(;t<=n;++t){var a=e[t];i(a)&&(i(a.tag)?(M(a),g(a)):l(a.elm))}}function M(e,t){if(i(t)||i(e.data)){var n,a=u.remove.length+1;for(i(t)?t.listeners+=a:t=function(e,t){function n(){0==--n.listeners&&l(e)}return n.listeners=t,n}(e.elm,a),i(n=e.componentInstance)&&i(n=n._vnode)&&i(n.data)&&M(n,t),n=0;n<u.remove.length;++n)u.remove[n](e,t);i(n=e.data.hook)&&i(n=n.remove)?n(e,t):t()}else l(e.elm)}function I(e,t,n,a){for(var s=n;s<a;s++){var r=t[s];if(i(r)&&Ra(e,r))return s}}function R(e,t,n,r,o,p){if(e!==t){i(t.elm)&&i(r)&&(t=r[o]=me(t));var l=t.elm=e.elm;if(s(e.isAsyncPlaceholder))i(t.asyncFactory.resolved)?_(e.elm,t,n):t.isAsyncPlaceholder=!0;else if(s(t.isStatic)&&s(e.isStatic)&&t.key===e.key&&(s(t.isCloned)||s(t.isOnce)))t.componentInstance=e.componentInstance;else{var c,m=t.data;i(m)&&i(c=m.hook)&&i(c=c.prepatch)&&c(e,t);var f=e.children,b=t.children;if(i(m)&&h(t)){for(c=0;c<u.update.length;++c)u.update[c](e,t);i(c=m.hook)&&i(c=c.update)&&c(e,t)}a(t.text)?i(f)&&i(b)?f!==b&&function(e,t,n,s,r){for(var o,u,p,l=0,c=0,m=t.length-1,f=t[0],b=t[m],h=n.length-1,T=n[0],v=n[h],g=!r;l<=m&&c<=h;)a(f)?f=t[++l]:a(b)?b=t[--m]:Ra(f,T)?(R(f,T,s,n,c),f=t[++l],T=n[++c]):Ra(b,v)?(R(b,v,s,n,h),b=t[--m],v=n[--h]):Ra(f,v)?(R(f,v,s,n,h),g&&d.insertBefore(e,f.elm,d.nextSibling(b.elm)),f=t[++l],v=n[--h]):Ra(b,T)?(R(b,T,s,n,c),g&&d.insertBefore(e,b.elm,f.elm),b=t[--m],T=n[++c]):(a(o)&&(o=Ea(t,l,m)),a(u=i(T.key)?o[T.key]:I(T,t,l,m))?y(T,s,e,f.elm,!1,n,c):Ra(p=t[u],T)?(R(p,T,s,n,c),t[u]=void 0,g&&d.insertBefore(e,p.elm,f.elm)):y(T,s,e,f.elm,!1,n,c),T=n[++c]);l>m?w(e,a(n[h+1])?null:n[h+1].elm,n,c,h,s):c>h&&k(t,l,m)}(l,f,b,n,p):i(b)?(i(e.text)&&d.setTextContent(l,""),w(l,null,b,0,b.length-1,n)):i(f)?k(f,0,f.length-1):i(e.text)&&d.setTextContent(l,""):e.text!==t.text&&d.setTextContent(l,t.text),i(m)&&i(c=m.hook)&&i(c=c.postpatch)&&c(e,t)}}}function E(e,t,n){if(s(n)&&i(e.parent))e.parent.data.pendingInsert=t;else for(var a=0;a<t.length;++a)t[a].data.hook.insert(t[a])}var x=f("attrs,class,staticClass,staticStyle,key");function _(e,t,n,a){var r,o=t.tag,u=t.data,p=t.children;if(a=a||u&&u.pre,t.elm=e,s(t.isComment)&&i(t.asyncFactory))return t.isAsyncPlaceholder=!0,!0;if(i(u)&&(i(r=u.hook)&&i(r=r.init)&&r(t,!0),i(r=t.componentInstance)))return c(t,n),!0;if(i(o)){if(i(p))if(e.hasChildNodes())if(i(r=u)&&i(r=r.domProps)&&i(r=r.innerHTML)){if(r!==e.innerHTML)return!1}else{for(var d=!0,l=e.firstChild,y=0;y<p.length;y++){if(!l||!_(l,p[y],n,a)){d=!1;break}l=l.nextSibling}if(!d||l)return!1}else b(t,p,n);if(i(u)){var m=!1;for(var f in u)if(!x(f)){m=!0,T(t,n);break}!m&&u.class&&un(u.class)}}else e.data!==t.text&&(e.data=t.text);return!0}return function(e,t,n,r){if(!a(t)){var o,p=!1,l=[];if(a(e))p=!0,y(t,l);else{var c=i(e.nodeType);if(!c&&Ra(e,t))R(e,t,l,null,null,r);else{if(c){if(1===e.nodeType&&e.hasAttribute(X)&&(e.removeAttribute(X),n=!0),s(n)&&_(e,t,l))return E(t,l,!0),e;o=e,e=new le(d.tagName(o).toLowerCase(),{},[],void 0,o)}var m=e.elm,f=d.parentNode(m);if(y(t,l,m._leaveCb?null:f,d.nextSibling(m)),i(t.parent))for(var b=t.parent,T=h(t);b;){for(var v=0;v<u.destroy.length;++v)u.destroy[v](b);if(b.elm=t.elm,T){for(var w=0;w<u.create.length;++w)u.create[w](Ma,b);var M=b.data.hook.insert;if(M.merged)for(var I=1;I<M.fns.length;I++)M.fns[I]()}else ga(b);b=b.parent}i(f)?k([e],0,0):i(e.tag)&&g(e)}}return E(t,l,p),t.elm}i(e)&&g(e)}}({nodeOps:va,modules:[Da,ja,gi,Ii,Pi,G?{create:os,activate:os,remove:function(e,t){!0!==e.data.show?is(e,t):t()}}:{}].concat(Oa)});K&&document.addEventListener("selectionchange",(function(){var e=document.activeElement;e&&e.vmodel&&bs(e,"input")}));var ps={inserted:function(e,t,n,a){"select"===n.tag?(a.elm&&!a.elm._vOptions?Le(n,"postpatch",(function(){ps.componentUpdated(e,t,n)})):ds(e,t,n.context),e._vOptions=[].map.call(e.options,cs)):("textarea"===n.tag||ha(e.type))&&(e._vModifiers=t.modifiers,t.modifiers.lazy||(e.addEventListener("compositionstart",ms),e.addEventListener("compositionend",fs),e.addEventListener("change",fs),K&&(e.vmodel=!0)))},componentUpdated:function(e,t,n){if("select"===n.tag){ds(e,t,n.context);var a=e._vOptions,i=e._vOptions=[].map.call(e.options,cs);i.some((function(e,t){return!N(e,a[t])}))&&(e.multiple?t.value.some((function(e){return ys(e,i)})):t.value!==t.oldValue&&ys(t.value,i))&&bs(e,"change")}}};function ds(e,t,n){ls(e,t),(Z||J)&&setTimeout((function(){ls(e,t)}),0)}function ls(e,t,n){var a=t.value,i=e.multiple;if(!i||Array.isArray(a)){for(var s,r,o=0,u=e.options.length;o<u;o++)if(r=e.options[o],i)s=P(a,cs(r))>-1,r.selected!==s&&(r.selected=s);else if(N(cs(r),a))return void(e.selectedIndex!==o&&(e.selectedIndex=o));i||(e.selectedIndex=-1)}}function ys(e,t){return t.every((function(t){return!N(t,e)}))}function cs(e){return"_value"in e?e._value:e.value}function ms(e){e.target.composing=!0}function fs(e){e.target.composing&&(e.target.composing=!1,bs(e.target,"input"))}function bs(e,t){var n=document.createEvent("HTMLEvents");n.initEvent(t,!0,!0),e.dispatchEvent(n)}function hs(e){return!e.componentInstance||e.data&&e.data.transition?e:hs(e.componentInstance._vnode)}var Ts={model:ps,show:{bind:function(e,t,n){var a=t.value,i=(n=hs(n)).data&&n.data.transition,s=e.__vOriginalDisplay="none"===e.style.display?"":e.style.display;a&&i?(n.data.show=!0,as(n,(function(){e.style.display=s}))):e.style.display=a?s:"none"},update:function(e,t,n){var a=t.value;!a!=!t.oldValue&&((n=hs(n)).data&&n.data.transition?(n.data.show=!0,a?as(n,(function(){e.style.display=e.__vOriginalDisplay})):is(n,(function(){e.style.display="none"}))):e.style.display=a?e.__vOriginalDisplay:"none")},unbind:function(e,t,n,a,i){i||(e.style.display=e.__vOriginalDisplay)}}},vs={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function ws(e){var t=e&&e.componentOptions;return t&&t.Ctor.options.abstract?ws(wt(t.children)):e}function gs(e){var t={},n=e.$options;for(var a in n.propsData)t[a]=e[a];var i=n._parentListeners;for(var a in i)t[M(a)]=i[a];return t}function ks(e,t){if(/\d-keep-alive$/.test(t.tag))return e("keep-alive",{props:t.componentOptions.propsData})}var Ms=function(e){return e.tag||dt(e)},Is=function(e){return"show"===e.name},Rs={name:"transition",props:vs,abstract:!0,render:function(e){var t=this,n=this.$slots.default;if(n&&(n=n.filter(Ms)).length){var a=this.mode,i=n[0];if(function(e){for(;e=e.parent;)if(e.data.transition)return!0}(this.$vnode))return i;var s=ws(i);if(!s)return i;if(this._leaving)return ks(e,i);var o="__transition-".concat(this._uid,"-");s.key=null==s.key?s.isComment?o+"comment":o+s.tag:r(s.key)?0===String(s.key).indexOf(o)?s.key:o+s.key:s.key;var u=(s.data||(s.data={})).transition=gs(this),p=this._vnode,d=ws(p);if(s.data.directives&&s.data.directives.some(Is)&&(s.data.show=!0),d&&d.data&&!function(e,t){return t.key===e.key&&t.tag===e.tag}(s,d)&&!dt(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var l=d.data.transition=F({},u);if("out-in"===a)return this._leaving=!0,Le(l,"afterLeave",(function(){t._leaving=!1,t.$forceUpdate()})),ks(e,i);if("in-out"===a){if(dt(s))return p;var y,c=function(){y()};Le(u,"afterEnter",c),Le(u,"enterCancelled",c),Le(l,"delayLeave",(function(e){y=e}))}}return i}}},Es=F({tag:String,moveClass:String},vs);delete Es.mode;var xs={props:Es,beforeMount:function(){var e=this,t=this._update;this._update=function(n,a){var i=Et(e);e.__patch__(e._vnode,e.kept,!1,!0),e._vnode=e.kept,i(),t.call(e,n,a)}},render:function(e){for(var t=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),a=this.prevChildren=this.children,i=this.$slots.default||[],s=this.children=[],r=gs(this),o=0;o<i.length;o++)(d=i[o]).tag&&null!=d.key&&0!==String(d.key).indexOf("__vlist")&&(s.push(d),n[d.key]=d,(d.data||(d.data={})).transition=r);if(a){var u=[],p=[];for(o=0;o<a.length;o++){var d;(d=a[o]).data.transition=r,d.data.pos=d.elm.getBoundingClientRect(),n[d.key]?u.push(d):p.push(d)}this.kept=e(t,null,u),this.removed=p}return e(t,null,s)},updated:function(){var e=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";e.length&&this.hasMove(e[0].elm,t)&&(e.forEach(_s),e.forEach(Fs),e.forEach(As),this._reflow=document.body.offsetHeight,e.forEach((function(e){if(e.data.moved){var n=e.elm,a=n.style;Ki(n,t),a.transform=a.WebkitTransform=a.transitionDuration="",n.addEventListener(ji,n._moveCb=function e(a){a&&a.target!==n||a&&!/transform$/.test(a.propertyName)||(n.removeEventListener(ji,e),n._moveCb=null,Ji(n,t))})}})))},methods:{hasMove:function(e,t){if(!$i)return!1;if(this._hasMove)return this._hasMove;var n=e.cloneNode();e._transitionClasses&&e._transitionClasses.forEach((function(e){Xi(n,e)})),Di(n,t),n.style.display="none",this.$el.appendChild(n);var a=es(n);return this.$el.removeChild(n),this._hasMove=a.hasTransform}}};function _s(e){e.elm._moveCb&&e.elm._moveCb(),e.elm._enterCb&&e.elm._enterCb()}function Fs(e){e.data.newPos=e.elm.getBoundingClientRect()}function As(e){var t=e.data.pos,n=e.data.newPos,a=t.left-n.left,i=t.top-n.top;if(a||i){e.data.moved=!0;var s=e.elm.style;s.transform=s.WebkitTransform="translate(".concat(a,"px,").concat(i,"px)"),s.transitionDuration="0s"}}var Cs={Transition:Rs,TransitionGroup:xs};jn.config.mustUseProp=ea,jn.config.isReservedTag=ma,jn.config.isReservedAttr=Yn,jn.config.getTagNamespace=fa,jn.config.isUnknownElement=function(e){if(!G)return!0;if(ma(e))return!1;if(e=e.toLowerCase(),null!=ba[e])return ba[e];var t=document.createElement(e);return e.indexOf("-")>-1?ba[e]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:ba[e]=/HTMLUnknownElement/.test(t.toString())},F(jn.options.directives,Ts),F(jn.options.components,Cs),jn.prototype.__patch__=G?us:C,jn.prototype.$mount=function(e,t){return function(e,t,n){var a;e.$el=t,e.$options.render||(e.$options.render=ye),At(e,"beforeMount"),a=function(){e._update(e._render(),n)},new ln(e,a,C,{before:function(){e._isMounted&&!e._isDestroyed&&At(e,"beforeUpdate")}},!0),n=!1;var i=e._preWatchers;if(i)for(var s=0;s<i.length;s++)i[s].run();return null==e.$vnode&&(e._isMounted=!0,At(e,"mounted")),e}(this,e=e&&G?Ta(e):void 0,t)},G&&setTimeout((function(){$.devtools&&se&&se.emit("init",jn)}),0);var Ss,Os=/\{\{((?:.|\r?\n)+?)\}\}/g,Ns=/[-.*+?^${}()|[\]\/\\]/g,Ps=g((function(e){var t=e[0].replace(Ns,"\\$&"),n=e[1].replace(Ns,"\\$&");return new RegExp(t+"((?:.|\\n)+?)"+n,"g")})),Us={staticKeys:["staticClass"],transformNode:function(e,t){t.warn;var n=ii(e,"class");n&&(e.staticClass=JSON.stringify(n.replace(/\s+/g," ").trim()));var a=ai(e,"class",!1);a&&(e.classBinding=a)},genData:function(e){var t="";return e.staticClass&&(t+="staticClass:".concat(e.staticClass,",")),e.classBinding&&(t+="class:".concat(e.classBinding,",")),t}},Ds={staticKeys:["staticStyle"],transformNode:function(e,t){t.warn;var n=ii(e,"style");n&&(e.staticStyle=JSON.stringify(Ri(n)));var a=ai(e,"style",!1);a&&(e.styleBinding=a)},genData:function(e){var t="";return e.staticStyle&&(t+="staticStyle:".concat(e.staticStyle,",")),e.styleBinding&&(t+="style:(".concat(e.styleBinding,"),")),t}},Xs=f("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),Vs=f("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),Ls=f("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),$s=/^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,Bs=/^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,Hs="[a-zA-Z_][\\-\\.0-9_a-zA-Z".concat(B.source,"]*"),qs="((?:".concat(Hs,"\\:)?").concat(Hs,")"),js=new RegExp("^<".concat(qs)),zs=/^\s*(\/?)>/,Gs=new RegExp("^<\\/".concat(qs,"[^>]*>")),Ws=/^<!DOCTYPE [^>]+>/i,Zs=/^<!\--/,Ks=/^<!\[/,Js=f("script,style,textarea",!0),Ys={},Qs={"&lt;":"<","&gt;":">","&quot;":'"',"&amp;":"&","&#10;":"\n","&#9;":"\t","&#39;":"'"},er=/&(?:lt|gt|quot|amp|#39);/g,tr=/&(?:lt|gt|quot|amp|#39|#10|#9);/g,nr=f("pre,textarea",!0),ar=function(e,t){return e&&nr(e)&&"\n"===t[0]};function ir(e,t){var n=t?tr:er;return e.replace(n,(function(e){return Qs[e]}))}var sr,rr,or,ur,pr,dr,lr,yr,cr=/^@|^v-on:/,mr=/^v-|^@|^:|^#/,fr=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,br=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,hr=/^\(|\)$/g,Tr=/^\[.*\]$/,vr=/:(.*)$/,wr=/^:|^\.|^v-bind:/,gr=/\.[^.\]]+(?=[^\]]*$)/g,kr=/^v-slot(:|$)|^#/,Mr=/[\r\n]/,Ir=/[ \f\t\r\n]+/g,Rr=g((function(e){return(Ss=Ss||document.createElement("div")).innerHTML=e,Ss.textContent})),Er="_empty_";function xr(e,t,n){return{type:1,tag:e,attrsList:t,attrsMap:Nr(t),rawAttrsMap:{},parent:n,children:[]}}function _r(e,t){sr=t.warn||Za,dr=t.isPreTag||S,lr=t.mustUseProp||S,yr=t.getTagNamespace||S;t.isReservedTag;or=Ka(t.modules,"transformNode"),ur=Ka(t.modules,"preTransformNode"),pr=Ka(t.modules,"postTransformNode"),rr=t.delimiters;var n,a,i=[],s=!1!==t.preserveWhitespace,r=t.whitespace,o=!1,u=!1;function p(e){if(d(e),o||e.processed||(e=Fr(e,t)),i.length||e===n||n.if&&(e.elseif||e.else)&&Cr(n,{exp:e.elseif,block:e}),a&&!e.forbidden)if(e.elseif||e.else)r=e,p=function(e){for(var t=e.length;t--;){if(1===e[t].type)return e[t];e.pop()}}(a.children),p&&p.if&&Cr(p,{exp:r.elseif,block:r});else{if(e.slotScope){var s=e.slotTarget||'"default"';(a.scopedSlots||(a.scopedSlots={}))[s]=e}a.children.push(e),e.parent=a}var r,p;e.children=e.children.filter((function(e){return!e.slotScope})),d(e),e.pre&&(o=!1),dr(e.tag)&&(u=!1);for(var l=0;l<pr.length;l++)pr[l](e,t)}function d(e){if(!u)for(var t=void 0;(t=e.children[e.children.length-1])&&3===t.type&&" "===t.text;)e.children.pop()}return function(e,t){for(var n,a,i=[],s=t.expectHTML,r=t.isUnaryTag||S,o=t.canBeLeftOpenTag||S,u=0,p=function(){if(n=e,a&&Js(a)){var p=0,y=a.toLowerCase(),c=Ys[y]||(Ys[y]=new RegExp("([\\s\\S]*?)(</"+y+"[^>]*>)","i"));k=e.replace(c,(function(e,n,a){return p=a.length,Js(y)||"noscript"===y||(n=n.replace(/<!\--([\s\S]*?)-->/g,"$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g,"$1")),ar(y,n)&&(n=n.slice(1)),t.chars&&t.chars(n),""})),u+=e.length-k.length,e=k,l(y,u-p,u)}else{var m=e.indexOf("<");if(0===m){if(Zs.test(e)){var f=e.indexOf("--\x3e");if(f>=0)return t.shouldKeepComment&&t.comment&&t.comment(e.substring(4,f),u,u+f+3),d(f+3),"continue"}if(Ks.test(e)){var b=e.indexOf("]>");if(b>=0)return d(b+2),"continue"}var h=e.match(Ws);if(h)return d(h[0].length),"continue";var T=e.match(Gs);if(T){var v=u;return d(T[0].length),l(T[1],v,u),"continue"}var w=function(){var t=e.match(js);if(t){var n={tagName:t[1],attrs:[],start:u};d(t[0].length);for(var a=void 0,i=void 0;!(a=e.match(zs))&&(i=e.match(Bs)||e.match($s));)i.start=u,d(i[0].length),i.end=u,n.attrs.push(i);if(a)return n.unarySlash=a[1],d(a[0].length),n.end=u,n}}();if(w)return function(e){var n=e.tagName,u=e.unarySlash;s&&("p"===a&&Ls(n)&&l(a),o(n)&&a===n&&l(n));for(var p=r(n)||!!u,d=e.attrs.length,y=new Array(d),c=0;c<d;c++){var m=e.attrs[c],f=m[3]||m[4]||m[5]||"",b="a"===n&&"href"===m[1]?t.shouldDecodeNewlinesForHref:t.shouldDecodeNewlines;y[c]={name:m[1],value:ir(f,b)}}p||(i.push({tag:n,lowerCasedTag:n.toLowerCase(),attrs:y,start:e.start,end:e.end}),a=n),t.start&&t.start(n,y,p,e.start,e.end)}(w),ar(w.tagName,e)&&d(1),"continue"}var g=void 0,k=void 0,M=void 0;if(m>=0){for(k=e.slice(m);!(Gs.test(k)||js.test(k)||Zs.test(k)||Ks.test(k)||(M=k.indexOf("<",1))<0);)m+=M,k=e.slice(m);g=e.substring(0,m)}m<0&&(g=e),g&&d(g.length),t.chars&&g&&t.chars(g,u-g.length,u)}if(e===n)return t.chars&&t.chars(e),"break"};e&&"break"!==p(););function d(t){u+=t,e=e.substring(t)}function l(e,n,s){var r,o;if(null==n&&(n=u),null==s&&(s=u),e)for(o=e.toLowerCase(),r=i.length-1;r>=0&&i[r].lowerCasedTag!==o;r--);else r=0;if(r>=0){for(var p=i.length-1;p>=r;p--)t.end&&t.end(i[p].tag,n,s);i.length=r,a=r&&i[r-1].tag}else"br"===o?t.start&&t.start(e,[],!0,n,s):"p"===o&&(t.start&&t.start(e,[],!1,n,s),t.end&&t.end(e,n,s))}l()}(e,{warn:sr,expectHTML:t.expectHTML,isUnaryTag:t.isUnaryTag,canBeLeftOpenTag:t.canBeLeftOpenTag,shouldDecodeNewlines:t.shouldDecodeNewlines,shouldDecodeNewlinesForHref:t.shouldDecodeNewlinesForHref,shouldKeepComment:t.comments,outputSourceRange:t.outputSourceRange,start:function(e,s,r,d,l){var y=a&&a.ns||yr(e);Z&&"svg"===y&&(s=function(e){for(var t=[],n=0;n<e.length;n++){var a=e[n];Pr.test(a.name)||(a.name=a.name.replace(Ur,""),t.push(a))}return t}(s));var c,m=xr(e,s,a);y&&(m.ns=y),"style"!==(c=m).tag&&("script"!==c.tag||c.attrsMap.type&&"text/javascript"!==c.attrsMap.type)||ie()||(m.forbidden=!0);for(var f=0;f<ur.length;f++)m=ur[f](m,t)||m;o||(function(e){null!=ii(e,"v-pre")&&(e.pre=!0)}(m),m.pre&&(o=!0)),dr(m.tag)&&(u=!0),o?function(e){var t=e.attrsList,n=t.length;if(n)for(var a=e.attrs=new Array(n),i=0;i<n;i++)a[i]={name:t[i].name,value:JSON.stringify(t[i].value)},null!=t[i].start&&(a[i].start=t[i].start,a[i].end=t[i].end);else e.pre||(e.plain=!0)}(m):m.processed||(Ar(m),function(e){var t=ii(e,"v-if");if(t)e.if=t,Cr(e,{exp:t,block:e});else{null!=ii(e,"v-else")&&(e.else=!0);var n=ii(e,"v-else-if");n&&(e.elseif=n)}}(m),function(e){null!=ii(e,"v-once")&&(e.once=!0)}(m)),n||(n=m),r?p(m):(a=m,i.push(m))},end:function(e,t,n){var s=i[i.length-1];i.length-=1,a=i[i.length-1],p(s)},chars:function(e,t,n){if(a&&(!Z||"textarea"!==a.tag||a.attrsMap.placeholder!==e)){var i,p=a.children;if(e=u||e.trim()?"script"===(i=a).tag||"style"===i.tag?e:Rr(e):p.length?r?"condense"===r&&Mr.test(e)?"":" ":s?" ":"":""){u||"condense"!==r||(e=e.replace(Ir," "));var d=void 0,l=void 0;!o&&" "!==e&&(d=function(e,t){var n=t?Ps(t):Os;if(n.test(e)){for(var a,i,s,r=[],o=[],u=n.lastIndex=0;a=n.exec(e);){(i=a.index)>u&&(o.push(s=e.slice(u,i)),r.push(JSON.stringify(s)));var p=Ga(a[1].trim());r.push("_s(".concat(p,")")),o.push({"@binding":p}),u=i+a[0].length}return u<e.length&&(o.push(s=e.slice(u)),r.push(JSON.stringify(s))),{expression:r.join("+"),tokens:o}}}(e,rr))?l={type:2,expression:d.expression,tokens:d.tokens,text:e}:" "===e&&p.length&&" "===p[p.length-1].text||(l={type:3,text:e}),l&&p.push(l)}}},comment:function(e,t,n){if(a){var i={type:3,text:e,isComment:!0};a.children.push(i)}}}),n}function Fr(e,t){var n;!function(e){var t=ai(e,"key");t&&(e.key=t)}(e),e.plain=!e.key&&!e.scopedSlots&&!e.attrsList.length,function(e){var t=ai(e,"ref");t&&(e.ref=t,e.refInFor=function(e){for(var t=e;t;){if(void 0!==t.for)return!0;t=t.parent}return!1}(e))}(e),function(e){var t;"template"===e.tag?(t=ii(e,"scope"),e.slotScope=t||ii(e,"slot-scope")):(t=ii(e,"slot-scope"))&&(e.slotScope=t);var n,a=ai(e,"slot");if(a&&(e.slotTarget='""'===a?'"default"':a,e.slotTargetDynamic=!(!e.attrsMap[":slot"]&&!e.attrsMap["v-bind:slot"]),"template"===e.tag||e.slotScope||Ya(e,"slot",a,function(e,t){return e.rawAttrsMap[":slot"]||e.rawAttrsMap["v-bind:slot"]||e.rawAttrsMap.slot}(e))),"template"===e.tag){if(n=si(e,kr)){var i=Sr(n),s=i.name,r=i.dynamic;e.slotTarget=s,e.slotTargetDynamic=r,e.slotScope=n.value||Er}}else if(n=si(e,kr)){var o=e.scopedSlots||(e.scopedSlots={}),u=Sr(n),p=u.name,d=(r=u.dynamic,o[p]=xr("template",[],e));d.slotTarget=p,d.slotTargetDynamic=r,d.children=e.children.filter((function(e){if(!e.slotScope)return e.parent=d,!0})),d.slotScope=n.value||Er,e.children=[],e.plain=!1}}(e),"slot"===(n=e).tag&&(n.slotName=ai(n,"name")),function(e){var t;(t=ai(e,"is"))&&(e.component=t),null!=ii(e,"inline-template")&&(e.inlineTemplate=!0)}(e);for(var a=0;a<or.length;a++)e=or[a](e,t)||e;return function(e){var t,n,a,i,s,r,o,u,p=e.attrsList;for(t=0,n=p.length;t<n;t++)if(a=i=p[t].name,s=p[t].value,mr.test(a))if(e.hasBindings=!0,(r=Or(a.replace(mr,"")))&&(a=a.replace(gr,"")),wr.test(a))a=a.replace(wr,""),s=Ga(s),(u=Tr.test(a))&&(a=a.slice(1,-1)),r&&(r.prop&&!u&&"innerHtml"===(a=M(a))&&(a="innerHTML"),r.camel&&!u&&(a=M(a)),r.sync&&(o=ui(s,"$event"),u?ni(e,'"update:"+('.concat(a,")"),o,null,!1,0,p[t],!0):(ni(e,"update:".concat(M(a)),o,null,!1,0,p[t]),E(a)!==M(a)&&ni(e,"update:".concat(E(a)),o,null,!1,0,p[t])))),r&&r.prop||!e.component&&lr(e.tag,e.attrsMap.type,a)?Ja(e,a,s,p[t],u):Ya(e,a,s,p[t],u);else if(cr.test(a))a=a.replace(cr,""),(u=Tr.test(a))&&(a=a.slice(1,-1)),ni(e,a,s,r,!1,0,p[t],u);else{var d=(a=a.replace(mr,"")).match(vr),l=d&&d[1];u=!1,l&&(a=a.slice(0,-(l.length+1)),Tr.test(l)&&(l=l.slice(1,-1),u=!0)),ei(e,a,i,s,l,u,r,p[t])}else Ya(e,a,JSON.stringify(s),p[t]),!e.component&&"muted"===a&&lr(e.tag,e.attrsMap.type,a)&&Ja(e,a,"true",p[t])}(e),e}function Ar(e){var t;if(t=ii(e,"v-for")){var n=function(e){var t=e.match(fr);if(t){var n={};n.for=t[2].trim();var a=t[1].trim().replace(hr,""),i=a.match(br);return i?(n.alias=a.replace(br,"").trim(),n.iterator1=i[1].trim(),i[2]&&(n.iterator2=i[2].trim())):n.alias=a,n}}(t);n&&F(e,n)}}function Cr(e,t){e.ifConditions||(e.ifConditions=[]),e.ifConditions.push(t)}function Sr(e){var t=e.name.replace(kr,"");return t||"#"!==e.name[0]&&(t="default"),Tr.test(t)?{name:t.slice(1,-1),dynamic:!0}:{name:'"'.concat(t,'"'),dynamic:!1}}function Or(e){var t=e.match(gr);if(t){var n={};return t.forEach((function(e){n[e.slice(1)]=!0})),n}}function Nr(e){for(var t={},n=0,a=e.length;n<a;n++)t[e[n].name]=e[n].value;return t}var Pr=/^xmlns:NS\d+/,Ur=/^NS\d+:/;function Dr(e){return xr(e.tag,e.attrsList.slice(),e.parent)}var Xr,Vr,Lr=[Us,Ds,{preTransformNode:function(e,t){if("input"===e.tag){var n=e.attrsMap;if(!n["v-model"])return;var a=void 0;if((n[":type"]||n["v-bind:type"])&&(a=ai(e,"type")),n.type||a||!n["v-bind"]||(a="(".concat(n["v-bind"],").type")),a){var i=ii(e,"v-if",!0),s=i?"&&(".concat(i,")"):"",r=null!=ii(e,"v-else",!0),o=ii(e,"v-else-if",!0),u=Dr(e);Ar(u),Qa(u,"type","checkbox"),Fr(u,t),u.processed=!0,u.if="(".concat(a,")==='checkbox'")+s,Cr(u,{exp:u.if,block:u});var p=Dr(e);ii(p,"v-for",!0),Qa(p,"type","radio"),Fr(p,t),Cr(u,{exp:"(".concat(a,")==='radio'")+s,block:p});var d=Dr(e);return ii(d,"v-for",!0),Qa(d,":type",a),Fr(d,t),Cr(u,{exp:i,block:d}),r?u.else=!0:o&&(u.elseif=o),u}}}}],$r={expectHTML:!0,modules:Lr,directives:{model:function(e,t,n){var a=t.value,i=t.modifiers,s=e.tag,r=e.attrsMap.type;if(e.component)return oi(e,a,i),!1;if("select"===s)!function(e,t,n){var a=n&&n.number,i='Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;'+"return ".concat(a?"_n(val)":"val","})"),s="var $$selectedVal = ".concat(i,";");ni(e,"change",s="".concat(s," ").concat(ui(t,"$event.target.multiple ? $$selectedVal : $$selectedVal[0]")),null,!0)}(e,a,i);else if("input"===s&&"checkbox"===r)!function(e,t,n){var a=n&&n.number,i=ai(e,"value")||"null",s=ai(e,"true-value")||"true",r=ai(e,"false-value")||"false";Ja(e,"checked","Array.isArray(".concat(t,")")+"?_i(".concat(t,",").concat(i,")>-1")+("true"===s?":(".concat(t,")"):":_q(".concat(t,",").concat(s,")"))),ni(e,"change","var $$a=".concat(t,",")+"$$el=$event.target,"+"$$c=$$el.checked?(".concat(s,"):(").concat(r,");")+"if(Array.isArray($$a)){"+"var $$v=".concat(a?"_n("+i+")":i,",")+"$$i=_i($$a,$$v);"+"if($$el.checked){$$i<0&&(".concat(ui(t,"$$a.concat([$$v])"),")}")+"else{$$i>-1&&(".concat(ui(t,"$$a.slice(0,$$i).concat($$a.slice($$i+1))"),")}")+"}else{".concat(ui(t,"$$c"),"}"),null,!0)}(e,a,i);else if("input"===s&&"radio"===r)!function(e,t,n){var a=n&&n.number,i=ai(e,"value")||"null";i=a?"_n(".concat(i,")"):i,Ja(e,"checked","_q(".concat(t,",").concat(i,")")),ni(e,"change",ui(t,i),null,!0)}(e,a,i);else if("input"===s||"textarea"===s)!function(e,t,n){var a=e.attrsMap.type,i=n||{},s=i.lazy,r=i.number,o=i.trim,u=!s&&"range"!==a,p=s?"change":"range"===a?"__r":"input",d="$event.target.value";o&&(d="$event.target.value.trim()"),r&&(d="_n(".concat(d,")"));var l=ui(t,d);u&&(l="if($event.target.composing)return;".concat(l)),Ja(e,"value","(".concat(t,")")),ni(e,p,l,null,!0),(o||r)&&ni(e,"blur","$forceUpdate()")}(e,a,i);else if(!$.isReservedTag(s))return oi(e,a,i),!1;return!0},text:function(e,t){t.value&&Ja(e,"textContent","_s(".concat(t.value,")"),t)},html:function(e,t){t.value&&Ja(e,"innerHTML","_s(".concat(t.value,")"),t)}},isPreTag:function(e){return"pre"===e},isUnaryTag:Xs,mustUseProp:ea,canBeLeftOpenTag:Vs,isReservedTag:ma,getTagNamespace:fa,staticKeys:function(e){return e.reduce((function(e,t){return e.concat(t.staticKeys||[])}),[]).join(",")}(Lr)},Br=g((function(e){return f("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap"+(e?","+e:""))}));function Hr(e,t){e&&(Xr=Br(t.staticKeys||""),Vr=t.isReservedTag||S,qr(e),jr(e,!1))}function qr(e){if(e.static=function(e){return 2!==e.type&&(3===e.type||!(!e.pre&&(e.hasBindings||e.if||e.for||b(e.tag)||!Vr(e.tag)||function(e){for(;e.parent;){if("template"!==(e=e.parent).tag)return!1;if(e.for)return!0}return!1}(e)||!Object.keys(e).every(Xr))))}(e),1===e.type){if(!Vr(e.tag)&&"slot"!==e.tag&&null==e.attrsMap["inline-template"])return;for(var t=0,n=e.children.length;t<n;t++){var a=e.children[t];qr(a),a.static||(e.static=!1)}if(e.ifConditions)for(t=1,n=e.ifConditions.length;t<n;t++){var i=e.ifConditions[t].block;qr(i),i.static||(e.static=!1)}}}function jr(e,t){if(1===e.type){if((e.static||e.once)&&(e.staticInFor=t),e.static&&e.children.length&&(1!==e.children.length||3!==e.children[0].type))return void(e.staticRoot=!0);if(e.staticRoot=!1,e.children)for(var n=0,a=e.children.length;n<a;n++)jr(e.children[n],t||!!e.for);if(e.ifConditions)for(n=1,a=e.ifConditions.length;n<a;n++)jr(e.ifConditions[n].block,t)}}var zr=/^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/,Gr=/\([^)]*?\);*$/,Wr=/^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,Zr={esc:27,tab:9,enter:13,space:32,up:38,left:37,right:39,down:40,delete:[8,46]},Kr={esc:["Esc","Escape"],tab:"Tab",enter:"Enter",space:[" ","Spacebar"],up:["Up","ArrowUp"],left:["Left","ArrowLeft"],right:["Right","ArrowRight"],down:["Down","ArrowDown"],delete:["Backspace","Delete","Del"]},Jr=function(e){return"if(".concat(e,")return null;")},Yr={stop:"$event.stopPropagation();",prevent:"$event.preventDefault();",self:Jr("$event.target !== $event.currentTarget"),ctrl:Jr("!$event.ctrlKey"),shift:Jr("!$event.shiftKey"),alt:Jr("!$event.altKey"),meta:Jr("!$event.metaKey"),left:Jr("'button' in $event && $event.button !== 0"),middle:Jr("'button' in $event && $event.button !== 1"),right:Jr("'button' in $event && $event.button !== 2")};function Qr(e,t){var n=t?"nativeOn:":"on:",a="",i="";for(var s in e){var r=eo(e[s]);e[s]&&e[s].dynamic?i+="".concat(s,",").concat(r,","):a+='"'.concat(s,'":').concat(r,",")}return a="{".concat(a.slice(0,-1),"}"),i?n+"_d(".concat(a,",[").concat(i.slice(0,-1),"])"):n+a}function eo(e){if(!e)return"function(){}";if(Array.isArray(e))return"[".concat(e.map((function(e){return eo(e)})).join(","),"]");var t=Wr.test(e.value),n=zr.test(e.value),a=Wr.test(e.value.replace(Gr,""));if(e.modifiers){var i="",s="",r=[],o=function(t){if(Yr[t])s+=Yr[t],Zr[t]&&r.push(t);else if("exact"===t){var n=e.modifiers;s+=Jr(["ctrl","shift","alt","meta"].filter((function(e){return!n[e]})).map((function(e){return"$event.".concat(e,"Key")})).join("||"))}else r.push(t)};for(var u in e.modifiers)o(u);r.length&&(i+=function(e){return"if(!$event.type.indexOf('key')&&"+"".concat(e.map(to).join("&&"),")return null;")}(r)),s&&(i+=s);var p=t?"return ".concat(e.value,".apply(null, arguments)"):n?"return (".concat(e.value,").apply(null, arguments)"):a?"return ".concat(e.value):e.value;return"function($event){".concat(i).concat(p,"}")}return t||n?e.value:"function($event){".concat(a?"return ".concat(e.value):e.value,"}")}function to(e){var t=parseInt(e,10);if(t)return"$event.keyCode!==".concat(t);var n=Zr[e],a=Kr[e];return"_k($event.keyCode,"+"".concat(JSON.stringify(e),",")+"".concat(JSON.stringify(n),",")+"$event.key,"+"".concat(JSON.stringify(a))+")"}var no={on:function(e,t){e.wrapListeners=function(e){return"_g(".concat(e,",").concat(t.value,")")}},bind:function(e,t){e.wrapData=function(n){return"_b(".concat(n,",'").concat(e.tag,"',").concat(t.value,",").concat(t.modifiers&&t.modifiers.prop?"true":"false").concat(t.modifiers&&t.modifiers.sync?",true":"",")")}},cloak:C},ao=function(e){this.options=e,this.warn=e.warn||Za,this.transforms=Ka(e.modules,"transformCode"),this.dataGenFns=Ka(e.modules,"genData"),this.directives=F(F({},no),e.directives);var t=e.isReservedTag||S;this.maybeComponent=function(e){return!!e.component||!t(e.tag)},this.onceId=0,this.staticRenderFns=[],this.pre=!1};function io(e,t){var n=new ao(t),a=e?"script"===e.tag?"null":so(e,n):'_c("div")';return{render:"with(this){return ".concat(a,"}"),staticRenderFns:n.staticRenderFns}}function so(e,t){if(e.parent&&(e.pre=e.pre||e.parent.pre),e.staticRoot&&!e.staticProcessed)return ro(e,t);if(e.once&&!e.onceProcessed)return oo(e,t);if(e.for&&!e.forProcessed)return lo(e,t);if(e.if&&!e.ifProcessed)return uo(e,t);if("template"!==e.tag||e.slotTarget||t.pre){if("slot"===e.tag)return function(e,t){var n=e.slotName||'"default"',a=fo(e,t),i="_t(".concat(n).concat(a?",function(){return ".concat(a,"}"):""),s=e.attrs||e.dynamicAttrs?To((e.attrs||[]).concat(e.dynamicAttrs||[]).map((function(e){return{name:M(e.name),value:e.value,dynamic:e.dynamic}}))):null,r=e.attrsMap["v-bind"];return!s&&!r||a||(i+=",null"),s&&(i+=",".concat(s)),r&&(i+="".concat(s?"":",null",",").concat(r)),i+")"}(e,t);var n=void 0;if(e.component)n=function(e,t,n){var a=t.inlineTemplate?null:fo(t,n,!0);return"_c(".concat(e,",").concat(yo(t,n)).concat(a?",".concat(a):"",")")}(e.component,e,t);else{var a=void 0,i=t.maybeComponent(e);(!e.plain||e.pre&&i)&&(a=yo(e,t));var s=void 0,r=t.options.bindings;i&&r&&!1!==r.__isScriptSetup&&(s=function(e,t){var n=M(t),a=I(n),i=function(i){return e[t]===i?t:e[n]===i?n:e[a]===i?a:void 0},s=i("setup-const")||i("setup-reactive-const");if(s)return s;var r=i("setup-let")||i("setup-ref")||i("setup-maybe-ref");return r||void 0}(r,e.tag)),s||(s="'".concat(e.tag,"'"));var o=e.inlineTemplate?null:fo(e,t,!0);n="_c(".concat(s).concat(a?",".concat(a):"").concat(o?",".concat(o):"",")")}for(var u=0;u<t.transforms.length;u++)n=t.transforms[u](e,n);return n}return fo(e,t)||"void 0"}function ro(e,t){e.staticProcessed=!0;var n=t.pre;return e.pre&&(t.pre=e.pre),t.staticRenderFns.push("with(this){return ".concat(so(e,t),"}")),t.pre=n,"_m(".concat(t.staticRenderFns.length-1).concat(e.staticInFor?",true":"",")")}function oo(e,t){if(e.onceProcessed=!0,e.if&&!e.ifProcessed)return uo(e,t);if(e.staticInFor){for(var n="",a=e.parent;a;){if(a.for){n=a.key;break}a=a.parent}return n?"_o(".concat(so(e,t),",").concat(t.onceId++,",").concat(n,")"):so(e,t)}return ro(e,t)}function uo(e,t,n,a){return e.ifProcessed=!0,po(e.ifConditions.slice(),t,n,a)}function po(e,t,n,a){if(!e.length)return a||"_e()";var i=e.shift();return i.exp?"(".concat(i.exp,")?").concat(s(i.block),":").concat(po(e,t,n,a)):"".concat(s(i.block));function s(e){return n?n(e,t):e.once?oo(e,t):so(e,t)}}function lo(e,t,n,a){var i=e.for,s=e.alias,r=e.iterator1?",".concat(e.iterator1):"",o=e.iterator2?",".concat(e.iterator2):"";return e.forProcessed=!0,"".concat(a||"_l","((").concat(i,"),")+"function(".concat(s).concat(r).concat(o,"){")+"return ".concat((n||so)(e,t))+"})"}function yo(e,t){var n="{",a=function(e,t){var n=e.directives;if(n){var a,i,s,r,o="directives:[",u=!1;for(a=0,i=n.length;a<i;a++){s=n[a],r=!0;var p=t.directives[s.name];p&&(r=!!p(e,s,t.warn)),r&&(u=!0,o+='{name:"'.concat(s.name,'",rawName:"').concat(s.rawName,'"').concat(s.value?",value:(".concat(s.value,"),expression:").concat(JSON.stringify(s.value)):"").concat(s.arg?",arg:".concat(s.isDynamicArg?s.arg:'"'.concat(s.arg,'"')):"").concat(s.modifiers?",modifiers:".concat(JSON.stringify(s.modifiers)):"","},"))}return u?o.slice(0,-1)+"]":void 0}}(e,t);a&&(n+=a+","),e.key&&(n+="key:".concat(e.key,",")),e.ref&&(n+="ref:".concat(e.ref,",")),e.refInFor&&(n+="refInFor:true,"),e.pre&&(n+="pre:true,"),e.component&&(n+='tag:"'.concat(e.tag,'",'));for(var i=0;i<t.dataGenFns.length;i++)n+=t.dataGenFns[i](e);if(e.attrs&&(n+="attrs:".concat(To(e.attrs),",")),e.props&&(n+="domProps:".concat(To(e.props),",")),e.events&&(n+="".concat(Qr(e.events,!1),",")),e.nativeEvents&&(n+="".concat(Qr(e.nativeEvents,!0),",")),e.slotTarget&&!e.slotScope&&(n+="slot:".concat(e.slotTarget,",")),e.scopedSlots&&(n+="".concat(function(e,t,n){var a=e.for||Object.keys(t).some((function(e){var n=t[e];return n.slotTargetDynamic||n.if||n.for||co(n)})),i=!!e.if;if(!a)for(var s=e.parent;s;){if(s.slotScope&&s.slotScope!==Er||s.for){a=!0;break}s.if&&(i=!0),s=s.parent}var r=Object.keys(t).map((function(e){return mo(t[e],n)})).join(",");return"scopedSlots:_u([".concat(r,"]").concat(a?",null,true":"").concat(!a&&i?",null,false,".concat(function(e){for(var t=5381,n=e.length;n;)t=33*t^e.charCodeAt(--n);return t>>>0}(r)):"",")")}(e,e.scopedSlots,t),",")),e.model&&(n+="model:{value:".concat(e.model.value,",callback:").concat(e.model.callback,",expression:").concat(e.model.expression,"},")),e.inlineTemplate){var s=function(e,t){var n=e.children[0];if(n&&1===n.type){var a=io(n,t.options);return"inlineTemplate:{render:function(){".concat(a.render,"},staticRenderFns:[").concat(a.staticRenderFns.map((function(e){return"function(){".concat(e,"}")})).join(","),"]}")}}(e,t);s&&(n+="".concat(s,","))}return n=n.replace(/,$/,"")+"}",e.dynamicAttrs&&(n="_b(".concat(n,',"').concat(e.tag,'",').concat(To(e.dynamicAttrs),")")),e.wrapData&&(n=e.wrapData(n)),e.wrapListeners&&(n=e.wrapListeners(n)),n}function co(e){return 1===e.type&&("slot"===e.tag||e.children.some(co))}function mo(e,t){var n=e.attrsMap["slot-scope"];if(e.if&&!e.ifProcessed&&!n)return uo(e,t,mo,"null");if(e.for&&!e.forProcessed)return lo(e,t,mo);var a=e.slotScope===Er?"":String(e.slotScope),i="function(".concat(a,"){")+"return ".concat("template"===e.tag?e.if&&n?"(".concat(e.if,")?").concat(fo(e,t)||"undefined",":undefined"):fo(e,t)||"undefined":so(e,t),"}"),s=a?"":",proxy:true";return"{key:".concat(e.slotTarget||'"default"',",fn:").concat(i).concat(s,"}")}function fo(e,t,n,a,i){var s=e.children;if(s.length){var r=s[0];if(1===s.length&&r.for&&"template"!==r.tag&&"slot"!==r.tag){var o=n?t.maybeComponent(r)?",1":",0":"";return"".concat((a||so)(r,t)).concat(o)}var u=n?function(e,t){for(var n=0,a=0;a<e.length;a++){var i=e[a];if(1===i.type){if(bo(i)||i.ifConditions&&i.ifConditions.some((function(e){return bo(e.block)}))){n=2;break}(t(i)||i.ifConditions&&i.ifConditions.some((function(e){return t(e.block)})))&&(n=1)}}return n}(s,t.maybeComponent):0,p=i||ho;return"[".concat(s.map((function(e){return p(e,t)})).join(","),"]").concat(u?",".concat(u):"")}}function bo(e){return void 0!==e.for||"template"===e.tag||"slot"===e.tag}function ho(e,t){return 1===e.type?so(e,t):3===e.type&&e.isComment?function(e){return"_e(".concat(JSON.stringify(e.text),")")}(e):"_v(".concat(2===(n=e).type?n.expression:vo(JSON.stringify(n.text)),")");var n}function To(e){for(var t="",n="",a=0;a<e.length;a++){var i=e[a],s=vo(i.value);i.dynamic?n+="".concat(i.name,",").concat(s,","):t+='"'.concat(i.name,'":').concat(s,",")}return t="{".concat(t.slice(0,-1),"}"),n?"_d(".concat(t,",[").concat(n.slice(0,-1),"])"):t}function vo(e){return e.replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}function wo(e,t){try{return new Function(e)}catch(n){return t.push({err:n,code:e}),C}}function go(e){var t=Object.create(null);return function(n,a,i){(a=F({},a)).warn,delete a.warn;var s=a.delimiters?String(a.delimiters)+n:n;if(t[s])return t[s];var r=e(n,a),o={},u=[];return o.render=wo(r.render,u),o.staticRenderFns=r.staticRenderFns.map((function(e){return wo(e,u)})),t[s]=o}}new RegExp("\\b"+"do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b")+"\\b"),new RegExp("\\b"+"delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b")+"\\s*\\([^\\)]*\\)");var ko,Mo,Io=(ko=function(e,t){var n=_r(e.trim(),t);!1!==t.optimize&&Hr(n,t);var a=io(n,t);return{ast:n,render:a.render,staticRenderFns:a.staticRenderFns}},function(e){function t(t,n){var a=Object.create(e),i=[],s=[];if(n)for(var r in n.modules&&(a.modules=(e.modules||[]).concat(n.modules)),n.directives&&(a.directives=F(Object.create(e.directives||null),n.directives)),n)"modules"!==r&&"directives"!==r&&(a[r]=n[r]);a.warn=function(e,t,n){(n?s:i).push(e)};var o=ko(t.trim(),a);return o.errors=i,o.tips=s,o}return{compile:t,compileToFunctions:go(t)}}),Ro=Io($r).compileToFunctions;function Eo(e){return(Mo=Mo||document.createElement("div")).innerHTML=e?'<a href="\n"/>':'<div a="\n"/>',Mo.innerHTML.indexOf("&#10;")>0}var xo=!!G&&Eo(!1),_o=!!G&&Eo(!0),Fo=g((function(e){var t=Ta(e);return t&&t.innerHTML})),Ao=jn.prototype.$mount;function Co(e,t){for(var n in t)e[n]=t[n];return e}jn.prototype.$mount=function(e,t){if((e=e&&Ta(e))===document.body||e===document.documentElement)return this;var n=this.$options;if(!n.render){var a=n.template;if(a)if("string"==typeof a)"#"===a.charAt(0)&&(a=Fo(a));else{if(!a.nodeType)return this;a=a.innerHTML}else e&&(a=function(e){if(e.outerHTML)return e.outerHTML;var t=document.createElement("div");return t.appendChild(e.cloneNode(!0)),t.innerHTML}(e));if(a){var i=Ro(a,{outputSourceRange:!1,shouldDecodeNewlines:xo,shouldDecodeNewlinesForHref:_o,delimiters:n.delimiters,comments:n.comments},this),s=i.render,r=i.staticRenderFns;n.render=s,n.staticRenderFns=r}}return Ao.call(this,e,t)},jn.compile=Ro;var So=/[!'()*]/g,Oo=function(e){return"%"+e.charCodeAt(0).toString(16)},No=/%2C/g,Po=function(e){return encodeURIComponent(e).replace(So,Oo).replace(No,",")};function Uo(e){try{return decodeURIComponent(e)}catch(e){}return e}var Do=function(e){return null==e||"object"==typeof e?e:String(e)};function Xo(e){var t={};return(e=e.trim().replace(/^(\?|#|&)/,""))?(e.split("&").forEach((function(e){var n=e.replace(/\+/g," ").split("="),a=Uo(n.shift()),i=n.length>0?Uo(n.join("=")):null;void 0===t[a]?t[a]=i:Array.isArray(t[a])?t[a].push(i):t[a]=[t[a],i]})),t):t}function Vo(e){var t=e?Object.keys(e).map((function(t){var n=e[t];if(void 0===n)return"";if(null===n)return Po(t);if(Array.isArray(n)){var a=[];return n.forEach((function(e){void 0!==e&&(null===e?a.push(Po(t)):a.push(Po(t)+"="+Po(e)))})),a.join("&")}return Po(t)+"="+Po(n)})).filter((function(e){return e.length>0})).join("&"):null;return t?"?"+t:""}var Lo=/\/?$/;function $o(e,t,n,a){var i=a&&a.options.stringifyQuery,s=t.query||{};try{s=Bo(s)}catch(e){}var r={name:t.name||e&&e.name,meta:e&&e.meta||{},path:t.path||"/",hash:t.hash||"",query:s,params:t.params||{},fullPath:jo(t,i),matched:e?qo(e):[]};return n&&(r.redirectedFrom=jo(n,i)),Object.freeze(r)}function Bo(e){if(Array.isArray(e))return e.map(Bo);if(e&&"object"==typeof e){var t={};for(var n in e)t[n]=Bo(e[n]);return t}return e}var Ho=$o(null,{path:"/"});function qo(e){for(var t=[];e;)t.unshift(e),e=e.parent;return t}function jo(e,t){var n=e.path,a=e.query;void 0===a&&(a={});var i=e.hash;return void 0===i&&(i=""),(n||"/")+(t||Vo)(a)+i}function zo(e,t,n){return t===Ho?e===t:!!t&&(e.path&&t.path?e.path.replace(Lo,"")===t.path.replace(Lo,"")&&(n||e.hash===t.hash&&Go(e.query,t.query)):!(!e.name||!t.name)&&e.name===t.name&&(n||e.hash===t.hash&&Go(e.query,t.query)&&Go(e.params,t.params)))}function Go(e,t){if(void 0===e&&(e={}),void 0===t&&(t={}),!e||!t)return e===t;var n=Object.keys(e).sort(),a=Object.keys(t).sort();return n.length===a.length&&n.every((function(n,i){var s=e[n];if(a[i]!==n)return!1;var r=t[n];return null==s||null==r?s===r:"object"==typeof s&&"object"==typeof r?Go(s,r):String(s)===String(r)}))}function Wo(e){for(var t=0;t<e.matched.length;t++){var n=e.matched[t];for(var a in n.instances){var i=n.instances[a],s=n.enteredCbs[a];if(i&&s){delete n.enteredCbs[a];for(var r=0;r<s.length;r++)i._isBeingDestroyed||s[r](i)}}}}var Zo={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(e,t){var n=t.props,a=t.children,i=t.parent,s=t.data;s.routerView=!0;for(var r=i.$createElement,o=n.name,u=i.$route,p=i._routerViewCache||(i._routerViewCache={}),d=0,l=!1;i&&i._routerRoot!==i;){var y=i.$vnode?i.$vnode.data:{};y.routerView&&d++,y.keepAlive&&i._directInactive&&i._inactive&&(l=!0),i=i.$parent}if(s.routerViewDepth=d,l){var c=p[o],m=c&&c.component;return m?(c.configProps&&Ko(m,s,c.route,c.configProps),r(m,s,a)):r()}var f=u.matched[d],b=f&&f.components[o];if(!f||!b)return p[o]=null,r();p[o]={component:b},s.registerRouteInstance=function(e,t){var n=f.instances[o];(t&&n!==e||!t&&n===e)&&(f.instances[o]=t)},(s.hook||(s.hook={})).prepatch=function(e,t){f.instances[o]=t.componentInstance},s.hook.init=function(e){e.data.keepAlive&&e.componentInstance&&e.componentInstance!==f.instances[o]&&(f.instances[o]=e.componentInstance),Wo(u)};var h=f.props&&f.props[o];return h&&(Co(p[o],{route:u,configProps:h}),Ko(b,s,u,h)),r(b,s,a)}};function Ko(e,t,n,a){var i=t.props=function(e,t){switch(typeof t){case"undefined":return;case"object":return t;case"function":return t(e);case"boolean":return t?e.params:void 0}}(n,a);if(i){i=t.props=Co({},i);var s=t.attrs=t.attrs||{};for(var r in i)e.props&&r in e.props||(s[r]=i[r],delete i[r])}}function Jo(e,t,n){var a=e.charAt(0);if("/"===a)return e;if("?"===a||"#"===a)return t+e;var i=t.split("/");n&&i[i.length-1]||i.pop();for(var s=e.replace(/^\//,"").split("/"),r=0;r<s.length;r++){var o=s[r];".."===o?i.pop():"."!==o&&i.push(o)}return""!==i[0]&&i.unshift(""),i.join("/")}function Yo(e){return e.replace(/\/(?:\s*\/)+/g,"/")}var Qo=Array.isArray||function(e){return"[object Array]"==Object.prototype.toString.call(e)},eu=function e(t,n,a){return Qo(n)||(a=n||a,n=[]),a=a||{},t instanceof RegExp?function(e,t){var n=e.source.match(/\((?!\?)/g);if(n)for(var a=0;a<n.length;a++)t.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return lu(e,t)}(t,n):Qo(t)?function(t,n,a){for(var i=[],s=0;s<t.length;s++)i.push(e(t[s],n,a).source);return lu(new RegExp("(?:"+i.join("|")+")",yu(a)),n)}(t,n,a):function(e,t,n){return cu(su(e,n),t,n)}(t,n,a)},tu=su,nu=uu,au=cu,iu=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function su(e,t){for(var n,a=[],i=0,s=0,r="",o=t&&t.delimiter||"/";null!=(n=iu.exec(e));){var u=n[0],p=n[1],d=n.index;if(r+=e.slice(s,d),s=d+u.length,p)r+=p[1];else{var l=e[s],y=n[2],c=n[3],m=n[4],f=n[5],b=n[6],h=n[7];r&&(a.push(r),r="");var T=null!=y&&null!=l&&l!==y,v="+"===b||"*"===b,w="?"===b||"*"===b,g=n[2]||o,k=m||f;a.push({name:c||i++,prefix:y||"",delimiter:g,optional:w,repeat:v,partial:T,asterisk:!!h,pattern:k?du(k):h?".*":"[^"+pu(g)+"]+?"})}}return s<e.length&&(r+=e.substr(s)),r&&a.push(r),a}function ru(e){return encodeURI(e).replace(/[\/?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function ou(e){return encodeURI(e).replace(/[?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function uu(e,t){for(var n=new Array(e.length),a=0;a<e.length;a++)"object"==typeof e[a]&&(n[a]=new RegExp("^(?:"+e[a].pattern+")$",yu(t)));return function(t,a){for(var i="",s=t||{},r=(a||{}).pretty?ru:encodeURIComponent,o=0;o<e.length;o++){var u=e[o];if("string"!=typeof u){var p,d=s[u.name];if(null==d){if(u.optional){u.partial&&(i+=u.prefix);continue}throw new TypeError('Expected "'+u.name+'" to be defined')}if(Qo(d)){if(!u.repeat)throw new TypeError('Expected "'+u.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(u.optional)continue;throw new TypeError('Expected "'+u.name+'" to not be empty')}for(var l=0;l<d.length;l++){if(p=r(d[l]),!n[o].test(p))throw new TypeError('Expected all "'+u.name+'" to match "'+u.pattern+'", but received `'+JSON.stringify(p)+"`");i+=(0===l?u.prefix:u.delimiter)+p}}else{if(p=u.asterisk?ou(d):r(d),!n[o].test(p))throw new TypeError('Expected "'+u.name+'" to match "'+u.pattern+'", but received "'+p+'"');i+=u.prefix+p}}else i+=u}return i}}function pu(e){return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function du(e){return e.replace(/([=!:$\/()])/g,"\\$1")}function lu(e,t){return e.keys=t,e}function yu(e){return e&&e.sensitive?"":"i"}function cu(e,t,n){Qo(t)||(n=t||n,t=[]);for(var a=(n=n||{}).strict,i=!1!==n.end,s="",r=0;r<e.length;r++){var o=e[r];if("string"==typeof o)s+=pu(o);else{var u=pu(o.prefix),p="(?:"+o.pattern+")";t.push(o),o.repeat&&(p+="(?:"+u+p+")*"),s+=p=o.optional?o.partial?u+"("+p+")?":"(?:"+u+"("+p+"))?":u+"("+p+")"}}var d=pu(n.delimiter||"/"),l=s.slice(-d.length)===d;return a||(s=(l?s.slice(0,-d.length):s)+"(?:"+d+"(?=$))?"),s+=i?"$":a&&l?"":"(?="+d+"|$)",lu(new RegExp("^"+s,yu(n)),t)}eu.parse=tu,eu.compile=function(e,t){return uu(su(e,t),t)},eu.tokensToFunction=nu,eu.tokensToRegExp=au;var mu=Object.create(null);function fu(e,t,n){t=t||{};try{var a=mu[e]||(mu[e]=eu.compile(e));return"string"==typeof t.pathMatch&&(t[0]=t.pathMatch),a(t,{pretty:!0})}catch(e){return""}finally{delete t[0]}}function bu(e,t,n,a){var i="string"==typeof e?{path:e}:e;if(i._normalized)return i;if(i.name){var s=(i=Co({},e)).params;return s&&"object"==typeof s&&(i.params=Co({},s)),i}if(!i.path&&i.params&&t){(i=Co({},i))._normalized=!0;var r=Co(Co({},t.params),i.params);if(t.name)i.name=t.name,i.params=r;else if(t.matched.length){var o=t.matched[t.matched.length-1].path;i.path=fu(o,r,t.path)}return i}var u=function(e){var t="",n="",a=e.indexOf("#");a>=0&&(t=e.slice(a),e=e.slice(0,a));var i=e.indexOf("?");return i>=0&&(n=e.slice(i+1),e=e.slice(0,i)),{path:e,query:n,hash:t}}(i.path||""),p=t&&t.path||"/",d=u.path?Jo(u.path,p,n||i.append):p,l=function(e,t,n){void 0===t&&(t={});var a,i=n||Xo;try{a=i(e||"")}catch(e){a={}}for(var s in t){var r=t[s];a[s]=Array.isArray(r)?r.map(Do):Do(r)}return a}(u.query,i.query,a&&a.options.parseQuery),y=i.hash||u.hash;return y&&"#"!==y.charAt(0)&&(y="#"+y),{_normalized:!0,path:d,query:l,hash:y}}var hu,Tu=function(){},vu={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(e){var t=this,n=this.$router,a=this.$route,i=n.resolve(this.to,a,this.append),s=i.location,r=i.route,o=i.href,u={},p=n.options.linkActiveClass,d=n.options.linkExactActiveClass,l=null==p?"router-link-active":p,y=null==d?"router-link-exact-active":d,c=null==this.activeClass?l:this.activeClass,m=null==this.exactActiveClass?y:this.exactActiveClass,f=r.redirectedFrom?$o(null,bu(r.redirectedFrom),null,n):r;u[m]=zo(a,f,this.exactPath),u[c]=this.exact||this.exactPath?u[m]:function(e,t){return 0===e.path.replace(Lo,"/").indexOf(t.path.replace(Lo,"/"))&&(!t.hash||e.hash===t.hash)&&function(e,t){for(var n in t)if(!(n in e))return!1;return!0}(e.query,t.query)}(a,f);var b=u[m]?this.ariaCurrentValue:null,h=function(e){wu(e)&&(t.replace?n.replace(s,Tu):n.push(s,Tu))},T={click:wu};Array.isArray(this.event)?this.event.forEach((function(e){T[e]=h})):T[this.event]=h;var v={class:u},w=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:o,route:r,navigate:h,isActive:u[c],isExactActive:u[m]});if(w){if(1===w.length)return w[0];if(w.length>1||!w.length)return 0===w.length?e():e("span",{},w)}if("a"===this.tag)v.on=T,v.attrs={href:o,"aria-current":b};else{var g=gu(this.$slots.default);if(g){g.isStatic=!1;var k=g.data=Co({},g.data);for(var M in k.on=k.on||{},k.on){var I=k.on[M];M in T&&(k.on[M]=Array.isArray(I)?I:[I])}for(var R in T)R in k.on?k.on[R].push(T[R]):k.on[R]=h;var E=g.data.attrs=Co({},g.data.attrs);E.href=o,E["aria-current"]=b}else v.on=T}return e(this.tag,v,this.$slots.default)}};function wu(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey||e.defaultPrevented||void 0!==e.button&&0!==e.button)){if(e.currentTarget&&e.currentTarget.getAttribute){var t=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return e.preventDefault&&e.preventDefault(),!0}}function gu(e){if(e)for(var t,n=0;n<e.length;n++){if("a"===(t=e[n]).tag)return t;if(t.children&&(t=gu(t.children)))return t}}var ku="undefined"!=typeof window;function Mu(e,t,n,a,i){var s=t||[],r=n||Object.create(null),o=a||Object.create(null);e.forEach((function(e){Iu(s,r,o,e,i)}));for(var u=0,p=s.length;u<p;u++)"*"===s[u]&&(s.push(s.splice(u,1)[0]),p--,u--);return{pathList:s,pathMap:r,nameMap:o}}function Iu(e,t,n,a,i,s){var r=a.path,o=a.name,u=a.pathToRegexpOptions||{},p=function(e,t,n){return n||(e=e.replace(/\/$/,"")),"/"===e[0]||null==t?e:Yo(t.path+"/"+e)}(r,i,u.strict);"boolean"==typeof a.caseSensitive&&(u.sensitive=a.caseSensitive);var d={path:p,regex:Ru(p,u),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:o,parent:i,matchAs:s,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};if(a.children&&a.children.forEach((function(a){var i=s?Yo(s+"/"+a.path):void 0;Iu(e,t,n,a,d,i)})),t[d.path]||(e.push(d.path),t[d.path]=d),void 0!==a.alias)for(var l=Array.isArray(a.alias)?a.alias:[a.alias],y=0;y<l.length;++y){var c={path:l[y],children:a.children};Iu(e,t,n,c,i,d.path||"/")}o&&(n[o]||(n[o]=d))}function Ru(e,t){return eu(e,[],t)}function Eu(e,t){var n=Mu(e),a=n.pathList,i=n.pathMap,s=n.nameMap;function r(e,n,r){var u=bu(e,n,!1,t),p=u.name;if(p){var d=s[p];if(!d)return o(null,u);var l=d.regex.keys.filter((function(e){return!e.optional})).map((function(e){return e.name}));if("object"!=typeof u.params&&(u.params={}),n&&"object"==typeof n.params)for(var y in n.params)!(y in u.params)&&l.indexOf(y)>-1&&(u.params[y]=n.params[y]);return u.path=fu(d.path,u.params),o(d,u,r)}if(u.path){u.params={};for(var c=0;c<a.length;c++){var m=a[c],f=i[m];if(xu(f.regex,u.path,u.params))return o(f,u,r)}}return o(null,u)}function o(e,n,a){return e&&e.redirect?function(e,n){var a=e.redirect,i="function"==typeof a?a($o(e,n,null,t)):a;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return o(null,n);var u=i,p=u.name,d=u.path,l=n.query,y=n.hash,c=n.params;if(l=u.hasOwnProperty("query")?u.query:l,y=u.hasOwnProperty("hash")?u.hash:y,c=u.hasOwnProperty("params")?u.params:c,p)return s[p],r({_normalized:!0,name:p,query:l,hash:y,params:c},void 0,n);if(d){var m=function(e,t){return Jo(e,t.parent?t.parent.path:"/",!0)}(d,e);return r({_normalized:!0,path:fu(m,c),query:l,hash:y},void 0,n)}return o(null,n)}(e,a||n):e&&e.matchAs?function(e,t,n){var a=r({_normalized:!0,path:fu(n,t.params)});if(a){var i=a.matched,s=i[i.length-1];return t.params=a.params,o(s,t)}return o(null,t)}(0,n,e.matchAs):$o(e,n,a,t)}return{match:r,addRoute:function(e,t){var n="object"!=typeof e?s[e]:void 0;Mu([t||e],a,i,s,n),n&&n.alias.length&&Mu(n.alias.map((function(e){return{path:e,children:[t]}})),a,i,s,n)},getRoutes:function(){return a.map((function(e){return i[e]}))},addRoutes:function(e){Mu(e,a,i,s)}}}function xu(e,t,n){var a=t.match(e);if(!a)return!1;if(!n)return!0;for(var i=1,s=a.length;i<s;++i){var r=e.keys[i-1];r&&(n[r.name||"pathMatch"]="string"==typeof a[i]?Uo(a[i]):a[i])}return!0}var _u=ku&&window.performance&&window.performance.now?window.performance:Date;function Fu(){return _u.now().toFixed(3)}var Au=Fu();function Cu(){return Au}function Su(e){return Au=e}var Ou=Object.create(null);function Nu(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var e=window.location.protocol+"//"+window.location.host,t=window.location.href.replace(e,""),n=Co({},window.history.state);return n.key=Cu(),window.history.replaceState(n,"",t),window.addEventListener("popstate",Du),function(){window.removeEventListener("popstate",Du)}}function Pu(e,t,n,a){if(e.app){var i=e.options.scrollBehavior;i&&e.app.$nextTick((function(){var s=function(){var e=Cu();if(e)return Ou[e]}(),r=i.call(e,t,n,a?s:null);r&&("function"==typeof r.then?r.then((function(e){Bu(e,s)})).catch((function(e){})):Bu(r,s))}))}}function Uu(){var e=Cu();e&&(Ou[e]={x:window.pageXOffset,y:window.pageYOffset})}function Du(e){Uu(),e.state&&e.state.key&&Su(e.state.key)}function Xu(e){return Lu(e.x)||Lu(e.y)}function Vu(e){return{x:Lu(e.x)?e.x:window.pageXOffset,y:Lu(e.y)?e.y:window.pageYOffset}}function Lu(e){return"number"==typeof e}var $u=/^#\d/;function Bu(e,t){var n,a="object"==typeof e;if(a&&"string"==typeof e.selector){var i=$u.test(e.selector)?document.getElementById(e.selector.slice(1)):document.querySelector(e.selector);if(i){var s=e.offset&&"object"==typeof e.offset?e.offset:{};t=function(e,t){var n=document.documentElement.getBoundingClientRect(),a=e.getBoundingClientRect();return{x:a.left-n.left-t.x,y:a.top-n.top-t.y}}(i,s={x:Lu((n=s).x)?n.x:0,y:Lu(n.y)?n.y:0})}else Xu(e)&&(t=Vu(e))}else a&&Xu(e)&&(t=Vu(e));t&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:t.x,top:t.y,behavior:e.behavior}):window.scrollTo(t.x,t.y))}var Hu,qu=ku&&(-1===(Hu=window.navigator.userAgent).indexOf("Android 2.")&&-1===Hu.indexOf("Android 4.0")||-1===Hu.indexOf("Mobile Safari")||-1!==Hu.indexOf("Chrome")||-1!==Hu.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState;function ju(e,t){Uu();var n=window.history;try{if(t){var a=Co({},n.state);a.key=Cu(),n.replaceState(a,"",e)}else n.pushState({key:Su(Fu())},"",e)}catch(n){window.location[t?"replace":"assign"](e)}}function zu(e){ju(e,!0)}function Gu(e,t,n){var a=function(i){i>=e.length?n():e[i]?t(e[i],(function(){a(i+1)})):a(i+1)};a(0)}var Wu={redirected:2,aborted:4,cancelled:8,duplicated:16};function Zu(e,t){return Ku(e,t,Wu.cancelled,'Navigation cancelled from "'+e.fullPath+'" to "'+t.fullPath+'" with a new navigation.')}function Ku(e,t,n,a){var i=new Error(a);return i._isRouter=!0,i.from=e,i.to=t,i.type=n,i}var Ju=["params","query","hash"];function Yu(e){return Object.prototype.toString.call(e).indexOf("Error")>-1}function Qu(e,t){return Yu(e)&&e._isRouter&&(null==t||e.type===t)}function ep(e,t){return tp(e.map((function(e){return Object.keys(e.components).map((function(n){return t(e.components[n],e.instances[n],e,n)}))})))}function tp(e){return Array.prototype.concat.apply([],e)}var np="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function ap(e){var t=!1;return function(){for(var n=[],a=arguments.length;a--;)n[a]=arguments[a];if(!t)return t=!0,e.apply(this,n)}}var ip=function(e,t){this.router=e,this.base=function(e){if(!e)if(ku){var t=document.querySelector("base");e=(e=t&&t.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else e="/";return"/"!==e.charAt(0)&&(e="/"+e),e.replace(/\/$/,"")}(t),this.current=Ho,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function sp(e,t,n,a){var i=ep(e,(function(e,a,i,s){var r=function(e,t){return"function"!=typeof e&&(e=hu.extend(e)),e.options[t]}(e,t);if(r)return Array.isArray(r)?r.map((function(e){return n(e,a,i,s)})):n(r,a,i,s)}));return tp(a?i.reverse():i)}function rp(e,t){if(t)return function(){return e.apply(t,arguments)}}ip.prototype.listen=function(e){this.cb=e},ip.prototype.onReady=function(e,t){this.ready?e():(this.readyCbs.push(e),t&&this.readyErrorCbs.push(t))},ip.prototype.onError=function(e){this.errorCbs.push(e)},ip.prototype.transitionTo=function(e,t,n){var a,i=this;try{a=this.router.match(e,this.current)}catch(e){throw this.errorCbs.forEach((function(t){t(e)})),e}var s=this.current;this.confirmTransition(a,(function(){i.updateRoute(a),t&&t(a),i.ensureURL(),i.router.afterHooks.forEach((function(e){e&&e(a,s)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(e){e(a)})))}),(function(e){n&&n(e),e&&!i.ready&&(Qu(e,Wu.redirected)&&s===Ho||(i.ready=!0,i.readyErrorCbs.forEach((function(t){t(e)}))))}))},ip.prototype.confirmTransition=function(e,t,n){var a=this,i=this.current;this.pending=e;var s,r,o=function(e){!Qu(e)&&Yu(e)&&(a.errorCbs.length?a.errorCbs.forEach((function(t){t(e)})):console.error(e)),n&&n(e)},u=e.matched.length-1,p=i.matched.length-1;if(zo(e,i)&&u===p&&e.matched[u]===i.matched[p])return this.ensureURL(),e.hash&&Pu(this.router,i,e,!1),o(((r=Ku(s=i,e,Wu.duplicated,'Avoided redundant navigation to current location: "'+s.fullPath+'".')).name="NavigationDuplicated",r));var d,l=function(e,t){var n,a=Math.max(e.length,t.length);for(n=0;n<a&&e[n]===t[n];n++);return{updated:t.slice(0,n),activated:t.slice(n),deactivated:e.slice(n)}}(this.current.matched,e.matched),y=l.updated,c=l.deactivated,m=l.activated,f=[].concat(function(e){return sp(e,"beforeRouteLeave",rp,!0)}(c),this.router.beforeHooks,function(e){return sp(e,"beforeRouteUpdate",rp)}(y),m.map((function(e){return e.beforeEnter})),(d=m,function(e,t,n){var a=!1,i=0,s=null;ep(d,(function(e,t,r,o){if("function"==typeof e&&void 0===e.cid){a=!0,i++;var u,p=ap((function(t){var a;((a=t).__esModule||np&&"Module"===a[Symbol.toStringTag])&&(t=t.default),e.resolved="function"==typeof t?t:hu.extend(t),r.components[o]=t,--i<=0&&n()})),d=ap((function(e){var t="Failed to resolve async component "+o+": "+e;s||(s=Yu(e)?e:new Error(t),n(s))}));try{u=e(p,d)}catch(e){d(e)}if(u)if("function"==typeof u.then)u.then(p,d);else{var l=u.component;l&&"function"==typeof l.then&&l.then(p,d)}}})),a||n()})),b=function(t,n){if(a.pending!==e)return o(Zu(i,e));try{t(e,i,(function(t){!1===t?(a.ensureURL(!0),o(function(e,t){return Ku(e,t,Wu.aborted,'Navigation aborted from "'+e.fullPath+'" to "'+t.fullPath+'" via a navigation guard.')}(i,e))):Yu(t)?(a.ensureURL(!0),o(t)):"string"==typeof t||"object"==typeof t&&("string"==typeof t.path||"string"==typeof t.name)?(o(function(e,t){return Ku(e,t,Wu.redirected,'Redirected when going from "'+e.fullPath+'" to "'+function(e){if("string"==typeof e)return e;if("path"in e)return e.path;var t={};return Ju.forEach((function(n){n in e&&(t[n]=e[n])})),JSON.stringify(t,null,2)}(t)+'" via a navigation guard.')}(i,e)),"object"==typeof t&&t.replace?a.replace(t):a.push(t)):n(t)}))}catch(e){o(e)}};Gu(f,b,(function(){var n=function(e){return sp(e,"beforeRouteEnter",(function(e,t,n,a){return function(e,t,n){return function(a,i,s){return e(a,i,(function(e){"function"==typeof e&&(t.enteredCbs[n]||(t.enteredCbs[n]=[]),t.enteredCbs[n].push(e)),s(e)}))}}(e,n,a)}))}(m);Gu(n.concat(a.router.resolveHooks),b,(function(){if(a.pending!==e)return o(Zu(i,e));a.pending=null,t(e),a.router.app&&a.router.app.$nextTick((function(){Wo(e)}))}))}))},ip.prototype.updateRoute=function(e){this.current=e,this.cb&&this.cb(e)},ip.prototype.setupListeners=function(){},ip.prototype.teardown=function(){this.listeners.forEach((function(e){e()})),this.listeners=[],this.current=Ho,this.pending=null};var op=function(e){function t(t,n){e.call(this,t,n),this._startLocation=up(this.base)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router,n=t.options.scrollBehavior,a=qu&&n;a&&this.listeners.push(Nu());var i=function(){var n=e.current,i=up(e.base);e.current===Ho&&i===e._startLocation||e.transitionTo(i,(function(e){a&&Pu(t,e,n,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},t.prototype.go=function(e){window.history.go(e)},t.prototype.push=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){ju(Yo(a.base+e.fullPath)),Pu(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){zu(Yo(a.base+e.fullPath)),Pu(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.ensureURL=function(e){if(up(this.base)!==this.current.fullPath){var t=Yo(this.base+this.current.fullPath);e?ju(t):zu(t)}},t.prototype.getCurrentLocation=function(){return up(this.base)},t}(ip);function up(e){var t=window.location.pathname,n=t.toLowerCase(),a=e.toLowerCase();return!e||n!==a&&0!==n.indexOf(Yo(a+"/"))||(t=t.slice(e.length)),(t||"/")+window.location.search+window.location.hash}var pp=function(e){function t(t,n,a){e.call(this,t,n),a&&function(e){var t=up(e);if(!/^\/#/.test(t))return window.location.replace(Yo(e+"/#"+t)),!0}(this.base)||dp()}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router.options.scrollBehavior,n=qu&&t;n&&this.listeners.push(Nu());var a=function(){var t=e.current;dp()&&e.transitionTo(lp(),(function(a){n&&Pu(e.router,a,t,!0),qu||mp(a.fullPath)}))},i=qu?"popstate":"hashchange";window.addEventListener(i,a),this.listeners.push((function(){window.removeEventListener(i,a)}))}},t.prototype.push=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){cp(e.fullPath),Pu(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){mp(e.fullPath),Pu(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.go=function(e){window.history.go(e)},t.prototype.ensureURL=function(e){var t=this.current.fullPath;lp()!==t&&(e?cp(t):mp(t))},t.prototype.getCurrentLocation=function(){return lp()},t}(ip);function dp(){var e=lp();return"/"===e.charAt(0)||(mp("/"+e),!1)}function lp(){var e=window.location.href,t=e.indexOf("#");return t<0?"":e=e.slice(t+1)}function yp(e){var t=window.location.href,n=t.indexOf("#");return(n>=0?t.slice(0,n):t)+"#"+e}function cp(e){qu?ju(yp(e)):window.location.hash=e}function mp(e){qu?zu(yp(e)):window.location.replace(yp(e))}var fp=function(e){function t(t,n){e.call(this,t,n),this.stack=[],this.index=-1}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.push=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index+1).concat(e),a.index++,t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index).concat(e),t&&t(e)}),n)},t.prototype.go=function(e){var t=this,n=this.index+e;if(!(n<0||n>=this.stack.length)){var a=this.stack[n];this.confirmTransition(a,(function(){var e=t.current;t.index=n,t.updateRoute(a),t.router.afterHooks.forEach((function(t){t&&t(a,e)}))}),(function(e){Qu(e,Wu.duplicated)&&(t.index=n)}))}},t.prototype.getCurrentLocation=function(){var e=this.stack[this.stack.length-1];return e?e.fullPath:"/"},t.prototype.ensureURL=function(){},t}(ip),bp=function(e){void 0===e&&(e={}),this.app=null,this.apps=[],this.options=e,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Eu(e.routes||[],this);var t=e.mode||"hash";switch(this.fallback="history"===t&&!qu&&!1!==e.fallback,this.fallback&&(t="hash"),ku||(t="abstract"),this.mode=t,t){case"history":this.history=new op(this,e.base);break;case"hash":this.history=new pp(this,e.base,this.fallback);break;case"abstract":this.history=new fp(this,e.base)}},hp={currentRoute:{configurable:!0}};function Tp(e,t){return e.push(t),function(){var n=e.indexOf(t);n>-1&&e.splice(n,1)}}bp.prototype.match=function(e,t,n){return this.matcher.match(e,t,n)},hp.currentRoute.get=function(){return this.history&&this.history.current},bp.prototype.init=function(e){var t=this;if(this.apps.push(e),e.$once("hook:destroyed",(function(){var n=t.apps.indexOf(e);n>-1&&t.apps.splice(n,1),t.app===e&&(t.app=t.apps[0]||null),t.app||t.history.teardown()})),!this.app){this.app=e;var n=this.history;if(n instanceof op||n instanceof pp){var a=function(e){n.setupListeners(),function(e){var a=n.current,i=t.options.scrollBehavior;qu&&i&&"fullPath"in e&&Pu(t,e,a,!1)}(e)};n.transitionTo(n.getCurrentLocation(),a,a)}n.listen((function(e){t.apps.forEach((function(t){t._route=e}))}))}},bp.prototype.beforeEach=function(e){return Tp(this.beforeHooks,e)},bp.prototype.beforeResolve=function(e){return Tp(this.resolveHooks,e)},bp.prototype.afterEach=function(e){return Tp(this.afterHooks,e)},bp.prototype.onReady=function(e,t){this.history.onReady(e,t)},bp.prototype.onError=function(e){this.history.onError(e)},bp.prototype.push=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.push(e,t,n)}));this.history.push(e,t,n)},bp.prototype.replace=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.replace(e,t,n)}));this.history.replace(e,t,n)},bp.prototype.go=function(e){this.history.go(e)},bp.prototype.back=function(){this.go(-1)},bp.prototype.forward=function(){this.go(1)},bp.prototype.getMatchedComponents=function(e){var t=e?e.matched?e:this.resolve(e).route:this.currentRoute;return t?[].concat.apply([],t.matched.map((function(e){return Object.keys(e.components).map((function(t){return e.components[t]}))}))):[]},bp.prototype.resolve=function(e,t,n){var a=bu(e,t=t||this.history.current,n,this),i=this.match(a,t),s=i.redirectedFrom||i.fullPath,r=function(e,t,n){var a="hash"===n?"#"+t:t;return e?Yo(e+"/"+a):a}(this.history.base,s,this.mode);return{location:a,route:i,href:r,normalizedTo:a,resolved:i}},bp.prototype.getRoutes=function(){return this.matcher.getRoutes()},bp.prototype.addRoute=function(e,t){this.matcher.addRoute(e,t),this.history.current!==Ho&&this.history.transitionTo(this.history.getCurrentLocation())},bp.prototype.addRoutes=function(e){this.matcher.addRoutes(e),this.history.current!==Ho&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(bp.prototype,hp),bp.install=function e(t){if(!e.installed||hu!==t){e.installed=!0,hu=t;var n=function(e){return void 0!==e},a=function(e,t){var a=e.$options._parentVnode;n(a)&&n(a=a.data)&&n(a=a.registerRouteInstance)&&a(e,t)};t.mixin({beforeCreate:function(){n(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),t.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(t.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(t.prototype,"$route",{get:function(){return this._routerRoot._route}}),t.component("RouterView",Zo),t.component("RouterLink",vu);var i=t.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},bp.version="3.5.4",bp.isNavigationFailure=Qu,bp.NavigationFailureType=Wu,bp.START_LOCATION=Ho,ku&&window.Vue&&window.Vue.use(bp);const vp=bp;var wp=function(){var e=this._self._c;return e("div",{staticClass:"min-h-screen bg-gray-100 px-4 pt-6"},[e("router-view")],1)};function gp(e,t,n,a,i,s,r,o){var u,p="function"==typeof e?e.options:e;if(t&&(p.render=t,p.staticRenderFns=n,p._compiled=!0),a&&(p.functional=!0),s&&(p._scopeId="data-v-"+s),r?(u=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),i&&i.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(r)},p._ssrRegister=u):i&&(u=o?function(){i.call(this,(p.functional?this.parent:this).$root.$options.shadowRoot)}:i),u)if(p.functional){p._injectStyles=u;var d=p.render;p.render=function(e,t){return u.call(t),d(e,t)}}else{var l=p.beforeCreate;p.beforeCreate=l?[].concat(l,u):[u]}return{exports:e,options:p}}wp._withStripped=!0,n(838);const kp=gp({},wp,[],!1,null,null,null).exports;var Mp=function(){var e=this,t=e._self._c;return t("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[t("HeaderBar"),e._v(" "),t("div",{staticClass:"pb-32"},[t("div",{staticClass:"space-y-4"},[t("span",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.source)+"\n      ")]),e._v(" "),t("h1",{staticClass:"text-xl"},[e._v("\n        "+e._s(e.json.name)+"\n      ")]),e._v(" "),t("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.title)+"\n      ")]),e._v(" "),t("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.author)+"\n      ")]),e._v(" "),t("p",[e._v(e._s(e.json.notice))]),e._v(" "),t("p",[e._v(e._s(e.json.details))])]),e._v(" "),t("div",{staticClass:"mt-8"},[e.json.hasOwnProperty("constructor")?t("Member",{attrs:{json:e.json.constructor}}):e._e()],1),e._v(" "),t("div",{staticClass:"mt-8"},[e.json.receive?t("Member",{attrs:{json:e.json.receive}}):e._e()],1),e._v(" "),t("div",{staticClass:"mt-8"},[e.json.fallback?t("Member",{attrs:{json:e.json.fallback}}):e._e()],1),e._v(" "),e.json.events?t("MemberSet",{attrs:{title:"Events",json:e.json.events}}):e._e(),e._v(" "),e.json.stateVariables?t("MemberSet",{attrs:{title:"State Variables",json:e.json.stateVariables}}):e._e(),e._v(" "),e.json.methods?t("MemberSet",{attrs:{title:"Methods",json:e.json.methods}}):e._e()],1),e._v(" "),t("FooterBar")],1)};Mp._withStripped=!0;var Ip=function(){var e=this,t=e._self._c;return t("div",{staticClass:"bg-gray-100 fixed bottom-0 right-0 w-full border-t border-dashed border-gray-300"},[t("div",{staticClass:"w-full text-center py-2 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[t("button",{staticClass:"py-1 px-2 text-gray-500",on:{click:function(t){return e.openLink(e.repository)}}},[e._v("\n      built with "+e._s(e.name)+"\n    ")])])])};Ip._withStripped=!0;const Rp=JSON.parse('{"u2":"hardhat-docgen","cj":"https://github.com/ItsNickBarry/hardhat-docgen"}'),Ep=gp({data:function(){return{repository:Rp.cj,name:Rp.u2}},methods:{openLink(e){window.open(e,"_blank")}}},Ip,[],!1,null,null,null).exports;var xp=function(){var e=this._self._c;return e("div",{staticClass:"w-full border-b border-dashed py-2 border-gray-300"},[e("router-link",{staticClass:"py-2 text-gray-500",attrs:{to:"/"}},[this._v("\n    <- Go back\n  ")])],1)};xp._withStripped=!0;const _p=gp({},xp,[],!1,null,null,null).exports;var Fp=function(){var e=this,t=e._self._c;return t("div",{staticClass:"border-2 border-gray-400 border-dashed w-full p-2"},[t("h3",{staticClass:"text-lg pb-2 mb-2 border-b-2 border-gray-400 border-dashed"},[e._v("\n    "+e._s(e.name)+" "+e._s(e.keywords)+" "+e._s(e.inputSignature)+"\n  ")]),e._v(" "),t("div",{staticClass:"space-y-3"},[t("p",[e._v(e._s(e.json.notice))]),e._v(" "),t("p",[e._v(e._s(e.json.details))]),e._v(" "),t("MemberSection",{attrs:{name:"Parameters",items:e.inputs}}),e._v(" "),t("MemberSection",{attrs:{name:"Return Values",items:e.outputs}})],1)])};Fp._withStripped=!0;var Ap=function(){var e=this,t=e._self._c;return e.items.length>0?t("ul",[t("h4",{staticClass:"text-lg"},[e._v("\n    "+e._s(e.name)+"\n  ")]),e._v(" "),e._l(e.items,(function(n,a){return t("li",{key:a},[t("span",{staticClass:"bg-gray-300"},[e._v(e._s(n.type))]),e._v(" "),t("b",[e._v(e._s(n.name||`_${a}`))]),n.desc?t("span",[e._v(": "),t("i",[e._v(e._s(n.desc))])]):e._e()])}))],2):e._e()};Ap._withStripped=!0;const Cp={components:{MemberSection:gp({props:{name:{type:String,default:""},items:{type:Array,default:()=>new Array}}},Ap,[],!1,null,null,null).exports},props:{json:{type:Object,default:()=>new Object}},computed:{name:function(){return this.json.name||this.json.type},keywords:function(){let e=[];return this.json.stateMutability&&e.push(this.json.stateMutability),"true"===this.json.anonymous&&e.push("anonymous"),e.join(" ")},params:function(){return this.json.params||{}},returns:function(){return this.json.returns||{}},inputs:function(){return(this.json.inputs||[]).map((e=>({...e,desc:this.params[e.name]})))},inputSignature:function(){return`(${this.inputs.map((e=>e.type)).join(",")})`},outputs:function(){return(this.json.outputs||[]).map(((e,t)=>({...e,desc:this.returns[e.name||`_${t}`]})))},outputSignature:function(){return`(${this.outputs.map((e=>e.type)).join(",")})`}}},Sp=gp(Cp,Fp,[],!1,null,null,null).exports;var Op=function(){var e=this,t=e._self._c;return t("div",{staticClass:"w-full mt-8"},[t("h2",{staticClass:"text-lg"},[e._v(e._s(e.title))]),e._v(" "),e._l(Object.keys(e.json),(function(n){return t("Member",{key:n,staticClass:"mt-3",attrs:{json:e.json[n]}})}))],2)};Op._withStripped=!0;var Np=gp({components:{Member:Sp},props:{title:{type:String,default:""},json:{type:Object,default:()=>new Object}}},Op,[],!1,null,null,null);const Pp=gp({components:{Member:Sp,MemberSet:Np.exports,HeaderBar:_p,FooterBar:Ep},props:{json:{type:Object,default:()=>new Object}}},Mp,[],!1,null,null,null).exports;var Up=function(){var e=this,t=e._self._c;return t("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto pb-32"},[t("Branch",{attrs:{json:e.trees,name:"Sources:"}}),e._v(" "),t("FooterBar",{staticClass:"mt-20"})],1)};Up._withStripped=!0;var Dp=function(){var e=this,t=e._self._c;return t("div",[e._v("\n  "+e._s(e.name)+"\n  "),Array.isArray(e.json)?t("div",{staticClass:"pl-5"},e._l(e.json,(function(n,a){return t("div",{key:a},[t("router-link",{attrs:{to:`${n.source}:${n.name}`}},[e._v("\n        "+e._s(n.name)+"\n      ")])],1)})),0):t("div",{staticClass:"pl-5"},e._l(Object.keys(e.json),(function(n){return t("div",{key:n},[t("Branch",{attrs:{json:e.json[n],name:n}})],1)})),0)])};Dp._withStripped=!0;var Xp=gp({name:"Branch",props:{name:{type:String,default:null},json:{type:[Object,Array],default:()=>new Object}}},Dp,[],!1,null,null,null);const Vp=gp({components:{Branch:Xp.exports,FooterBar:Ep},props:{json:{type:Object,default:()=>new Object}},computed:{trees:function(){let e={};for(let t in this.json)t.replace("/","//").split(/\/(?=[^\/])/).reduce(function(e,n){if(!n.includes(":"))return e[n]=e[n]||{},e[n];{let[a]=n.split(":");e[a]=e[a]||[],e[a].push(this.json[t])}}.bind(this),e);return e}}},Up,[],!1,null,null,null).exports;jn.use(vp);const Lp={"contracts/solidity/NFTXEligibilityManager.sol:NFTXEligibilityManager":{source:"contracts/solidity/NFTXEligibilityManager.sol",name:"NFTXEligibilityManager",events:{"ModuleAdded(address,address,string,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"implementation",type:"address"},{indexed:!1,internalType:"address",name:"targetAsset",type:"address"},{indexed:!1,internalType:"string",name:"name",type:"string"},{indexed:!1,internalType:"bool",name:"finalizedOnDeploy",type:"bool"}],name:"ModuleAdded",type:"event"},"ModuleUpdated(address,string,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"implementation",type:"address"},{indexed:!1,internalType:"string",name:"name",type:"string"},{indexed:!1,internalType:"bool",name:"finalizedOnDeploy",type:"bool"}],name:"ModuleUpdated",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"__NFTXEligibilityManager_init()":{inputs:[],name:"__NFTXEligibilityManager_init",outputs:[],stateMutability:"nonpayable",type:"function"},"addModule(address)":{inputs:[{internalType:"address",name:"implementation",type:"address"}],name:"addModule",outputs:[],stateMutability:"nonpayable",type:"function"},"allModuleNames()":{inputs:[],name:"allModuleNames",outputs:[{internalType:"string[]",name:"",type:"string[]"}],stateMutability:"view",type:"function"},"allModules()":{inputs:[],name:"allModules",outputs:[{components:[{internalType:"address",name:"implementation",type:"address"},{internalType:"address",name:"targetAsset",type:"address"},{internalType:"string",name:"name",type:"string"}],internalType:"struct NFTXEligibilityManager.EligibilityModule[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function"},"deployEligibility(uint256,bytes)":{inputs:[{internalType:"uint256",name:"moduleIndex",type:"uint256"},{internalType:"bytes",name:"configData",type:"bytes"}],name:"deployEligibility",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"},"modules(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"modules",outputs:[{internalType:"address",name:"implementation",type:"address"},{internalType:"address",name:"targetAsset",type:"address"},{internalType:"string",name:"name",type:"string"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"updateModule(uint256,address)":{inputs:[{internalType:"uint256",name:"moduleIndex",type:"uint256"},{internalType:"address",name:"implementation",type:"address"}],name:"updateModule",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/NFTXInventoryStaking.sol:NFTXInventoryStaking":{source:"contracts/solidity/NFTXInventoryStaking.sol",name:"NFTXInventoryStaking",events:{"Deposit(uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"baseTokenAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"xTokenAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"timelockUntil",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Deposit",type:"event"},"FeesReceived(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"FeesReceived",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"SetIsGuardian(address,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"addr",type:"address"},{indexed:!1,internalType:"bool",name:"isGuardian",type:"bool"}],name:"SetIsGuardian",type:"event"},"SetPaused(uint256,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"lockId",type:"uint256"},{indexed:!1,internalType:"bool",name:"paused",type:"bool"}],name:"SetPaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"childImplementation",type:"address"}],name:"Upgraded",type:"event"},"Withdraw(uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"baseTokenAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"xTokenAmount",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"Withdraw",type:"event"},"XTokenCreated(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"address",name:"baseToken",type:"address"},{indexed:!1,internalType:"address",name:"xToken",type:"address"}],name:"XTokenCreated",type:"event"}},methods:{"__NFTXInventoryStaking_init(address)":{inputs:[{internalType:"address",name:"_nftxVaultFactory",type:"address"}],name:"__NFTXInventoryStaking_init",outputs:[],stateMutability:"nonpayable",type:"function"},"__UpgradeableBeacon__init(address)":{inputs:[{internalType:"address",name:"childImplementation_",type:"address"}],name:"__UpgradeableBeacon__init",outputs:[],stateMutability:"nonpayable",type:"function",details:"Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the beacon."},"balanceOf(uint256,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"address",name:"who",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"childImplementation()":{inputs:[],name:"childImplementation",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the current child implementation address."},"deployXTokenForVault(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"deployXTokenForVault",outputs:[],stateMutability:"nonpayable",type:"function"},"deposit(uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function"},"inventoryLockTimeErc20()":{inputs:[],name:"inventoryLockTimeErc20",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"isAddressTimelockExcluded(address,uint256)":{inputs:[{internalType:"address",name:"addr",type:"address"},{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"isAddressTimelockExcluded",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isGuardian(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isGuardian",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isPaused(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"isPaused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"nftxVaultFactory()":{inputs:[],name:"nftxVaultFactory",outputs:[{internalType:"contract INFTXVaultFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"onlyOwnerIfPaused(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"onlyOwnerIfPaused",outputs:[],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"pause(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function"},"receiveRewards(uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"receiveRewards",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setInventoryLockTimeErc20(uint256)":{inputs:[{internalType:"uint256",name:"time",type:"uint256"}],name:"setInventoryLockTimeErc20",outputs:[],stateMutability:"nonpayable",type:"function"},"setIsGuardian(address,bool)":{inputs:[{internalType:"address",name:"addr",type:"address"},{internalType:"bool",name:"_isGuardian",type:"bool"}],name:"setIsGuardian",outputs:[],stateMutability:"nonpayable",type:"function"},"setTimelockExcludeList(address)":{inputs:[{internalType:"address",name:"addr",type:"address"}],name:"setTimelockExcludeList",outputs:[],stateMutability:"nonpayable",type:"function"},"timelockExcludeList()":{inputs:[],name:"timelockExcludeList",outputs:[{internalType:"contract ITimelockExcludeList",name:"",type:"address"}],stateMutability:"view",type:"function"},"timelockMintFor(uint256,uint256,address,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"timelockLength",type:"uint256"}],name:"timelockMintFor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"timelockUntil(uint256,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"address",name:"who",type:"address"}],name:"timelockUntil",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"unpause(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function"},"upgradeChildTo(address)":{inputs:[{internalType:"address",name:"newChildImplementation",type:"address"}],name:"upgradeChildTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrades the beacon to a new implementation. Emits an {Upgraded} event. Requirements: - msg.sender must be the owner of the contract. - `newChildImplementation` must be a contract."},"vaultXToken(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"vaultXToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"withdraw(uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"_share",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"},"xTokenAddr(address)":{inputs:[{internalType:"address",name:"baseToken",type:"address"}],name:"xTokenAddr",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"xTokenShareValue(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"xTokenShareValue",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/solidity/NFTXLPStaking.sol:NFTXLPStaking":{source:"contracts/solidity/NFTXLPStaking.sol",name:"NFTXLPStaking",events:{"FeesReceived(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"FeesReceived",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"PoolCreated(uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"address",name:"pool",type:"address"}],name:"PoolCreated",type:"event"},"PoolUpdated(uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"address",name:"pool",type:"address"}],name:"PoolUpdated",type:"event"},"SetIsGuardian(address,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"addr",type:"address"},{indexed:!1,internalType:"bool",name:"isGuardian",type:"bool"}],name:"SetIsGuardian",type:"event"},"SetPaused(uint256,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"lockId",type:"uint256"},{indexed:!1,internalType:"bool",name:"paused",type:"bool"}],name:"SetPaused",type:"event"}},methods:{"__NFTXLPStaking__init(address)":{inputs:[{internalType:"address",name:"_stakingTokenProvider",type:"address"}],name:"__NFTXLPStaking__init",outputs:[],stateMutability:"nonpayable",type:"function"},"_oldRewardDistributionTokenAddr((address,address))":{inputs:[{components:[{internalType:"address",name:"stakingToken",type:"address"},{internalType:"address",name:"rewardToken",type:"address"}],internalType:"struct NFTXLPStaking.StakingPool",name:"pool",type:"tuple"}],name:"_oldRewardDistributionTokenAddr",outputs:[{internalType:"contract IRewardDistributionToken",name:"",type:"address"}],stateMutability:"view",type:"function"},"_rewardDistributionTokenAddr((address,address))":{inputs:[{components:[{internalType:"address",name:"stakingToken",type:"address"},{internalType:"address",name:"rewardToken",type:"address"}],internalType:"struct NFTXLPStaking.StakingPool",name:"pool",type:"tuple"}],name:"_rewardDistributionTokenAddr",outputs:[{internalType:"contract TimelockRewardDistributionTokenImpl",name:"",type:"address"}],stateMutability:"view",type:"function"},"_unusedRewardDistributionTokenAddr((address,address))":{inputs:[{components:[{internalType:"address",name:"stakingToken",type:"address"},{internalType:"address",name:"rewardToken",type:"address"}],internalType:"struct NFTXLPStaking.StakingPool",name:"pool",type:"tuple"}],name:"_unusedRewardDistributionTokenAddr",outputs:[{internalType:"contract IRewardDistributionToken",name:"",type:"address"}],stateMutability:"view",type:"function"},"addPoolForVault(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"addPoolForVault",outputs:[],stateMutability:"nonpayable",type:"function"},"balanceOf(uint256,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"address",name:"addr",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimMultipleRewards(uint256[])":{inputs:[{internalType:"uint256[]",name:"vaultIds",type:"uint256[]"}],name:"claimMultipleRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"claimRewards(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"claimRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"deposit(uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function"},"emergencyExit(address,address)":{inputs:[{internalType:"address",name:"_stakingToken",type:"address"},{internalType:"address",name:"_rewardToken",type:"address"}],name:"emergencyExit",outputs:[],stateMutability:"nonpayable",type:"function"},"emergencyExitAndClaim(address,address)":{inputs:[{internalType:"address",name:"_stakingToken",type:"address"},{internalType:"address",name:"_rewardToken",type:"address"}],name:"emergencyExitAndClaim",outputs:[],stateMutability:"nonpayable",type:"function"},"emergencyMigrate(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"emergencyMigrate",outputs:[],stateMutability:"nonpayable",type:"function"},"exit(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"exit",outputs:[],stateMutability:"nonpayable",type:"function"},"isGuardian(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isGuardian",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isPaused(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"isPaused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"lockedLPBalance(uint256,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"address",name:"who",type:"address"}],name:"lockedLPBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lockedUntil(uint256,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"address",name:"who",type:"address"}],name:"lockedUntil",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"newRewardDistributionToken(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"newRewardDistributionToken",outputs:[{internalType:"contract TimelockRewardDistributionTokenImpl",name:"",type:"address"}],stateMutability:"view",type:"function"},"newTimelockRewardDistTokenImpl()":{inputs:[],name:"newTimelockRewardDistTokenImpl",outputs:[{internalType:"contract TimelockRewardDistributionTokenImpl",name:"",type:"address"}],stateMutability:"view",type:"function"},"nftxVaultFactory()":{inputs:[],name:"nftxVaultFactory",outputs:[{internalType:"contract INFTXVaultFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"oldBalanceOf(uint256,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"address",name:"addr",type:"address"}],name:"oldBalanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"oldRewardDistributionToken(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"oldRewardDistributionToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"onlyOwnerIfPaused(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"onlyOwnerIfPaused",outputs:[],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"pause(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function"},"receiveRewards(uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"receiveRewards",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"retrieveTokens(uint256,uint256,address,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"}],name:"retrieveTokens",outputs:[],stateMutability:"nonpayable",type:"function"},"rewardDistTokenImpl()":{inputs:[],name:"rewardDistTokenImpl",outputs:[{internalType:"contract IRewardDistributionToken",name:"",type:"address"}],stateMutability:"view",type:"function"},"rewardDistributionToken(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"rewardDistributionToken",outputs:[{internalType:"contract IRewardDistributionToken",name:"",type:"address"}],stateMutability:"view",type:"function"},"rewardDistributionTokenAddr(address,address)":{inputs:[{internalType:"address",name:"stakedToken",type:"address"},{internalType:"address",name:"rewardToken",type:"address"}],name:"rewardDistributionTokenAddr",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"setIsGuardian(address,bool)":{inputs:[{internalType:"address",name:"addr",type:"address"},{internalType:"bool",name:"_isGuardian",type:"bool"}],name:"setIsGuardian",outputs:[],stateMutability:"nonpayable",type:"function"},"setNFTXVaultFactory(address)":{inputs:[{internalType:"address",name:"newFactory",type:"address"}],name:"setNFTXVaultFactory",outputs:[],stateMutability:"nonpayable",type:"function"},"setStakingTokenProvider(address)":{inputs:[{internalType:"address",name:"newProvider",type:"address"}],name:"setStakingTokenProvider",outputs:[],stateMutability:"nonpayable",type:"function"},"stakingTokenProvider()":{inputs:[],name:"stakingTokenProvider",outputs:[{internalType:"contract StakingTokenProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"timelockDepositFor(uint256,address,uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"timelockLength",type:"uint256"}],name:"timelockDepositFor",outputs:[],stateMutability:"nonpayable",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"unpause(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function"},"unusedBalanceOf(uint256,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"address",name:"addr",type:"address"}],name:"unusedBalanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"unusedRewardDistributionToken(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"unusedRewardDistributionToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"updatePoolForVault(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"updatePoolForVault",outputs:[],stateMutability:"nonpayable",type:"function"},"updatePoolForVaults(uint256[])":{inputs:[{internalType:"uint256[]",name:"vaultIds",type:"uint256[]"}],name:"updatePoolForVaults",outputs:[],stateMutability:"nonpayable",type:"function"},"vaultStakingInfo(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"vaultStakingInfo",outputs:[{internalType:"address",name:"stakingToken",type:"address"},{internalType:"address",name:"rewardToken",type:"address"}],stateMutability:"view",type:"function"},"withdraw(uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/NFTXMarketplaceZap.sol:IWETH":{source:"contracts/solidity/NFTXMarketplaceZap.sol",name:"IWETH",methods:{"balanceOf(address)":{inputs:[{internalType:"address",name:"to",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"deposit()":{inputs:[],name:"deposit",outputs:[],stateMutability:"payable",type:"function"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/NFTXMarketplaceZap.sol:NFTXMarketplaceZap":{source:"contracts/solidity/NFTXMarketplaceZap.sol",name:"NFTXMarketplaceZap",constructor:{inputs:[{internalType:"address",name:"_nftxFactory",type:"address"},{internalType:"address",name:"_sushiRouter",type:"address"}],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},events:{"Buy(uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"count",type:"uint256"},{indexed:!1,internalType:"uint256",name:"ethSpent",type:"uint256"},{indexed:!1,internalType:"address",name:"to",type:"address"}],name:"Buy",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Sell(uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"count",type:"uint256"},{indexed:!1,internalType:"uint256",name:"ethReceived",type:"uint256"},{indexed:!1,internalType:"address",name:"to",type:"address"}],name:"Sell",type:"event"},"Swap(uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"count",type:"uint256"},{indexed:!1,internalType:"uint256",name:"ethSpent",type:"uint256"},{indexed:!1,internalType:"address",name:"to",type:"address"}],name:"Swap",type:"event"}},methods:{"WETH()":{inputs:[],name:"WETH",outputs:[{internalType:"contract IWETH",name:"",type:"address"}],stateMutability:"view",type:"function"},"buyAndRedeem(uint256,uint256,uint256[],address[],address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256[]",name:"specificIds",type:"uint256[]"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"}],name:"buyAndRedeem",outputs:[],stateMutability:"payable",type:"function"},"buyAndRedeemWETH(uint256,uint256,uint256[],uint256,address[],address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256[]",name:"specificIds",type:"uint256[]"},{internalType:"uint256",name:"maxWethIn",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"}],name:"buyAndRedeemWETH",outputs:[],stateMutability:"nonpayable",type:"function"},"buyAndSwap1155(uint256,uint256[],uint256[],uint256[],address[],address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"idsIn",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256[]",name:"specificIds",type:"uint256[]"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"}],name:"buyAndSwap1155",outputs:[],stateMutability:"payable",type:"function"},"buyAndSwap1155WETH(uint256,uint256[],uint256[],uint256[],uint256,address[],address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"idsIn",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256[]",name:"specificIds",type:"uint256[]"},{internalType:"uint256",name:"maxWethIn",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"}],name:"buyAndSwap1155WETH",outputs:[],stateMutability:"payable",type:"function"},"buyAndSwap721(uint256,uint256[],uint256[],address[],address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"idsIn",type:"uint256[]"},{internalType:"uint256[]",name:"specificIds",type:"uint256[]"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"}],name:"buyAndSwap721",outputs:[],stateMutability:"payable",type:"function"},"buyAndSwap721WETH(uint256,uint256[],uint256[],uint256,address[],address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"idsIn",type:"uint256[]"},{internalType:"uint256[]",name:"specificIds",type:"uint256[]"},{internalType:"uint256",name:"maxWethIn",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"}],name:"buyAndSwap721WETH",outputs:[],stateMutability:"nonpayable",type:"function"},"lpStaking()":{inputs:[],name:"lpStaking",outputs:[{internalType:"contract INFTXLPStaking",name:"",type:"address"}],stateMutability:"view",type:"function"},"mintAndSell1155(uint256,uint256[],uint256[],uint256,address[],address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"minWethOut",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"}],name:"mintAndSell1155",outputs:[],stateMutability:"nonpayable",type:"function"},"mintAndSell1155WETH(uint256,uint256[],uint256[],uint256,address[],address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"minWethOut",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"}],name:"mintAndSell1155WETH",outputs:[],stateMutability:"nonpayable",type:"function"},"mintAndSell721(uint256,uint256[],uint256,address[],address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256",name:"minEthOut",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"}],name:"mintAndSell721",outputs:[],stateMutability:"nonpayable",type:"function"},"mintAndSell721WETH(uint256,uint256[],uint256,address[],address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256",name:"minWethOut",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"}],name:"mintAndSell721WETH",outputs:[],stateMutability:"nonpayable",type:"function"},"nftxFactory()":{inputs:[],name:"nftxFactory",outputs:[{internalType:"contract INFTXVaultFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256[]",name:"",type:"uint256[]"},{internalType:"uint256[]",name:"",type:"uint256[]"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC1155BatchReceived",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function"},"onERC1155Received(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC1155Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function"},"onERC721Received(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC721Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"See {IERC721Receiver-onERC721Received}. Always returns `IERC721Receiver.onERC721Received.selector`."},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"rescue(address)":{inputs:[{internalType:"address",name:"token",type:"address"}],name:"rescue",outputs:[],stateMutability:"nonpayable",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"sushiRouter()":{inputs:[],name:"sushiRouter",outputs:[{internalType:"contract IUniswapV2Router01",name:"",type:"address"}],stateMutability:"view",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/solidity/NFTXMarketplaceZap.sol:Ownable":{source:"contracts/solidity/NFTXMarketplaceZap.sol",name:"Ownable",details:"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. By default, the owner account will be the one that deploys the contract. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.",events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/solidity/NFTXMarketplaceZap.sol:ReentrancyGuard":{source:"contracts/solidity/NFTXMarketplaceZap.sol",name:"ReentrancyGuard",details:"Contract module that helps prevent reentrant calls to a function. Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier available, which can be applied to functions to make sure there are no nested (reentrant) calls to them. Note that because there is a single `nonReentrant` guard, functions marked as `nonReentrant` may not call one another. This can be worked around by making those functions `private`, and then adding `external` `nonReentrant` entry points to them. TIP: If you would like to learn more about reentrancy and alternative ways to protect against it, check out our blog post https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]."},"contracts/solidity/NFTXSimpleFeeDistributor.sol:NFTXSimpleFeeDistributor":{source:"contracts/solidity/NFTXSimpleFeeDistributor.sol",name:"NFTXSimpleFeeDistributor",events:{"AddFeeReceiver(address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"receiver",type:"address"},{indexed:!1,internalType:"uint256",name:"allocPoint",type:"uint256"}],name:"AddFeeReceiver",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"PauseDistribution(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"paused",type:"bool"}],name:"PauseDistribution",type:"event"},"RemoveFeeReceiver(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"receiver",type:"address"}],name:"RemoveFeeReceiver",type:"event"},"SetIsGuardian(address,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"addr",type:"address"},{indexed:!1,internalType:"bool",name:"isGuardian",type:"bool"}],name:"SetIsGuardian",type:"event"},"SetPaused(uint256,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"lockId",type:"uint256"},{indexed:!1,internalType:"bool",name:"paused",type:"bool"}],name:"SetPaused",type:"event"},"UpdateFeeReceiverAddress(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldReceiver",type:"address"},{indexed:!1,internalType:"address",name:"newReceiver",type:"address"}],name:"UpdateFeeReceiverAddress",type:"event"},"UpdateFeeReceiverAlloc(address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"receiver",type:"address"},{indexed:!1,internalType:"uint256",name:"allocPoint",type:"uint256"}],name:"UpdateFeeReceiverAlloc",type:"event"},"UpdateInventoryStakingAddress(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"newInventoryStaking",type:"address"}],name:"UpdateInventoryStakingAddress",type:"event"},"UpdateLPStakingAddress(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"newLPStaking",type:"address"}],name:"UpdateLPStakingAddress",type:"event"},"UpdateNFTXVaultFactory(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"factory",type:"address"}],name:"UpdateNFTXVaultFactory",type:"event"},"UpdateTreasuryAddress(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"newTreasury",type:"address"}],name:"UpdateTreasuryAddress",type:"event"}},methods:{"__SimpleFeeDistributor__init__(address,address)":{inputs:[{internalType:"address",name:"_lpStaking",type:"address"},{internalType:"address",name:"_treasury",type:"address"}],name:"__SimpleFeeDistributor__init__",outputs:[],stateMutability:"nonpayable",type:"function"},"addReceiver(uint256,address,bool)":{inputs:[{internalType:"uint256",name:"_allocPoint",type:"uint256"},{internalType:"address",name:"_receiver",type:"address"},{internalType:"bool",name:"_isContract",type:"bool"}],name:"addReceiver",outputs:[],stateMutability:"nonpayable",type:"function"},"allocTotal()":{inputs:[],name:"allocTotal",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"changeReceiverAddress(uint256,address,bool)":{inputs:[{internalType:"uint256",name:"_receiverIdx",type:"uint256"},{internalType:"address",name:"_address",type:"address"},{internalType:"bool",name:"_isContract",type:"bool"}],name:"changeReceiverAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"changeReceiverAlloc(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_receiverIdx",type:"uint256"},{internalType:"uint256",name:"_allocPoint",type:"uint256"}],name:"changeReceiverAlloc",outputs:[],stateMutability:"nonpayable",type:"function"},"distribute(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function"},"distributionPaused()":{inputs:[],name:"distributionPaused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"feeReceivers(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"feeReceivers",outputs:[{internalType:"uint256",name:"allocPoint",type:"uint256"},{internalType:"address",name:"receiver",type:"address"},{internalType:"bool",name:"isContract",type:"bool"}],stateMutability:"view",type:"function"},"initializeVaultReceivers(uint256)":{inputs:[{internalType:"uint256",name:"_vaultId",type:"uint256"}],name:"initializeVaultReceivers",outputs:[],stateMutability:"nonpayable",type:"function"},"inventoryStaking()":{inputs:[],name:"inventoryStaking",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"isGuardian(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isGuardian",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isPaused(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"isPaused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"lpStaking()":{inputs:[],name:"lpStaking",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"nftxVaultFactory()":{inputs:[],name:"nftxVaultFactory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"onlyOwnerIfPaused(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"onlyOwnerIfPaused",outputs:[],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"pause(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function"},"pauseFeeDistribution(bool)":{inputs:[{internalType:"bool",name:"_pause",type:"bool"}],name:"pauseFeeDistribution",outputs:[],stateMutability:"nonpayable",type:"function"},"removeReceiver(uint256)":{inputs:[{internalType:"uint256",name:"_receiverIdx",type:"uint256"}],name:"removeReceiver",outputs:[],stateMutability:"nonpayable",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"rescueTokens(address)":{inputs:[{internalType:"address",name:"_address",type:"address"}],name:"rescueTokens",outputs:[],stateMutability:"nonpayable",type:"function"},"setInventoryStakingAddress(address)":{inputs:[{internalType:"address",name:"_inventoryStaking",type:"address"}],name:"setInventoryStakingAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"setIsGuardian(address,bool)":{inputs:[{internalType:"address",name:"addr",type:"address"},{internalType:"bool",name:"_isGuardian",type:"bool"}],name:"setIsGuardian",outputs:[],stateMutability:"nonpayable",type:"function"},"setLPStakingAddress(address)":{inputs:[{internalType:"address",name:"_lpStaking",type:"address"}],name:"setLPStakingAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"setNFTXVaultFactory(address)":{inputs:[{internalType:"address",name:"_factory",type:"address"}],name:"setNFTXVaultFactory",outputs:[],stateMutability:"nonpayable",type:"function"},"setTreasuryAddress(address)":{inputs:[{internalType:"address",name:"_treasury",type:"address"}],name:"setTreasuryAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"unpause(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/NFTXStakingZap.sol:IWETH":{source:"contracts/solidity/NFTXStakingZap.sol",name:"IWETH",methods:{"deposit()":{inputs:[],name:"deposit",outputs:[],stateMutability:"payable",type:"function"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/NFTXStakingZap.sol:NFTXStakingZap":{source:"contracts/solidity/NFTXStakingZap.sol",name:"NFTXStakingZap",constructor:{inputs:[{internalType:"address",name:"_nftxFactory",type:"address"},{internalType:"address",name:"_sushiRouter",type:"address"}],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"UserStaked(uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"count",type:"uint256"},{indexed:!1,internalType:"uint256",name:"lpBalance",type:"uint256"},{indexed:!1,internalType:"uint256",name:"timelockUntil",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"UserStaked",type:"event"}},methods:{"WETH()":{inputs:[],name:"WETH",outputs:[{internalType:"contract IWETH",name:"",type:"address"}],stateMutability:"view",type:"function"},"addLiquidity1155(uint256,uint256[],uint256[],uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"minWethIn",type:"uint256"},{internalType:"uint256",name:"wethIn",type:"uint256"}],name:"addLiquidity1155",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"addLiquidity1155ETH(uint256,uint256[],uint256[],uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"minEthIn",type:"uint256"}],name:"addLiquidity1155ETH",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"payable",type:"function"},"addLiquidity1155ETHTo(uint256,uint256[],uint256[],uint256,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"minEthIn",type:"uint256"},{internalType:"address",name:"to",type:"address"}],name:"addLiquidity1155ETHTo",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"payable",type:"function"},"addLiquidity1155To(uint256,uint256[],uint256[],uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"minWethIn",type:"uint256"},{internalType:"uint256",name:"wethIn",type:"uint256"},{internalType:"address",name:"to",type:"address"}],name:"addLiquidity1155To",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"addLiquidity721(uint256,uint256[],uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256",name:"minWethIn",type:"uint256"},{internalType:"uint256",name:"wethIn",type:"uint256"}],name:"addLiquidity721",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"addLiquidity721ETH(uint256,uint256[],uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256",name:"minWethIn",type:"uint256"}],name:"addLiquidity721ETH",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"payable",type:"function"},"addLiquidity721ETHTo(uint256,uint256[],uint256,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256",name:"minWethIn",type:"uint256"},{internalType:"address",name:"to",type:"address"}],name:"addLiquidity721ETHTo",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"payable",type:"function"},"addLiquidity721To(uint256,uint256[],uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256",name:"minWethIn",type:"uint256"},{internalType:"uint256",name:"wethIn",type:"uint256"},{internalType:"address",name:"to",type:"address"}],name:"addLiquidity721To",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"assignStakingContracts()":{inputs:[],name:"assignStakingContracts",outputs:[],stateMutability:"nonpayable",type:"function"},"inventoryLockTime()":{inputs:[],name:"inventoryLockTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"inventoryStaking()":{inputs:[],name:"inventoryStaking",outputs:[{internalType:"contract INFTXInventoryStaking",name:"",type:"address"}],stateMutability:"view",type:"function"},"isAddressTimelockExcluded(address,uint256)":{inputs:[{internalType:"address",name:"addr",type:"address"},{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"isAddressTimelockExcluded",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"lpLockTime()":{inputs:[],name:"lpLockTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lpStaking()":{inputs:[],name:"lpStaking",outputs:[{internalType:"contract INFTXLPStaking",name:"",type:"address"}],stateMutability:"view",type:"function"},"nftxFactory()":{inputs:[],name:"nftxFactory",outputs:[{internalType:"contract INFTXVaultFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256[]",name:"",type:"uint256[]"},{internalType:"uint256[]",name:"",type:"uint256[]"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC1155BatchReceived",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function"},"onERC1155Received(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC1155Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function"},"onERC721Received(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC721Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"See {IERC721Receiver-onERC721Received}. Always returns `IERC721Receiver.onERC721Received.selector`."},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"provideInventory1155(uint256,uint256[],uint256[])":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],name:"provideInventory1155",outputs:[],stateMutability:"nonpayable",type:"function"},"provideInventory721(uint256,uint256[])":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"provideInventory721",outputs:[],stateMutability:"nonpayable",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"rescue(address)":{inputs:[{internalType:"address",name:"token",type:"address"}],name:"rescue",outputs:[],stateMutability:"nonpayable",type:"function"},"setInventoryLockTime(uint256)":{inputs:[{internalType:"uint256",name:"newInventoryLockTime",type:"uint256"}],name:"setInventoryLockTime",outputs:[],stateMutability:"nonpayable",type:"function"},"setLPLockTime(uint256)":{inputs:[{internalType:"uint256",name:"newLPLockTime",type:"uint256"}],name:"setLPLockTime",outputs:[],stateMutability:"nonpayable",type:"function"},"setTimelockExcludeList(address)":{inputs:[{internalType:"address",name:"addr",type:"address"}],name:"setTimelockExcludeList",outputs:[],stateMutability:"nonpayable",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"sushiRouter()":{inputs:[],name:"sushiRouter",outputs:[{internalType:"contract IUniswapV2Router01",name:"",type:"address"}],stateMutability:"view",type:"function"},"timelockExcludeList()":{inputs:[],name:"timelockExcludeList",outputs:[{internalType:"contract ITimelockExcludeList",name:"",type:"address"}],stateMutability:"view",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/solidity/NFTXStakingZap.sol:Ownable":{source:"contracts/solidity/NFTXStakingZap.sol",name:"Ownable",details:"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. By default, the owner account will be the one that deploys the contract. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.",events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/solidity/NFTXStakingZap.sol:ReentrancyGuard":{source:"contracts/solidity/NFTXStakingZap.sol",name:"ReentrancyGuard",details:"Contract module that helps prevent reentrant calls to a function. Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier available, which can be applied to functions to make sure there are no nested (reentrant) calls to them. Note that because there is a single `nonReentrant` guard, functions marked as `nonReentrant` may not call one another. This can be worked around by making those functions `private`, and then adding `external` `nonReentrant` entry points to them. TIP: If you would like to learn more about reentrancy and alternative ways to protect against it, check out our blog post https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]."},"contracts/solidity/NFTXUnstakingInventoryZap.sol:NFTXUnstakingInventoryZap":{source:"contracts/solidity/NFTXUnstakingInventoryZap.sol",name:"NFTXUnstakingInventoryZap",receive:{stateMutability:"payable",type:"receive"},events:{"InventoryUnstaked(uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"xTokensUnstaked",type:"uint256"},{indexed:!1,internalType:"uint256",name:"numNftsRedeemed",type:"uint256"},{indexed:!1,internalType:"address",name:"unstaker",type:"address"}],name:"InventoryUnstaked",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"inventoryStaking()":{inputs:[],name:"inventoryStaking",outputs:[{internalType:"contract NFTXInventoryStaking",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxNftsUsingXToken(uint256,address,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"address",name:"staker",type:"address"},{internalType:"address",name:"slpToken",type:"address"}],name:"maxNftsUsingXToken",outputs:[{internalType:"uint256",name:"numNfts",type:"uint256"},{internalType:"bool",name:"shortByTinyAmount",type:"bool"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"rescue(address)":{inputs:[{internalType:"address",name:"token",type:"address"}],name:"rescue",outputs:[],stateMutability:"nonpayable",type:"function"},"setInventoryStaking(address)":{inputs:[{internalType:"address",name:"addr",type:"address"}],name:"setInventoryStaking",outputs:[],stateMutability:"nonpayable",type:"function"},"setSushiRouterAndWeth(address)":{inputs:[{internalType:"address",name:"sushiRouterAddr",type:"address"}],name:"setSushiRouterAndWeth",outputs:[],stateMutability:"nonpayable",type:"function"},"setVaultFactory(address)":{inputs:[{internalType:"address",name:"addr",type:"address"}],name:"setVaultFactory",outputs:[],stateMutability:"nonpayable",type:"function"},"sushiRouter()":{inputs:[],name:"sushiRouter",outputs:[{internalType:"contract IUniswapV2Router01",name:"",type:"address"}],stateMutability:"view",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"unstakeInventory(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"numNfts",type:"uint256"},{internalType:"uint256",name:"remainingPortionToUnstake",type:"uint256"}],name:"unstakeInventory",outputs:[],stateMutability:"payable",type:"function"},"vaultFactory()":{inputs:[],name:"vaultFactory",outputs:[{internalType:"contract INFTXVaultFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"weth()":{inputs:[],name:"weth",outputs:[{internalType:"contract IWETH",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/solidity/NFTXV1Buyout.sol:IV1Token":{source:"contracts/solidity/NFTXV1Buyout.sol",name:"IV1Token",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"burnFrom(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burnFrom",outputs:[],stateMutability:"nonpayable",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}}},"contracts/solidity/NFTXV1Buyout.sol:NFTXV1Buyout":{source:"contracts/solidity/NFTXV1Buyout.sol",name:"NFTXV1Buyout",events:{"BuyoutComplete(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"tokenAddress",type:"address"}],name:"BuyoutComplete",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"SetIsGuardian(address,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"addr",type:"address"},{indexed:!1,internalType:"bool",name:"isGuardian",type:"bool"}],name:"SetIsGuardian",type:"event"},"SetPaused(uint256,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"lockId",type:"uint256"},{indexed:!1,internalType:"bool",name:"paused",type:"bool"}],name:"SetPaused",type:"event"},"TokenBuyout(address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"tokenAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"totalEth",type:"uint256"}],name:"TokenBuyout",type:"event"}},methods:{"__NFTXV1Buyout_init()":{inputs:[],name:"__NFTXV1Buyout_init",outputs:[],stateMutability:"nonpayable",type:"function"},"addBuyout(address)":{inputs:[{internalType:"address",name:"v1TokenAddr",type:"address"}],name:"addBuyout",outputs:[],stateMutability:"payable",type:"function"},"claimETH(address)":{inputs:[{internalType:"address",name:"v1TokenAddr",type:"address"}],name:"claimETH",outputs:[],stateMutability:"nonpayable",type:"function"},"clearBuyout(address)":{inputs:[{internalType:"address",name:"v1TokenAddr",type:"address"}],name:"clearBuyout",outputs:[],stateMutability:"nonpayable",type:"function"},"emergencyWithdraw()":{inputs:[],name:"emergencyWithdraw",outputs:[],stateMutability:"nonpayable",type:"function"},"ethAvailiable(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"ethAvailiable",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"isGuardian(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isGuardian",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isPaused(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"isPaused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"onlyOwnerIfPaused(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"onlyOwnerIfPaused",outputs:[],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"pause(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function"},"removeBuyout(address)":{inputs:[{internalType:"address",name:"v1TokenAddr",type:"address"}],name:"removeBuyout",outputs:[],stateMutability:"nonpayable",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setIsGuardian(address,bool)":{inputs:[{internalType:"address",name:"addr",type:"address"},{internalType:"bool",name:"_isGuardian",type:"bool"}],name:"setIsGuardian",outputs:[],stateMutability:"nonpayable",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"unpause(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/NFTXVaultFactoryUpgradeable.sol:NFTXVaultFactoryUpgradeable":{source:"contracts/solidity/NFTXVaultFactoryUpgradeable.sol",name:"NFTXVaultFactoryUpgradeable",events:{"DisableVaultFees(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"vaultId",type:"uint256"}],name:"DisableVaultFees",type:"event"},"FeeExclusion(address,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"feeExcluded",type:"address"},{indexed:!1,internalType:"bool",name:"excluded",type:"bool"}],name:"FeeExclusion",type:"event"},"NewEligibilityManager(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldEligManager",type:"address"},{indexed:!1,internalType:"address",name:"newEligManager",type:"address"}],name:"NewEligibilityManager",type:"event"},"NewFeeDistributor(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldDistributor",type:"address"},{indexed:!1,internalType:"address",name:"newDistributor",type:"address"}],name:"NewFeeDistributor",type:"event"},"NewVault(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"address",name:"vaultAddress",type:"address"},{indexed:!1,internalType:"address",name:"assetAddress",type:"address"}],name:"NewVault",type:"event"},"NewZapContract(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldZap",type:"address"},{indexed:!1,internalType:"address",name:"newZap",type:"address"}],name:"NewZapContract",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"SetIsGuardian(address,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"addr",type:"address"},{indexed:!1,internalType:"bool",name:"isGuardian",type:"bool"}],name:"SetIsGuardian",type:"event"},"SetPaused(uint256,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"lockId",type:"uint256"},{indexed:!1,internalType:"bool",name:"paused",type:"bool"}],name:"SetPaused",type:"event"},"UpdateFactoryFees(uint256,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"mintFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"randomRedeemFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"targetRedeemFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"randomSwapFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"targetSwapFee",type:"uint256"}],name:"UpdateFactoryFees",type:"event"},"UpdateVaultFees(uint256,uint256,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"mintFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"randomRedeemFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"targetRedeemFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"randomSwapFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"targetSwapFee",type:"uint256"}],name:"UpdateVaultFees",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"childImplementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"__NFTXVaultFactory_init(address,address)":{inputs:[{internalType:"address",name:"_vaultImpl",type:"address"},{internalType:"address",name:"_feeDistributor",type:"address"}],name:"__NFTXVaultFactory_init",outputs:[],stateMutability:"nonpayable",type:"function"},"__UpgradeableBeacon__init(address)":{inputs:[{internalType:"address",name:"childImplementation_",type:"address"}],name:"__UpgradeableBeacon__init",outputs:[],stateMutability:"nonpayable",type:"function",details:"Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the beacon."},"allVaults()":{inputs:[],name:"allVaults",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"childImplementation()":{inputs:[],name:"childImplementation",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the current child implementation address."},"createVault(string,string,address,bool,bool)":{inputs:[{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"symbol",type:"string"},{internalType:"address",name:"_assetAddress",type:"address"},{internalType:"bool",name:"is1155",type:"bool"},{internalType:"bool",name:"allowAllItems",type:"bool"}],name:"createVault",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"disableVaultFees(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"disableVaultFees",outputs:[],stateMutability:"nonpayable",type:"function"},"eligibilityManager()":{inputs:[],name:"eligibilityManager",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"excludedFromFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"excludedFromFees",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"factoryMintFee()":{inputs:[],name:"factoryMintFee",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function"},"factoryRandomRedeemFee()":{inputs:[],name:"factoryRandomRedeemFee",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function"},"factoryRandomSwapFee()":{inputs:[],name:"factoryRandomSwapFee",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function"},"factoryTargetRedeemFee()":{inputs:[],name:"factoryTargetRedeemFee",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function"},"factoryTargetSwapFee()":{inputs:[],name:"factoryTargetSwapFee",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function"},"feeDistributor()":{inputs:[],name:"feeDistributor",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"isGuardian(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isGuardian",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isLocked(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"isLocked",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isPaused(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"isPaused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"numVaults()":{inputs:[],name:"numVaults",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"onlyOwnerIfPaused(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"onlyOwnerIfPaused",outputs:[],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"pause(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setEligibilityManager(address)":{inputs:[{internalType:"address",name:"_eligibilityManager",type:"address"}],name:"setEligibilityManager",outputs:[],stateMutability:"nonpayable",type:"function"},"setFactoryFees(uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"mintFee",type:"uint256"},{internalType:"uint256",name:"randomRedeemFee",type:"uint256"},{internalType:"uint256",name:"targetRedeemFee",type:"uint256"},{internalType:"uint256",name:"randomSwapFee",type:"uint256"},{internalType:"uint256",name:"targetSwapFee",type:"uint256"}],name:"setFactoryFees",outputs:[],stateMutability:"nonpayable",type:"function"},"setFeeDistributor(address)":{inputs:[{internalType:"address",name:"_feeDistributor",type:"address"}],name:"setFeeDistributor",outputs:[],stateMutability:"nonpayable",type:"function"},"setFeeExclusion(address,bool)":{inputs:[{internalType:"address",name:"_excludedAddr",type:"address"},{internalType:"bool",name:"excluded",type:"bool"}],name:"setFeeExclusion",outputs:[],stateMutability:"nonpayable",type:"function"},"setIsGuardian(address,bool)":{inputs:[{internalType:"address",name:"addr",type:"address"},{internalType:"bool",name:"_isGuardian",type:"bool"}],name:"setIsGuardian",outputs:[],stateMutability:"nonpayable",type:"function"},"setVaultFees(uint256,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"mintFee",type:"uint256"},{internalType:"uint256",name:"randomRedeemFee",type:"uint256"},{internalType:"uint256",name:"targetRedeemFee",type:"uint256"},{internalType:"uint256",name:"randomSwapFee",type:"uint256"},{internalType:"uint256",name:"targetSwapFee",type:"uint256"}],name:"setVaultFees",outputs:[],stateMutability:"nonpayable",type:"function"},"setZapContract(address)":{inputs:[{internalType:"address",name:"_zapContract",type:"address"}],name:"setZapContract",outputs:[],stateMutability:"nonpayable",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"unpause(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function"},"upgradeChildTo(address)":{inputs:[{internalType:"address",name:"newChildImplementation",type:"address"}],name:"upgradeChildTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrades the beacon to a new implementation. Emits an {Upgraded} event. Requirements: - msg.sender must be the owner of the contract. - `newChildImplementation` must be a contract."},"vault(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"vault",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"vaultFees(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"vaultFees",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"vaultsForAsset(address)":{inputs:[{internalType:"address",name:"assetAddress",type:"address"}],name:"vaultsForAsset",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"zapContract()":{inputs:[],name:"zapContract",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/solidity/NFTXVaultUpgradeable.sol:NFTXVaultUpgradeable":{source:"contracts/solidity/NFTXVaultUpgradeable.sol",name:"NFTXVaultUpgradeable",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"EligibilityDeployed(uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"moduleIndex",type:"uint256"},{indexed:!1,internalType:"address",name:"eligibilityAddr",type:"address"}],name:"EligibilityDeployed",type:"event"},"EnableMintUpdated(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"enabled",type:"bool"}],name:"EnableMintUpdated",type:"event"},"EnableRandomRedeemUpdated(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"enabled",type:"bool"}],name:"EnableRandomRedeemUpdated",type:"event"},"EnableRandomSwapUpdated(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"enabled",type:"bool"}],name:"EnableRandomSwapUpdated",type:"event"},"EnableTargetRedeemUpdated(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"enabled",type:"bool"}],name:"EnableTargetRedeemUpdated",type:"event"},"EnableTargetSwapUpdated(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"enabled",type:"bool"}],name:"EnableTargetSwapUpdated",type:"event"},"ManagerSet(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"manager",type:"address"}],name:"ManagerSet",type:"event"},"MetaDataChange(string,string,string,string)":{anonymous:!1,inputs:[{indexed:!1,internalType:"string",name:"oldName",type:"string"},{indexed:!1,internalType:"string",name:"oldSymbol",type:"string"},{indexed:!1,internalType:"string",name:"newName",type:"string"},{indexed:!1,internalType:"string",name:"newSymbol",type:"string"}],name:"MetaDataChange",type:"event"},"Minted(uint256[],uint256[],address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256[]",name:"nftIds",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"amounts",type:"uint256[]"},{indexed:!1,internalType:"address",name:"to",type:"address"}],name:"Minted",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Redeemed(uint256[],uint256[],address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256[]",name:"nftIds",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"specificIds",type:"uint256[]"},{indexed:!1,internalType:"address",name:"to",type:"address"}],name:"Redeemed",type:"event"},"Swapped(uint256[],uint256[],uint256[],uint256[],address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256[]",name:"nftIds",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"amounts",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"specificIds",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"redeemedIds",type:"uint256[]"},{indexed:!1,internalType:"address",name:"to",type:"address"}],name:"Swapped",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"},"VaultInit(uint256,address,bool,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"address",name:"assetAddress",type:"address"},{indexed:!1,internalType:"bool",name:"is1155",type:"bool"},{indexed:!1,internalType:"bool",name:"allowAllItems",type:"bool"}],name:"VaultInit",type:"event"},"VaultShutdown(address,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"assetAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"numItems",type:"uint256"},{indexed:!1,internalType:"address",name:"recipient",type:"address"}],name:"VaultShutdown",type:"event"}},methods:{"__NFTXVault_init(string,string,address,bool,bool)":{inputs:[{internalType:"string",name:"_name",type:"string"},{internalType:"string",name:"_symbol",type:"string"},{internalType:"address",name:"_assetAddress",type:"address"},{internalType:"bool",name:"_is1155",type:"bool"},{internalType:"bool",name:"_allowAllItems",type:"bool"}],name:"__NFTXVault_init",outputs:[],stateMutability:"nonpayable",type:"function"},"allHoldings()":{inputs:[],name:"allHoldings",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function"},"allValidNFTs(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"allValidNFTs",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"allowAllItems()":{inputs:[],name:"allowAllItems",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"assetAddress()":{inputs:[],name:"assetAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless this function is overridden; NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"deployEligibilityStorage(uint256,bytes)":{inputs:[{internalType:"uint256",name:"moduleIndex",type:"uint256"},{internalType:"bytes",name:"initData",type:"bytes"}],name:"deployEligibilityStorage",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"},"disableVaultFees()":{inputs:[],name:"disableVaultFees",outputs:[],stateMutability:"nonpayable",type:"function"},"eligibilityStorage()":{inputs:[],name:"eligibilityStorage",outputs:[{internalType:"contract INFTXEligibility",name:"",type:"address"}],stateMutability:"view",type:"function"},"enableMint()":{inputs:[],name:"enableMint",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"enableRandomRedeem()":{inputs:[],name:"enableRandomRedeem",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"enableRandomSwap()":{inputs:[],name:"enableRandomSwap",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"enableTargetRedeem()":{inputs:[],name:"enableTargetRedeem",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"enableTargetSwap()":{inputs:[],name:"enableTargetSwap",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"finalizeVault()":{inputs:[],name:"finalizeVault",outputs:[],stateMutability:"nonpayable",type:"function"},"flashFee(address,uint256)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"flashFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the fee applied when doing flash loans. By default this implementation has 0 fees. This function can be overloaded to make the flash loan mechanism deflationary.",params:{amount:"The amount of tokens to be loaned.",token:"The token to be flash loaned."},returns:{_0:"The fees applied to the corresponding flash loan."}},"flashLoan(address,address,uint256,bytes)":{inputs:[{internalType:"contract IERC3156FlashBorrowerUpgradeable",name:"receiver",type:"address"},{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"flashLoan",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Performs a flash loan. New tokens are minted and sent to the `receiver`, who is required to implement the {IERC3156FlashBorrower} interface. By the end of the flash loan, the receiver is expected to own amount + fee tokens and have them approved back to the token contract itself so they can be burned.",params:{amount:"The amount of tokens to be loaned.",data:"An arbitrary datafield that is passed to the receiver.",receiver:"The receiver of the flash loan. Should implement the {IERC3156FlashBorrower.onFlashLoan} interface.",token:"The token to be flash loaned. Only `address(this)` is supported."},returns:{_0:"`true` is the flash loan was successfull."}},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"is1155()":{inputs:[],name:"is1155",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"manager()":{inputs:[],name:"manager",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxFlashLoan(address)":{inputs:[{internalType:"address",name:"token",type:"address"}],name:"maxFlashLoan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the maximum amount of tokens available for loan.",params:{token:"The address of the token that is requested."},returns:{_0:"The amont of token that can be loaned."}},"mint(uint256[],uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],name:"mint",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"mintFee()":{inputs:[],name:"mintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mintTo(uint256[],uint256[],address)":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"address",name:"to",type:"address"}],name:"mintTo",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"nftIdAt(uint256)":{inputs:[{internalType:"uint256",name:"holdingsIndex",type:"uint256"}],name:"nftIdAt",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256[]",name:"",type:"uint256[]"},{internalType:"uint256[]",name:"",type:"uint256[]"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC1155BatchReceived",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function"},"onERC1155Received(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC1155Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function"},"onERC721Received(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC721Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"See {IERC721Receiver-onERC721Received}. Always returns `IERC721Receiver.onERC721Received.selector`."},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"randomRedeemFee()":{inputs:[],name:"randomRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"randomSwapFee()":{inputs:[],name:"randomSwapFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeem(uint256,uint256[])":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256[]",name:"specificIds",type:"uint256[]"}],name:"redeem",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"redeemTo(uint256,uint256[],address)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256[]",name:"specificIds",type:"uint256[]"},{internalType:"address",name:"to",type:"address"}],name:"redeemTo",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"retrieveTokens(uint256,address,address)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"}],name:"retrieveTokens",outputs:[],stateMutability:"nonpayable",type:"function"},"setFees(uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_mintFee",type:"uint256"},{internalType:"uint256",name:"_randomRedeemFee",type:"uint256"},{internalType:"uint256",name:"_targetRedeemFee",type:"uint256"},{internalType:"uint256",name:"_randomSwapFee",type:"uint256"},{internalType:"uint256",name:"_targetSwapFee",type:"uint256"}],name:"setFees",outputs:[],stateMutability:"nonpayable",type:"function"},"setManager(address)":{inputs:[{internalType:"address",name:"_manager",type:"address"}],name:"setManager",outputs:[],stateMutability:"nonpayable",type:"function"},"setVaultFeatures(bool,bool,bool,bool,bool)":{inputs:[{internalType:"bool",name:"_enableMint",type:"bool"},{internalType:"bool",name:"_enableRandomRedeem",type:"bool"},{internalType:"bool",name:"_enableTargetRedeem",type:"bool"},{internalType:"bool",name:"_enableRandomSwap",type:"bool"},{internalType:"bool",name:"_enableTargetSwap",type:"bool"}],name:"setVaultFeatures",outputs:[],stateMutability:"nonpayable",type:"function"},"setVaultMetadata(string,string)":{inputs:[{internalType:"string",name:"name_",type:"string"},{internalType:"string",name:"symbol_",type:"string"}],name:"setVaultMetadata",outputs:[],stateMutability:"nonpayable",type:"function"},"shutdown(address)":{inputs:[{internalType:"address",name:"recipient",type:"address"}],name:"shutdown",outputs:[],stateMutability:"nonpayable",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"swap(uint256[],uint256[],uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256[]",name:"specificIds",type:"uint256[]"}],name:"swap",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"swapTo(uint256[],uint256[],uint256[],address)":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256[]",name:"specificIds",type:"uint256[]"},{internalType:"address",name:"to",type:"address"}],name:"swapTo",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"targetRedeemFee()":{inputs:[],name:"targetRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"targetSwapFee()":{inputs:[],name:"targetSwapFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalHoldings()":{inputs:[],name:"totalHoldings",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"vaultFactory()":{inputs:[],name:"vaultFactory",outputs:[{internalType:"contract INFTXVaultFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"vaultFees()":{inputs:[],name:"vaultFees",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"vaultId()":{inputs:[],name:"vaultId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"version()":{inputs:[],name:"version",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"}}},"contracts/solidity/StakingTokenProvider.sol:StakingTokenProvider":{source:"contracts/solidity/StakingTokenProvider.sol",name:"StakingTokenProvider",events:{"NewDefaultPaired(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldPaired",type:"address"},{indexed:!1,internalType:"address",name:"newPaired",type:"address"}],name:"NewDefaultPaired",type:"event"},"NewPairedTokenForVault(address,address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"vaultToken",type:"address"},{indexed:!1,internalType:"address",name:"oldPairedtoken",type:"address"},{indexed:!1,internalType:"address",name:"newPairedToken",type:"address"}],name:"NewPairedTokenForVault",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"__StakingTokenProvider_init(address,address,string)":{inputs:[{internalType:"address",name:"_uniLikeExchange",type:"address"},{internalType:"address",name:"_defaultPairedtoken",type:"address"},{internalType:"string",name:"_defaultPrefix",type:"string"}],name:"__StakingTokenProvider_init",outputs:[],stateMutability:"nonpayable",type:"function"},"defaultPairedToken()":{inputs:[],name:"defaultPairedToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"defaultPrefix()":{inputs:[],name:"defaultPrefix",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"nameForStakingToken(address)":{inputs:[{internalType:"address",name:"_vaultToken",type:"address"}],name:"nameForStakingToken",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"pairForVaultToken(address,address)":{inputs:[{internalType:"address",name:"_vaultToken",type:"address"},{internalType:"address",name:"_pairedToken",type:"address"}],name:"pairForVaultToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pairedPrefix(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"pairedPrefix",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"pairedToken(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"pairedToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setDefaultPairedToken(address,string)":{inputs:[{internalType:"address",name:"_newDefaultPaired",type:"address"},{internalType:"string",name:"_newDefaultPrefix",type:"string"}],name:"setDefaultPairedToken",outputs:[],stateMutability:"nonpayable",type:"function"},"setPairedTokenForVaultToken(address,address,string)":{inputs:[{internalType:"address",name:"_vaultToken",type:"address"},{internalType:"address",name:"_newPairedToken",type:"address"},{internalType:"string",name:"_newPrefix",type:"string"}],name:"setPairedTokenForVaultToken",outputs:[],stateMutability:"nonpayable",type:"function"},"stakingTokenForVaultToken(address)":{inputs:[{internalType:"address",name:"_vaultToken",type:"address"}],name:"stakingTokenForVaultToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"uniLikeExchange()":{inputs:[],name:"uniLikeExchange",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/solidity/eligibility/NFTXAvastarRank60Eligibility.sol:Avastar":{source:"contracts/solidity/eligibility/NFTXAvastarRank60Eligibility.sol",name:"Avastar",methods:{"getPrimeByTokenId(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"getPrimeByTokenId",outputs:[{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint256",name:"serial",type:"uint256"},{internalType:"uint256",name:"traits",type:"uint256"},{internalType:"enum Avastar.Generation",name:"generation",type:"uint8"},{internalType:"enum Avastar.Series",name:"series",type:"uint8"},{internalType:"enum Avastar.Gender",name:"gender",type:"uint8"},{internalType:"uint8",name:"ranking",type:"uint8"}],stateMutability:"view",type:"function"}}},"contracts/solidity/eligibility/NFTXAvastarRank60Eligibility.sol:NFTXAvastarRank60Eligibility":{source:"contracts/solidity/eligibility/NFTXAvastarRank60Eligibility.sol",name:"NFTXAvastarRank60Eligibility",events:{"NFTXEligibilityInit()":{anonymous:!1,inputs:[],name:"NFTXEligibilityInit",type:"event"}},methods:{"__NFTXEligibility_init()":{inputs:[],name:"__NFTXEligibility_init",outputs:[],stateMutability:"nonpayable",type:"function"},"__NFTXEligibility_init_bytes(bytes)":{inputs:[{internalType:"bytes",name:"",type:"bytes"}],name:"__NFTXEligibility_init_bytes",outputs:[],stateMutability:"nonpayable",type:"function"},"afterMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"afterRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"checkAllEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkAllIneligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllIneligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkEligible",outputs:[{internalType:"bool[]",name:"",type:"bool[]"}],stateMutability:"view",type:"function"},"checkIsEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"checkIsEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"finalized()":{inputs:[],name:"finalized",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"targetAsset()":{inputs:[],name:"targetAsset",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"}}},"contracts/solidity/eligibility/NFTXDeferEligibility.sol:NFTXDeferEligibility":{source:"contracts/solidity/eligibility/NFTXDeferEligibility.sol",name:"NFTXDeferEligibility",events:{"NFTXEligibilityInit(address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"deferAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"deferralVaultId",type:"uint256"}],name:"NFTXEligibilityInit",type:"event"}},methods:{"__NFTXEligibility_init(address,uint256)":{inputs:[{internalType:"address",name:"_deferAddress",type:"address"},{internalType:"uint256",name:"_deferVaultId",type:"uint256"}],name:"__NFTXEligibility_init",outputs:[],stateMutability:"nonpayable",type:"function"},"__NFTXEligibility_init_bytes(bytes)":{inputs:[{internalType:"bytes",name:"configData",type:"bytes"}],name:"__NFTXEligibility_init_bytes",outputs:[],stateMutability:"nonpayable",type:"function"},"afterMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"afterRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"checkAllEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkAllIneligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllIneligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkEligible",outputs:[{internalType:"bool[]",name:"",type:"bool[]"}],stateMutability:"view",type:"function"},"checkIsEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"checkIsEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"deferAddress()":{inputs:[],name:"deferAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"deferVaultId()":{inputs:[],name:"deferVaultId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"finalized()":{inputs:[],name:"finalized",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"targetAsset()":{inputs:[],name:"targetAsset",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"}}},"contracts/solidity/eligibility/NFTXDenyEligibility.sol:NFTXDenyEligibility":{source:"contracts/solidity/eligibility/NFTXDenyEligibility.sol",name:"NFTXDenyEligibility",events:{"NFTXEligibilityInit(address,address,bool,bool,uint256[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"address",name:"vault",type:"address"},{indexed:!1,internalType:"bool",name:"negateElig",type:"bool"},{indexed:!1,internalType:"bool",name:"finalize",type:"bool"},{indexed:!1,internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"NFTXEligibilityInit",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"UniqueEligibilitiesSet(uint256[],bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{indexed:!1,internalType:"bool",name:"isEligible",type:"bool"}],name:"UniqueEligibilitiesSet",type:"event"},"negateEligilityOnRedeemSet(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"negateElig",type:"bool"}],name:"negateEligilityOnRedeemSet",type:"event"}},methods:{"__NFTXEligibility_init(address,address,bool,bool,uint256[])":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"address",name:"_vault",type:"address"},{internalType:"bool",name:"negateElig",type:"bool"},{internalType:"bool",name:"finalize",type:"bool"},{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"__NFTXEligibility_init",outputs:[],stateMutability:"nonpayable",type:"function"},"__NFTXEligibility_init_bytes(bytes)":{inputs:[{internalType:"bytes",name:"_configData",type:"bytes"}],name:"__NFTXEligibility_init_bytes",outputs:[],stateMutability:"nonpayable",type:"function"},"afterMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"afterRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"checkAllEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkAllIneligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllIneligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkEligible",outputs:[{internalType:"bool[]",name:"",type:"bool[]"}],stateMutability:"view",type:"function"},"checkIsEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"checkIsEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"finalized()":{inputs:[],name:"finalized",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isInitialized()":{inputs:[],name:"isInitialized",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isUniqueEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"isUniqueEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"negateEligOnRedeem()":{inputs:[],name:"negateEligOnRedeem",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setEligibilityPreferences(bool)":{inputs:[{internalType:"bool",name:"_negateEligOnRedeem",type:"bool"}],name:"setEligibilityPreferences",outputs:[],stateMutability:"nonpayable",type:"function"},"setUniqueEligibilities(uint256[],bool)":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"bool",name:"_isEligible",type:"bool"}],name:"setUniqueEligibilities",outputs:[],stateMutability:"nonpayable",type:"function"},"targetAsset()":{inputs:[],name:"targetAsset",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/solidity/eligibility/NFTXEligibility.sol:NFTXEligibility":{source:"contracts/solidity/eligibility/NFTXEligibility.sol",name:"NFTXEligibility",methods:{"__NFTXEligibility_init_bytes(bytes)":{inputs:[{internalType:"bytes",name:"initData",type:"bytes"}],name:"__NFTXEligibility_init_bytes",outputs:[],stateMutability:"nonpayable",type:"function"},"afterMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"afterRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"checkAllEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkAllIneligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllIneligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkEligible",outputs:[{internalType:"bool[]",name:"",type:"bool[]"}],stateMutability:"view",type:"function"},"checkIsEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"checkIsEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"finalized()":{inputs:[],name:"finalized",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"targetAsset()":{inputs:[],name:"targetAsset",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"}}},"contracts/solidity/eligibility/NFTXGen0Eligibility.sol:KittyCore":{source:"contracts/solidity/eligibility/NFTXGen0Eligibility.sol",name:"KittyCore",methods:{"getKitty(uint256)":{inputs:[{internalType:"uint256",name:"_id",type:"uint256"}],name:"getKitty",outputs:[{internalType:"bool",name:"",type:"bool"},{internalType:"bool",name:"",type:"bool"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"_generation",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"owner",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/solidity/eligibility/NFTXGen0Eligibility.sol:NFTXGen0KittyEligibility":{source:"contracts/solidity/eligibility/NFTXGen0Eligibility.sol",name:"NFTXGen0KittyEligibility",events:{"NFTXEligibilityInit()":{anonymous:!1,inputs:[],name:"NFTXEligibilityInit",type:"event"}},methods:{"__NFTXEligibility_init()":{inputs:[],name:"__NFTXEligibility_init",outputs:[],stateMutability:"nonpayable",type:"function"},"__NFTXEligibility_init_bytes(bytes)":{inputs:[{internalType:"bytes",name:"",type:"bytes"}],name:"__NFTXEligibility_init_bytes",outputs:[],stateMutability:"nonpayable",type:"function"},"afterMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"afterRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"checkAllEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkAllIneligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllIneligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkEligible",outputs:[{internalType:"bool[]",name:"",type:"bool[]"}],stateMutability:"view",type:"function"},"checkIsEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"checkIsEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"finalized()":{inputs:[],name:"finalized",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"targetAsset()":{inputs:[],name:"targetAsset",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"}}},"contracts/solidity/eligibility/NFTXGen0FastEligibility.sol:KittyCore":{source:"contracts/solidity/eligibility/NFTXGen0FastEligibility.sol",name:"KittyCore",methods:{"getKitty(uint256)":{inputs:[{internalType:"uint256",name:"_id",type:"uint256"}],name:"getKitty",outputs:[{internalType:"bool",name:"",type:"bool"},{internalType:"bool",name:"",type:"bool"},{internalType:"uint256",name:"_cooldownIndex",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"_generation",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"owner",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/solidity/eligibility/NFTXGen0FastEligibility.sol:NFTXGen0FastKittyEligibility":{source:"contracts/solidity/eligibility/NFTXGen0FastEligibility.sol",name:"NFTXGen0FastKittyEligibility",events:{"NFTXEligibilityInit()":{anonymous:!1,inputs:[],name:"NFTXEligibilityInit",type:"event"}},methods:{"__NFTXEligibility_init()":{inputs:[],name:"__NFTXEligibility_init",outputs:[],stateMutability:"nonpayable",type:"function"},"__NFTXEligibility_init_bytes(bytes)":{inputs:[{internalType:"bytes",name:"",type:"bytes"}],name:"__NFTXEligibility_init_bytes",outputs:[],stateMutability:"nonpayable",type:"function"},"afterMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"afterRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"checkAllEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkAllIneligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllIneligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkEligible",outputs:[{internalType:"bool[]",name:"",type:"bool[]"}],stateMutability:"view",type:"function"},"checkIsEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"checkIsEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"finalized()":{inputs:[],name:"finalized",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"targetAsset()":{inputs:[],name:"targetAsset",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"}}},"contracts/solidity/eligibility/NFTXListEligibility.sol:NFTXListEligibility":{source:"contracts/solidity/eligibility/NFTXListEligibility.sol",name:"NFTXListEligibility",events:{"NFTXEligibilityInit(uint256[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"NFTXEligibilityInit",type:"event"},"UniqueEligibilitiesSet(uint256[],bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{indexed:!1,internalType:"bool",name:"isEligible",type:"bool"}],name:"UniqueEligibilitiesSet",type:"event"}},methods:{"__NFTXEligibility_init(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"__NFTXEligibility_init",outputs:[],stateMutability:"nonpayable",type:"function"},"__NFTXEligibility_init_bytes(bytes)":{inputs:[{internalType:"bytes",name:"_configData",type:"bytes"}],name:"__NFTXEligibility_init_bytes",outputs:[],stateMutability:"nonpayable",type:"function"},"afterMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"afterRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"checkAllEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkAllIneligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllIneligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkEligible",outputs:[{internalType:"bool[]",name:"",type:"bool[]"}],stateMutability:"view",type:"function"},"checkIsEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"checkIsEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"finalized()":{inputs:[],name:"finalized",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isUniqueEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"isUniqueEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"targetAsset()":{inputs:[],name:"targetAsset",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"}}},"contracts/solidity/eligibility/NFTXMerkleEligibility.sol:MerkleProof":{source:"contracts/solidity/eligibility/NFTXMerkleEligibility.sol",name:"MerkleProof",details:"These functions deal with verification of Merkle Tree proofs. The proofs can be generated using the JavaScript library https://github.com/miguelmota/merkletreejs[merkletreejs]. Note: the hashing algorithm should be keccak256 and pair sorting should be enabled. See `test/utils/cryptography/MerkleProof.test.js` for some examples. WARNING: You should avoid using leaf values that are 64 bytes long prior to hashing, or use a hash function other than keccak256 for hashing leaves. This is because the concatenation of a sorted pair of internal nodes in the merkle tree could be reinterpreted as a leaf value."},"contracts/solidity/eligibility/NFTXMerkleEligibility.sol:NFTXMerkleEligibility":{source:"contracts/solidity/eligibility/NFTXMerkleEligibility.sol",name:"NFTXMerkleEligibility",title:"NFTX Merkle Eligibility",author:"Twade ",notice:"Allows vaults to be allow eligibility based on a predefined merkle tree.",events:{"NFTXEligibilityInit(bytes32)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bytes32",name:"merkleRoot",type:"bytes32"}],name:"NFTXEligibilityInit",type:"event",notice:"Emitted when our NFTX Eligibility is deployed"},"PrecursoryCheckComplete(uint256,bytes32,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"tokenId",type:"uint256"},{indexed:!1,internalType:"bytes32",name:"requestId",type:"bytes32"},{indexed:!1,internalType:"bool",name:"isValid",type:"bool"}],name:"PrecursoryCheckComplete",type:"event",notice:"Emitted when a project validity check has been completed"},"PrecursoryCheckStarted(uint256,bytes32)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"tokenId",type:"uint256"},{indexed:!1,internalType:"bytes32",name:"requestId",type:"bytes32"}],name:"PrecursoryCheckStarted",type:"event",notice:"Emitted when a project validity check is started"}},methods:{"__NFTXEligibility_init(bytes32)":{inputs:[{internalType:"bytes32",name:"_merkleRoot",type:"bytes32"}],name:"__NFTXEligibility_init",outputs:[],stateMutability:"nonpayable",type:"function",params:{_merkleRoot:"The root of our merkle tree"},notice:"Parameters here should mirror the config struct. "},"__NFTXEligibility_init_bytes(bytes)":{inputs:[{internalType:"bytes",name:"configData",type:"bytes"}],name:"__NFTXEligibility_init_bytes",outputs:[],stateMutability:"nonpayable",type:"function",params:{configData:"Encoded config data"},notice:"Allow our eligibility module to be initialised with optional config data. "},"afterMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"afterRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"checkAllEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkAllIneligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllIneligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkEligible",outputs:[{internalType:"bool[]",name:"",type:"bool[]"}],stateMutability:"view",type:"function"},"checkIsEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"checkIsEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"finalized()":{inputs:[],name:"finalized",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"bool"},notice:"Confirms that our module has been finalised and won't change."},"merkleRoot()":{inputs:[],name:"merkleRoot",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"Merkle proof to validate all eligible domains against"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function",returns:{_0:"string"},notice:"The name of our Eligibility Module."},"processToken(uint256,bytes32[])":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes32[]",name:"merkleProof",type:"bytes32[]"}],name:"processToken",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",params:{merkleProof:"Merkle proof to validate against the tokenId",tokenId:"The ENS token ID being validated"},returns:{_0:"bool If the token is valid"},notice:"This will run a precursory check by encoding the token ID, creating the token hash, and then checking this against our merkle tree."},"requiresProcessing(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"requiresProcessing",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"If this returns `true`, `processToken` should subsequently be run before checking the eligibility of the token. ",params:{tokenId:"The ENS domain token ID"},returns:{_0:"bool If the tokenId requires precursory validation"},notice:"Checks if the token requires a precursory validation before it can have it's eligibility determined. "},"targetAsset()":{inputs:[],name:"targetAsset",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function",returns:{_0:"address "},notice:"The address of our token asset contract."},"validTokenHashes(bytes32)":{inputs:[{internalType:"bytes32",name:"",type:"bytes32"}],name:"validTokenHashes",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Set our asset contract address"}}},"contracts/solidity/eligibility/NFTXMerkleEligibility.sol:Strings":{source:"contracts/solidity/eligibility/NFTXMerkleEligibility.sol",name:"Strings"},"contracts/solidity/eligibility/NFTXMintRequestEligibility.sol:NFTXMintRequestEligibility":{source:"contracts/solidity/eligibility/NFTXMintRequestEligibility.sol",name:"NFTXMintRequestEligibility",events:{"AllowTrustedApprovalsSet(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"allow",type:"bool"}],name:"AllowTrustedApprovalsSet",type:"event"},"Approve(uint256[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256[]",name:"nftIds",type:"uint256[]"}],name:"Approve",type:"event"},"NFTXEligibilityInit(address,uint256[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"NFTXEligibilityInit",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Request(address,uint256[],uint256[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"sender",type:"address"},{indexed:!1,internalType:"uint256[]",name:"nftIds",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"amounts",type:"uint256[]"}],name:"Request",type:"event"},"SetIsGuardian(address,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"addr",type:"address"},{indexed:!1,internalType:"bool",name:"isGuardian",type:"bool"}],name:"SetIsGuardian",type:"event"},"SetPaused(uint256,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"lockId",type:"uint256"},{indexed:!1,internalType:"bool",name:"paused",type:"bool"}],name:"SetPaused",type:"event"},"UniqueEligibilitiesSet(uint256[],bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{indexed:!1,internalType:"bool",name:"isEligible",type:"bool"}],name:"UniqueEligibilitiesSet",type:"event"}},methods:{"__NFTXEligibility_init(address,address,bool,uint256[])":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"address",name:"vaultAddress",type:"address"},{internalType:"bool",name:"_negateEligOnRedeem",type:"bool"},{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"__NFTXEligibility_init",outputs:[],stateMutability:"nonpayable",type:"function"},"__NFTXEligibility_init_bytes(bytes)":{inputs:[{internalType:"bytes",name:"_configData",type:"bytes"}],name:"__NFTXEligibility_init_bytes",outputs:[],stateMutability:"nonpayable",type:"function"},"afterMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"afterRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"allowTrustedApprovals()":{inputs:[],name:"allowTrustedApprovals",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"approveMintRequests(uint256[],address[],bool)":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"address[]",name:"addresses",type:"address[]"},{internalType:"bool",name:"mint",type:"bool"}],name:"approveMintRequests",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"checkAllEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkAllIneligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllIneligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkEligible",outputs:[{internalType:"bool[]",name:"",type:"bool[]"}],stateMutability:"view",type:"function"},"checkIsEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"checkIsEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"claimUnminted(uint256[],address[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"address[]",name:"addresses",type:"address[]"}],name:"claimUnminted",outputs:[],stateMutability:"nonpayable",type:"function"},"finalizeEligibility()":{inputs:[],name:"finalizeEligibility",outputs:[],stateMutability:"nonpayable",type:"function"},"finalized()":{inputs:[],name:"finalized",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"is1155()":{inputs:[],name:"is1155",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isGuardian(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isGuardian",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isInitialized()":{inputs:[],name:"isInitialized",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isPaused(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"isPaused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isUniqueEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"isUniqueEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"negateEligOnRedeem()":{inputs:[],name:"negateEligOnRedeem",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256[]",name:"",type:"uint256[]"},{internalType:"uint256[]",name:"",type:"uint256[]"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC1155BatchReceived",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function"},"onERC1155Received(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC1155Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function"},"onERC721Received(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC721Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"See {IERC721Receiver-onERC721Received}. Always returns `IERC721Receiver.onERC721Received.selector`."},"onlyOwnerIfPaused(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"onlyOwnerIfPaused",outputs:[],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"pause(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function"},"reclaimRequestedMint(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"reclaimRequestedMint",outputs:[],stateMutability:"nonpayable",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"requestMint(uint256[],uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],name:"requestMint",outputs:[],stateMutability:"nonpayable",type:"function"},"setEligibilityPreferences(bool)":{inputs:[{internalType:"bool",name:"_allowTrustedApprovals",type:"bool"}],name:"setEligibilityPreferences",outputs:[],stateMutability:"nonpayable",type:"function"},"setIsGuardian(address,bool)":{inputs:[{internalType:"address",name:"addr",type:"address"},{internalType:"bool",name:"_isGuardian",type:"bool"}],name:"setIsGuardian",outputs:[],stateMutability:"nonpayable",type:"function"},"setUniqueEligibilities(uint256[],bool)":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"bool",name:"_isEligible",type:"bool"}],name:"setUniqueEligibilities",outputs:[],stateMutability:"nonpayable",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"targetAsset()":{inputs:[],name:"targetAsset",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"unpause(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function"},"vault()":{inputs:[],name:"vault",outputs:[{internalType:"contract INFTXVault",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/solidity/eligibility/NFTXOpenseaEligibility.sol:NFTXOpenseaEligibility":{source:"contracts/solidity/eligibility/NFTXOpenseaEligibility.sol",name:"NFTXOpenseaEligibility",events:{"NFTXEligibilityInit(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"collectionId",type:"uint256"}],name:"NFTXEligibilityInit",type:"event"}},methods:{"__NFTXEligibility_init(uint256)":{inputs:[{internalType:"uint256",name:"_collectionId",type:"uint256"}],name:"__NFTXEligibility_init",outputs:[],stateMutability:"nonpayable",type:"function"},"__NFTXEligibility_init_bytes(bytes)":{inputs:[{internalType:"bytes",name:"configData",type:"bytes"}],name:"__NFTXEligibility_init_bytes",outputs:[],stateMutability:"nonpayable",type:"function"},"afterMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"afterRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"checkAllEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkAllIneligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllIneligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkEligible",outputs:[{internalType:"bool[]",name:"",type:"bool[]"}],stateMutability:"view",type:"function"},"checkIsEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"checkIsEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"collectionId()":{inputs:[],name:"collectionId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"finalized()":{inputs:[],name:"finalized",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"targetAsset()":{inputs:[],name:"targetAsset",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"}}},"contracts/solidity/eligibility/NFTXRangeEligibility.sol:NFTXRangeEligibility":{source:"contracts/solidity/eligibility/NFTXRangeEligibility.sol",name:"NFTXRangeEligibility",events:{"NFTXEligibilityInit(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"rangeStart",type:"uint256"},{indexed:!1,internalType:"uint256",name:"rangeEnd",type:"uint256"}],name:"NFTXEligibilityInit",type:"event"},"RangeSet(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"rangeStart",type:"uint256"},{indexed:!1,internalType:"uint256",name:"rangeEnd",type:"uint256"}],name:"RangeSet",type:"event"}},methods:{"__NFTXEligibility_init(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_rangeStart",type:"uint256"},{internalType:"uint256",name:"_rangeEnd",type:"uint256"}],name:"__NFTXEligibility_init",outputs:[],stateMutability:"nonpayable",type:"function"},"__NFTXEligibility_init_bytes(bytes)":{inputs:[{internalType:"bytes",name:"_configData",type:"bytes"}],name:"__NFTXEligibility_init_bytes",outputs:[],stateMutability:"nonpayable",type:"function"},"afterMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"afterRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"checkAllEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkAllIneligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllIneligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkEligible",outputs:[{internalType:"bool[]",name:"",type:"bool[]"}],stateMutability:"view",type:"function"},"checkIsEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"checkIsEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"finalized()":{inputs:[],name:"finalized",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"rangeEnd()":{inputs:[],name:"rangeEnd",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rangeStart()":{inputs:[],name:"rangeStart",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"targetAsset()":{inputs:[],name:"targetAsset",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"}}},"contracts/solidity/eligibility/NFTXRangeExtendedEligibility.sol:NFTXRangeExtendedEligibility":{source:"contracts/solidity/eligibility/NFTXRangeExtendedEligibility.sol",name:"NFTXRangeExtendedEligibility",events:{"NFTXEligibilityInit(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"uint256",name:"rangeStart",type:"uint256"},{indexed:!1,internalType:"uint256",name:"rangeEnd",type:"uint256"}],name:"NFTXEligibilityInit",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"RangeSet(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"rangeStart",type:"uint256"},{indexed:!1,internalType:"uint256",name:"rangeEnd",type:"uint256"}],name:"RangeSet",type:"event"},"UniqueEligibilitiesSet(uint256[],bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{indexed:!1,internalType:"bool",name:"isEligible",type:"bool"}],name:"UniqueEligibilitiesSet",type:"event"}},methods:{"__NFTXEligibility_init(address,uint256,uint256)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"uint256",name:"_rangeStart",type:"uint256"},{internalType:"uint256",name:"_rangeEnd",type:"uint256"}],name:"__NFTXEligibility_init",outputs:[],stateMutability:"nonpayable",type:"function"},"__NFTXEligibility_init_bytes(bytes)":{inputs:[{internalType:"bytes",name:"_configData",type:"bytes"}],name:"__NFTXEligibility_init_bytes",outputs:[],stateMutability:"nonpayable",type:"function"},"afterMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"afterRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"checkAllEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkAllIneligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllIneligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkEligible",outputs:[{internalType:"bool[]",name:"",type:"bool[]"}],stateMutability:"view",type:"function"},"checkIsEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"checkIsEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"finalized()":{inputs:[],name:"finalized",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isInitialized()":{inputs:[],name:"isInitialized",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isUniqueEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"isUniqueEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"rangeEnd()":{inputs:[],name:"rangeEnd",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rangeStart()":{inputs:[],name:"rangeStart",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setEligibilityPreferences(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_rangeStart",type:"uint256"},{internalType:"uint256",name:"_rangeEnd",type:"uint256"}],name:"setEligibilityPreferences",outputs:[],stateMutability:"nonpayable",type:"function"},"setUniqueEligibilities(uint256[],bool)":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"bool",name:"_isEligible",type:"bool"}],name:"setUniqueEligibilities",outputs:[],stateMutability:"nonpayable",type:"function"},"targetAsset()":{inputs:[],name:"targetAsset",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/solidity/eligibility/NFTXUglyEligibility.sol:IPolymorph":{source:"contracts/solidity/eligibility/NFTXUglyEligibility.sol",name:"IPolymorph",methods:{"geneOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"geneOf",outputs:[{internalType:"uint256",name:"gene",type:"uint256"}],stateMutability:"view",type:"function"},"lastTokenId()":{inputs:[],name:"lastTokenId",outputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/solidity/eligibility/NFTXUglyEligibility.sol:NFTXUglyEligibility":{source:"contracts/solidity/eligibility/NFTXUglyEligibility.sol",name:"NFTXUglyEligibility",events:{"NFTXEligibilityInit()":{anonymous:!1,inputs:[],name:"NFTXEligibilityInit",type:"event"}},methods:{"__NFTXEligibility_init()":{inputs:[],name:"__NFTXEligibility_init",outputs:[],stateMutability:"nonpayable",type:"function"},"__NFTXEligibility_init_bytes(bytes)":{inputs:[{internalType:"bytes",name:"",type:"bytes"}],name:"__NFTXEligibility_init_bytes",outputs:[],stateMutability:"nonpayable",type:"function"},"afterMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"afterRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"checkAllEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkAllIneligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllIneligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkEligible",outputs:[{internalType:"bool[]",name:"",type:"bool[]"}],stateMutability:"view",type:"function"},"checkIsEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"checkIsEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"finalized()":{inputs:[],name:"finalized",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"targetAsset()":{inputs:[],name:"targetAsset",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"}}},"contracts/solidity/eligibility/NFTXUniqueEligibility.sol:NFTXUniqueEligibility":{source:"contracts/solidity/eligibility/NFTXUniqueEligibility.sol",name:"NFTXUniqueEligibility",events:{"NFTXEligibilityInit(address,address,bool,bool,uint256[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"address",name:"vault",type:"address"},{indexed:!1,internalType:"bool",name:"negateElig",type:"bool"},{indexed:!1,internalType:"bool",name:"finalize",type:"bool"},{indexed:!1,internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"NFTXEligibilityInit",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"UniqueEligibilitiesSet(uint256[],bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{indexed:!1,internalType:"bool",name:"isEligible",type:"bool"}],name:"UniqueEligibilitiesSet",type:"event"},"negateEligilityOnRedeemSet(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"negateElig",type:"bool"}],name:"negateEligilityOnRedeemSet",type:"event"}},methods:{"__NFTXEligibility_init(address,address,bool,bool,uint256[])":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"address",name:"_vault",type:"address"},{internalType:"bool",name:"negateElig",type:"bool"},{internalType:"bool",name:"finalize",type:"bool"},{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"__NFTXEligibility_init",outputs:[],stateMutability:"nonpayable",type:"function"},"__NFTXEligibility_init_bytes(bytes)":{inputs:[{internalType:"bytes",name:"_configData",type:"bytes"}],name:"__NFTXEligibility_init_bytes",outputs:[],stateMutability:"nonpayable",type:"function"},"afterMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"afterRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"checkAllEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkAllIneligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllIneligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkEligible",outputs:[{internalType:"bool[]",name:"",type:"bool[]"}],stateMutability:"view",type:"function"},"checkIsEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"checkIsEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"finalized()":{inputs:[],name:"finalized",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isInitialized()":{inputs:[],name:"isInitialized",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isUniqueEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"isUniqueEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"negateEligOnRedeem()":{inputs:[],name:"negateEligOnRedeem",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setEligibilityPreferences(bool)":{inputs:[{internalType:"bool",name:"_negateEligOnRedeem",type:"bool"}],name:"setEligibilityPreferences",outputs:[],stateMutability:"nonpayable",type:"function"},"setUniqueEligibilities(uint256[],bool)":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"bool",name:"_isEligible",type:"bool"}],name:"setUniqueEligibilities",outputs:[],stateMutability:"nonpayable",type:"function"},"targetAsset()":{inputs:[],name:"targetAsset",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/solidity/eligibility/UniqueEligibility.sol:UniqueEligibility":{source:"contracts/solidity/eligibility/UniqueEligibility.sol",name:"UniqueEligibility",events:{"UniqueEligibilitiesSet(uint256[],bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{indexed:!1,internalType:"bool",name:"isEligible",type:"bool"}],name:"UniqueEligibilitiesSet",type:"event"}},methods:{"isUniqueEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"isUniqueEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"}}},"contracts/solidity/eligibility/UniswapV3SparkleEligibility.sol:BitMath":{source:"contracts/solidity/eligibility/UniswapV3SparkleEligibility.sol",name:"BitMath",title:"BitMath",details:"This library provides functionality for computing bit properties of an unsigned integer"},"contracts/solidity/eligibility/UniswapV3SparkleEligibility.sol:INonfungiblePositionManager":{source:"contracts/solidity/eligibility/UniswapV3SparkleEligibility.sol",name:"INonfungiblePositionManager",methods:{"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"positions(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"positions",outputs:[{internalType:"uint96",name:"nonce",type:"uint96"},{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"liquidity",type:"uint128"},{internalType:"uint256",name:"feeGrowthInside0LastX128",type:"uint256"},{internalType:"uint256",name:"feeGrowthInside1LastX128",type:"uint256"},{internalType:"uint128",name:"tokensOwed0",type:"uint128"},{internalType:"uint128",name:"tokensOwed1",type:"uint128"}],stateMutability:"view",type:"function",details:"Throws if the token ID is not valid.",params:{tokenId:"The ID of the token that represents the position"},returns:{fee:"The fee associated with the pool",feeGrowthInside0LastX128:"The fee growth of token0 as of the last action on the individual position",feeGrowthInside1LastX128:"The fee growth of token1 as of the last action on the individual position",liquidity:"The liquidity of the position",nonce:"The nonce for permits",operator:"The address that is approved for spending",tickLower:"The lower end of the tick range for the position",tickUpper:"The higher end of the tick range for the position",token0:"The address of the token0 for a specific pool",token1:"The address of the token1 for a specific pool",tokensOwed0:"The uncollected amount of token0 owed to the position as of the last computation",tokensOwed1:"The uncollected amount of token1 owed to the position as of the last computation"},notice:"Returns the position information associated with a given token ID."}}},"contracts/solidity/eligibility/UniswapV3SparkleEligibility.sol:UniswapV3SparkleEligibility":{source:"contracts/solidity/eligibility/UniswapV3SparkleEligibility.sol",name:"UniswapV3SparkleEligibility",events:{"NFTXEligibilityInit()":{anonymous:!1,inputs:[],name:"NFTXEligibilityInit",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"PoolsAdded(address[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"address[]",name:"poolsAdded",type:"address[]"}],name:"PoolsAdded",type:"event"}},methods:{"__NFTXEligibility_init(address[],address)":{inputs:[{internalType:"address[]",name:"_validPools",type:"address[]"},{internalType:"address",name:"_owner",type:"address"}],name:"__NFTXEligibility_init",outputs:[],stateMutability:"nonpayable",type:"function"},"__NFTXEligibility_init_bytes(bytes)":{inputs:[{internalType:"bytes",name:"configData",type:"bytes"}],name:"__NFTXEligibility_init_bytes",outputs:[],stateMutability:"nonpayable",type:"function"},"addValidPools(address[])":{inputs:[{internalType:"address[]",name:"newPools",type:"address[]"}],name:"addValidPools",outputs:[],stateMutability:"nonpayable",type:"function"},"afterMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"afterRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"checkAllEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkAllIneligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllIneligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkEligible",outputs:[{internalType:"bool[]",name:"",type:"bool[]"}],stateMutability:"view",type:"function"},"checkIsEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"checkIsEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"finalized()":{inputs:[],name:"finalized",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isInitialized()":{inputs:[],name:"isInitialized",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"positionManager()":{inputs:[],name:"positionManager",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"targetAsset()":{inputs:[],name:"targetAsset",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"validPools(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"validPools",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"}}},"contracts/solidity/interface/IAdminUpgradeabilityProxy.sol:IAdminUpgradeabilityProxy":{source:"contracts/solidity/interface/IAdminUpgradeabilityProxy.sol",name:"IAdminUpgradeabilityProxy",methods:{"admin()":{inputs:[],name:"admin",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"changeAdmin(address)":{inputs:[{internalType:"address",name:"newAdmin",type:"address"}],name:"changeAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"implementation()":{inputs:[],name:"implementation",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/interface/IERC165Upgradeable.sol:IERC165Upgradeable":{source:"contracts/solidity/interface/IERC165Upgradeable.sol",name:"IERC165Upgradeable",details:"Interface of the ERC165 standard, as defined in the https://eips.ethereum.org/EIPS/eip-165[EIP]. Implementers can declare support of contract interfaces, which can then be queried by others ({ERC165Checker}). For an implementation, see {ERC165}.",methods:{"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."}}},"contracts/solidity/interface/IERC3156Upgradeable.sol:IERC3156FlashBorrowerUpgradeable":{source:"contracts/solidity/interface/IERC3156Upgradeable.sol",name:"IERC3156FlashBorrowerUpgradeable",details:"Interface of the ERC3156 FlashBorrower, as defined in https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].",methods:{"onFlashLoan(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"initiator",type:"address"},{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"fee",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"onFlashLoan",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"nonpayable",type:"function",details:"Receive a flash loan.",params:{amount:"The amount of tokens lent.",data:"Arbitrary data structure, intended to contain user-defined parameters.",fee:"The additional amount of tokens to repay.",initiator:"The initiator of the loan.",token:"The loan currency."},returns:{_0:'The keccak256 hash of "ERC3156FlashBorrower.onFlashLoan"'}}}},"contracts/solidity/interface/IERC3156Upgradeable.sol:IERC3156FlashLenderUpgradeable":{source:"contracts/solidity/interface/IERC3156Upgradeable.sol",name:"IERC3156FlashLenderUpgradeable",details:"Interface of the ERC3156 FlashLender, as defined in https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].",methods:{"flashFee(address,uint256)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"flashFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"The fee to be charged for a given loan.",params:{amount:"The amount of tokens lent.",token:"The loan currency."},returns:{_0:"The amount of `token` to be charged for the loan, on top of the returned principal."}},"flashLoan(address,address,uint256,bytes)":{inputs:[{internalType:"contract IERC3156FlashBorrowerUpgradeable",name:"receiver",type:"address"},{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"flashLoan",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Initiate a flash loan.",params:{amount:"The amount of tokens lent.",data:"Arbitrary data structure, intended to contain user-defined parameters.",receiver:"The receiver of the tokens in the loan, and the receiver of the callback.",token:"The loan currency."}},"maxFlashLoan(address)":{inputs:[{internalType:"address",name:"token",type:"address"}],name:"maxFlashLoan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"The amount of currency available to be lended.",params:{token:"The loan currency."},returns:{_0:"The amount of `token` that can be borrowed."}}}},"contracts/solidity/interface/INFTXEligibility.sol:INFTXEligibility":{source:"contracts/solidity/interface/INFTXEligibility.sol",name:"INFTXEligibility",methods:{"__NFTXEligibility_init_bytes(bytes)":{inputs:[{internalType:"bytes",name:"configData",type:"bytes"}],name:"__NFTXEligibility_init_bytes",outputs:[],stateMutability:"nonpayable",type:"function"},"afterMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"afterRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"afterRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeMintHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeMintHook",outputs:[],stateMutability:"nonpayable",type:"function"},"beforeRedeemHook(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"beforeRedeemHook",outputs:[],stateMutability:"nonpayable",type:"function"},"checkAllEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkAllIneligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkAllIneligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"checkEligible(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"checkEligible",outputs:[{internalType:"bool[]",name:"",type:"bool[]"}],stateMutability:"view",type:"function"},"checkIsEligible(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"checkIsEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"finalized()":{inputs:[],name:"finalized",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"targetAsset()":{inputs:[],name:"targetAsset",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"}}},"contracts/solidity/interface/INFTXEligibilityManager.sol:INFTXEligibilityManager":{source:"contracts/solidity/interface/INFTXEligibilityManager.sol",name:"INFTXEligibilityManager",methods:{"deployEligibility(uint256,bytes)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"bytes",name:"initData",type:"bytes"}],name:"deployEligibility",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"},"eligibilityImpl()":{inputs:[],name:"eligibilityImpl",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"},"nftxVaultFactory()":{inputs:[],name:"nftxVaultFactory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/interface/INFTXFeeDistributor.sol:INFTXFeeDistributor":{source:"contracts/solidity/interface/INFTXFeeDistributor.sol",name:"INFTXFeeDistributor",methods:{"__FeeDistributor__init__(address,address)":{inputs:[{internalType:"address",name:"_lpStaking",type:"address"},{internalType:"address",name:"_treasury",type:"address"}],name:"__FeeDistributor__init__",outputs:[],stateMutability:"nonpayable",type:"function"},"addReceiver(uint256,uint256,address,bool)":{inputs:[{internalType:"uint256",name:"_vaultId",type:"uint256"},{internalType:"uint256",name:"_allocPoint",type:"uint256"},{internalType:"address",name:"_receiver",type:"address"},{internalType:"bool",name:"_isContract",type:"bool"}],name:"addReceiver",outputs:[],stateMutability:"nonpayable",type:"function"},"allocTotal(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"allocTotal",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"changeMultipleReceiverAddress(uint256[],uint256[],address[],bool[])":{inputs:[{internalType:"uint256[]",name:"_vaultIds",type:"uint256[]"},{internalType:"uint256[]",name:"_receiverIdxs",type:"uint256[]"},{internalType:"address[]",name:"addresses",type:"address[]"},{internalType:"bool[]",name:"isContracts",type:"bool[]"}],name:"changeMultipleReceiverAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"changeMultipleReceiverAlloc(uint256[],uint256[],uint256[])":{inputs:[{internalType:"uint256[]",name:"_vaultIds",type:"uint256[]"},{internalType:"uint256[]",name:"_receiverIdxs",type:"uint256[]"},{internalType:"uint256[]",name:"allocPoints",type:"uint256[]"}],name:"changeMultipleReceiverAlloc",outputs:[],stateMutability:"nonpayable",type:"function"},"changeReceiverAddress(uint256,uint256,address,bool)":{inputs:[{internalType:"uint256",name:"_vaultId",type:"uint256"},{internalType:"uint256",name:"_idx",type:"uint256"},{internalType:"address",name:"_address",type:"address"},{internalType:"bool",name:"_isContract",type:"bool"}],name:"changeReceiverAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"changeReceiverAlloc(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_vaultId",type:"uint256"},{internalType:"uint256",name:"_idx",type:"uint256"},{internalType:"uint256",name:"_allocPoint",type:"uint256"}],name:"changeReceiverAlloc",outputs:[],stateMutability:"nonpayable",type:"function"},"defaultLPAlloc()":{inputs:[],name:"defaultLPAlloc",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"defaultTreasuryAlloc()":{inputs:[],name:"defaultTreasuryAlloc",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"distribute(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function"},"initializeVaultReceivers(uint256)":{inputs:[{internalType:"uint256",name:"_vaultId",type:"uint256"}],name:"initializeVaultReceivers",outputs:[],stateMutability:"nonpayable",type:"function"},"lpStaking()":{inputs:[],name:"lpStaking",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"},"nftxVaultFactory()":{inputs:[],name:"nftxVaultFactory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"},"removeReceiver(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_vaultId",type:"uint256"},{internalType:"uint256",name:"_receiverIdx",type:"uint256"}],name:"removeReceiver",outputs:[],stateMutability:"nonpayable",type:"function"},"rescueTokens(address)":{inputs:[{internalType:"address",name:"token",type:"address"}],name:"rescueTokens",outputs:[],stateMutability:"nonpayable",type:"function"},"setDefaultLPAlloc(uint256)":{inputs:[{internalType:"uint256",name:"_allocPoint",type:"uint256"}],name:"setDefaultLPAlloc",outputs:[],stateMutability:"nonpayable",type:"function"},"setDefaultTreasuryAlloc(uint256)":{inputs:[{internalType:"uint256",name:"_allocPoint",type:"uint256"}],name:"setDefaultTreasuryAlloc",outputs:[],stateMutability:"nonpayable",type:"function"},"setLPStakingAddress(address)":{inputs:[{internalType:"address",name:"_lpStaking",type:"address"}],name:"setLPStakingAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"setNFTXVaultFactory(address)":{inputs:[{internalType:"address",name:"_factory",type:"address"}],name:"setNFTXVaultFactory",outputs:[],stateMutability:"nonpayable",type:"function"},"setSpecificTreasuryAlloc(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_vaultId",type:"uint256"},{internalType:"uint256",name:"_allocPoint",type:"uint256"}],name:"setSpecificTreasuryAlloc",outputs:[],stateMutability:"nonpayable",type:"function"},"setTreasuryAddress(address)":{inputs:[{internalType:"address",name:"_treasury",type:"address"}],name:"setTreasuryAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"specificTreasuryAlloc(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"specificTreasuryAlloc",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/interface/INFTXInventoryStaking.sol:INFTXInventoryStaking":{source:"contracts/solidity/interface/INFTXInventoryStaking.sol",name:"INFTXInventoryStaking",methods:{"__NFTXInventoryStaking_init(address)":{inputs:[{internalType:"address",name:"nftxFactory",type:"address"}],name:"__NFTXInventoryStaking_init",outputs:[],stateMutability:"nonpayable",type:"function"},"deployXTokenForVault(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"deployXTokenForVault",outputs:[],stateMutability:"nonpayable",type:"function"},"deposit(uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function"},"nftxVaultFactory()":{inputs:[],name:"nftxVaultFactory",outputs:[{internalType:"contract INFTXVaultFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"receiveRewards(uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"receiveRewards",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"timelockMintFor(uint256,uint256,address,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"timelockLength",type:"uint256"}],name:"timelockMintFor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"vaultXToken(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"vaultXToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"withdraw(uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"_share",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"},"xTokenAddr(address)":{inputs:[{internalType:"address",name:"baseToken",type:"address"}],name:"xTokenAddr",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"xTokenShareValue(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"xTokenShareValue",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/solidity/interface/INFTXLPStaking.sol:INFTXLPStaking":{source:"contracts/solidity/interface/INFTXLPStaking.sol",name:"INFTXLPStaking",methods:{"__NFTXLPStaking__init(address)":{inputs:[{internalType:"address",name:"_stakingTokenProvider",type:"address"}],name:"__NFTXLPStaking__init",outputs:[],stateMutability:"nonpayable",type:"function"},"addPoolForVault(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"addPoolForVault",outputs:[],stateMutability:"nonpayable",type:"function"},"claimRewards(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"claimRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"deposit(uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function"},"exit(uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"exit",outputs:[],stateMutability:"nonpayable",type:"function"},"newRewardDistributionToken(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"newRewardDistributionToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"nftxVaultFactory()":{inputs:[],name:"nftxVaultFactory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"oldRewardDistributionToken(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"oldRewardDistributionToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"receiveRewards(uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"receiveRewards",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"rescue(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"rescue",outputs:[],stateMutability:"nonpayable",type:"function"},"rewardDistTokenImpl()":{inputs:[],name:"rewardDistTokenImpl",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"rewardDistributionToken(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"rewardDistributionToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"rewardDistributionTokenAddr(address,address)":{inputs:[{internalType:"address",name:"stakedToken",type:"address"},{internalType:"address",name:"rewardToken",type:"address"}],name:"rewardDistributionTokenAddr",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"setNFTXVaultFactory(address)":{inputs:[{internalType:"address",name:"newFactory",type:"address"}],name:"setNFTXVaultFactory",outputs:[],stateMutability:"nonpayable",type:"function"},"setStakingTokenProvider(address)":{inputs:[{internalType:"address",name:"newProvider",type:"address"}],name:"setStakingTokenProvider",outputs:[],stateMutability:"nonpayable",type:"function"},"stakingToken(address)":{inputs:[{internalType:"address",name:"_vaultToken",type:"address"}],name:"stakingToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"stakingTokenProvider()":{inputs:[],name:"stakingTokenProvider",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"timelockDepositFor(uint256,address,uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"timelockLength",type:"uint256"}],name:"timelockDepositFor",outputs:[],stateMutability:"nonpayable",type:"function"},"unusedRewardDistributionToken(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"unusedRewardDistributionToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"updatePoolForVault(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"updatePoolForVault",outputs:[],stateMutability:"nonpayable",type:"function"},"updatePoolForVaults(uint256[])":{inputs:[{internalType:"uint256[]",name:"vaultId",type:"uint256[]"}],name:"updatePoolForVaults",outputs:[],stateMutability:"nonpayable",type:"function"},"vaultToken(address)":{inputs:[{internalType:"address",name:"_stakingToken",type:"address"}],name:"vaultToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"withdraw(uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/interface/INFTXSimpleFeeDistributor.sol:INFTXSimpleFeeDistributor":{source:"contracts/solidity/interface/INFTXSimpleFeeDistributor.sol",name:"INFTXSimpleFeeDistributor",methods:{"__SimpleFeeDistributor__init__(address,address)":{inputs:[{internalType:"address",name:"_lpStaking",type:"address"},{internalType:"address",name:"_treasury",type:"address"}],name:"__SimpleFeeDistributor__init__",outputs:[],stateMutability:"nonpayable",type:"function"},"addReceiver(uint256,address,bool)":{inputs:[{internalType:"uint256",name:"_allocPoint",type:"uint256"},{internalType:"address",name:"_receiver",type:"address"},{internalType:"bool",name:"_isContract",type:"bool"}],name:"addReceiver",outputs:[],stateMutability:"nonpayable",type:"function"},"allocTotal()":{inputs:[],name:"allocTotal",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"changeReceiverAddress(uint256,address,bool)":{inputs:[{internalType:"uint256",name:"_idx",type:"uint256"},{internalType:"address",name:"_address",type:"address"},{internalType:"bool",name:"_isContract",type:"bool"}],name:"changeReceiverAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"changeReceiverAlloc(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_idx",type:"uint256"},{internalType:"uint256",name:"_allocPoint",type:"uint256"}],name:"changeReceiverAlloc",outputs:[],stateMutability:"nonpayable",type:"function"},"distribute(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function"},"initializeVaultReceivers(uint256)":{inputs:[{internalType:"uint256",name:"_vaultId",type:"uint256"}],name:"initializeVaultReceivers",outputs:[],stateMutability:"nonpayable",type:"function"},"inventoryStaking()":{inputs:[],name:"inventoryStaking",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"lpStaking()":{inputs:[],name:"lpStaking",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"nftxVaultFactory()":{inputs:[],name:"nftxVaultFactory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"removeReceiver(uint256)":{inputs:[{internalType:"uint256",name:"_receiverIdx",type:"uint256"}],name:"removeReceiver",outputs:[],stateMutability:"nonpayable",type:"function"},"rescueTokens(address)":{inputs:[{internalType:"address",name:"token",type:"address"}],name:"rescueTokens",outputs:[],stateMutability:"nonpayable",type:"function"},"setInventoryStakingAddress(address)":{inputs:[{internalType:"address",name:"_inventoryStaking",type:"address"}],name:"setInventoryStakingAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"setLPStakingAddress(address)":{inputs:[{internalType:"address",name:"_lpStaking",type:"address"}],name:"setLPStakingAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"setNFTXVaultFactory(address)":{inputs:[{internalType:"address",name:"_factory",type:"address"}],name:"setNFTXVaultFactory",outputs:[],stateMutability:"nonpayable",type:"function"},"setTreasuryAddress(address)":{inputs:[{internalType:"address",name:"_treasury",type:"address"}],name:"setTreasuryAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/solidity/interface/INFTXVault.sol:INFTXVault":{source:"contracts/solidity/interface/INFTXVault.sol",name:"INFTXVault",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"EligibilityDeployed(uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"moduleIndex",type:"uint256"},{indexed:!1,internalType:"address",name:"eligibilityAddr",type:"address"}],name:"EligibilityDeployed",type:"event"},"EnableMintUpdated(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"enabled",type:"bool"}],name:"EnableMintUpdated",type:"event"},"EnableRandomRedeemUpdated(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"enabled",type:"bool"}],name:"EnableRandomRedeemUpdated",type:"event"},"EnableRandomSwapUpdated(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"enabled",type:"bool"}],name:"EnableRandomSwapUpdated",type:"event"},"EnableTargetRedeemUpdated(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"enabled",type:"bool"}],name:"EnableTargetRedeemUpdated",type:"event"},"EnableTargetSwapUpdated(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"enabled",type:"bool"}],name:"EnableTargetSwapUpdated",type:"event"},"ManagerSet(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"manager",type:"address"}],name:"ManagerSet",type:"event"},"Minted(uint256[],uint256[],address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256[]",name:"nftIds",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"amounts",type:"uint256[]"},{indexed:!1,internalType:"address",name:"to",type:"address"}],name:"Minted",type:"event"},"Redeemed(uint256[],uint256[],address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256[]",name:"nftIds",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"specificIds",type:"uint256[]"},{indexed:!1,internalType:"address",name:"to",type:"address"}],name:"Redeemed",type:"event"},"Swapped(uint256[],uint256[],uint256[],uint256[],address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256[]",name:"nftIds",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"amounts",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"specificIds",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"redeemedIds",type:"uint256[]"},{indexed:!1,internalType:"address",name:"to",type:"address"}],name:"Swapped",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"},"VaultInit(uint256,address,bool,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"address",name:"assetAddress",type:"address"},{indexed:!1,internalType:"bool",name:"is1155",type:"bool"},{indexed:!1,internalType:"bool",name:"allowAllItems",type:"bool"}],name:"VaultInit",type:"event"}},methods:{"__NFTXVault_init(string,string,address,bool,bool)":{inputs:[{internalType:"string",name:"_name",type:"string"},{internalType:"string",name:"_symbol",type:"string"},{internalType:"address",name:"_assetAddress",type:"address"},{internalType:"bool",name:"_is1155",type:"bool"},{internalType:"bool",name:"_allowAllItems",type:"bool"}],name:"__NFTXVault_init",outputs:[],stateMutability:"nonpayable",type:"function"},"allHoldings()":{inputs:[],name:"allHoldings",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function"},"allValidNFTs(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"allValidNFTs",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"allowAllItems()":{inputs:[],name:"allowAllItems",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"assetAddress()":{inputs:[],name:"assetAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"deployEligibilityStorage(uint256,bytes)":{inputs:[{internalType:"uint256",name:"moduleIndex",type:"uint256"},{internalType:"bytes",name:"initData",type:"bytes"}],name:"deployEligibilityStorage",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"},"disableVaultFees()":{inputs:[],name:"disableVaultFees",outputs:[],stateMutability:"nonpayable",type:"function"},"eligibilityStorage()":{inputs:[],name:"eligibilityStorage",outputs:[{internalType:"contract INFTXEligibility",name:"",type:"address"}],stateMutability:"view",type:"function"},"enableMint()":{inputs:[],name:"enableMint",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"enableRandomRedeem()":{inputs:[],name:"enableRandomRedeem",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"enableRandomSwap()":{inputs:[],name:"enableRandomSwap",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"enableTargetRedeem()":{inputs:[],name:"enableTargetRedeem",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"enableTargetSwap()":{inputs:[],name:"enableTargetSwap",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"finalizeVault()":{inputs:[],name:"finalizeVault",outputs:[],stateMutability:"nonpayable",type:"function"},"is1155()":{inputs:[],name:"is1155",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"manager()":{inputs:[],name:"manager",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mint(uint256[],uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],name:"mint",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"mintFee()":{inputs:[],name:"mintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mintTo(uint256[],uint256[],address)":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"address",name:"to",type:"address"}],name:"mintTo",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"nftIdAt(uint256)":{inputs:[{internalType:"uint256",name:"holdingsIndex",type:"uint256"}],name:"nftIdAt",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"randomRedeemFee()":{inputs:[],name:"randomRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"randomSwapFee()":{inputs:[],name:"randomSwapFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeem(uint256,uint256[])":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256[]",name:"specificIds",type:"uint256[]"}],name:"redeem",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"redeemTo(uint256,uint256[],address)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256[]",name:"specificIds",type:"uint256[]"},{internalType:"address",name:"to",type:"address"}],name:"redeemTo",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"setFees(uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_mintFee",type:"uint256"},{internalType:"uint256",name:"_randomRedeemFee",type:"uint256"},{internalType:"uint256",name:"_targetRedeemFee",type:"uint256"},{internalType:"uint256",name:"_randomSwapFee",type:"uint256"},{internalType:"uint256",name:"_targetSwapFee",type:"uint256"}],name:"setFees",outputs:[],stateMutability:"nonpayable",type:"function"},"setManager(address)":{inputs:[{internalType:"address",name:"_manager",type:"address"}],name:"setManager",outputs:[],stateMutability:"nonpayable",type:"function"},"setVaultFeatures(bool,bool,bool,bool,bool)":{inputs:[{internalType:"bool",name:"_enableMint",type:"bool"},{internalType:"bool",name:"_enableRandomRedeem",type:"bool"},{internalType:"bool",name:"_enableTargetRedeem",type:"bool"},{internalType:"bool",name:"_enableRandomSwap",type:"bool"},{internalType:"bool",name:"_enableTargetSwap",type:"bool"}],name:"setVaultFeatures",outputs:[],stateMutability:"nonpayable",type:"function"},"setVaultMetadata(string,string)":{inputs:[{internalType:"string",name:"name_",type:"string"},{internalType:"string",name:"symbol_",type:"string"}],name:"setVaultMetadata",outputs:[],stateMutability:"nonpayable",type:"function"},"swap(uint256[],uint256[],uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256[]",name:"specificIds",type:"uint256[]"}],name:"swap",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"swapTo(uint256[],uint256[],uint256[],address)":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256[]",name:"specificIds",type:"uint256[]"},{internalType:"address",name:"to",type:"address"}],name:"swapTo",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"targetRedeemFee()":{inputs:[],name:"targetRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"targetSwapFee()":{inputs:[],name:"targetSwapFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalHoldings()":{inputs:[],name:"totalHoldings",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"vaultFactory()":{inputs:[],name:"vaultFactory",outputs:[{internalType:"contract INFTXVaultFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"vaultFees()":{inputs:[],name:"vaultFees",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"vaultId()":{inputs:[],name:"vaultId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/solidity/interface/INFTXVaultFactory.sol:INFTXVaultFactory":{source:"contracts/solidity/interface/INFTXVaultFactory.sol",name:"INFTXVaultFactory",events:{"DisableVaultFees(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"vaultId",type:"uint256"}],name:"DisableVaultFees",type:"event"},"FeeExclusion(address,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"feeExcluded",type:"address"},{indexed:!1,internalType:"bool",name:"excluded",type:"bool"}],name:"FeeExclusion",type:"event"},"NewEligibilityManager(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldEligManager",type:"address"},{indexed:!1,internalType:"address",name:"newEligManager",type:"address"}],name:"NewEligibilityManager",type:"event"},"NewFeeDistributor(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldDistributor",type:"address"},{indexed:!1,internalType:"address",name:"newDistributor",type:"address"}],name:"NewFeeDistributor",type:"event"},"NewVault(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"address",name:"vaultAddress",type:"address"},{indexed:!1,internalType:"address",name:"assetAddress",type:"address"}],name:"NewVault",type:"event"},"NewZapContract(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldZap",type:"address"},{indexed:!1,internalType:"address",name:"newZap",type:"address"}],name:"NewZapContract",type:"event"},"UpdateFactoryFees(uint256,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"mintFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"randomRedeemFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"targetRedeemFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"randomSwapFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"targetSwapFee",type:"uint256"}],name:"UpdateFactoryFees",type:"event"},"UpdateVaultFees(uint256,uint256,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"mintFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"randomRedeemFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"targetRedeemFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"randomSwapFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"targetSwapFee",type:"uint256"}],name:"UpdateVaultFees",type:"event"}},methods:{"__NFTXVaultFactory_init(address,address)":{inputs:[{internalType:"address",name:"_vaultImpl",type:"address"},{internalType:"address",name:"_feeDistributor",type:"address"}],name:"__NFTXVaultFactory_init",outputs:[],stateMutability:"nonpayable",type:"function"},"allVaults()":{inputs:[],name:"allVaults",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"childImplementation()":{inputs:[],name:"childImplementation",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Must return an address that can be used as a delegate call target. {BeaconProxy} will check that this address is a contract."},"createVault(string,string,address,bool,bool)":{inputs:[{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"symbol",type:"string"},{internalType:"address",name:"_assetAddress",type:"address"},{internalType:"bool",name:"is1155",type:"bool"},{internalType:"bool",name:"allowAllItems",type:"bool"}],name:"createVault",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"disableVaultFees(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"disableVaultFees",outputs:[],stateMutability:"nonpayable",type:"function"},"eligibilityManager()":{inputs:[],name:"eligibilityManager",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"excludedFromFees(address)":{inputs:[{internalType:"address",name:"addr",type:"address"}],name:"excludedFromFees",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"factoryMintFee()":{inputs:[],name:"factoryMintFee",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function"},"factoryRandomRedeemFee()":{inputs:[],name:"factoryRandomRedeemFee",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function"},"factoryRandomSwapFee()":{inputs:[],name:"factoryRandomSwapFee",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function"},"factoryTargetRedeemFee()":{inputs:[],name:"factoryTargetRedeemFee",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function"},"factoryTargetSwapFee()":{inputs:[],name:"factoryTargetSwapFee",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function"},"feeDistributor()":{inputs:[],name:"feeDistributor",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"isLocked(uint256)":{inputs:[{internalType:"uint256",name:"id",type:"uint256"}],name:"isLocked",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"numVaults()":{inputs:[],name:"numVaults",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"setEligibilityManager(address)":{inputs:[{internalType:"address",name:"_eligibilityManager",type:"address"}],name:"setEligibilityManager",outputs:[],stateMutability:"nonpayable",type:"function"},"setFactoryFees(uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"mintFee",type:"uint256"},{internalType:"uint256",name:"randomRedeemFee",type:"uint256"},{internalType:"uint256",name:"targetRedeemFee",type:"uint256"},{internalType:"uint256",name:"randomSwapFee",type:"uint256"},{internalType:"uint256",name:"targetSwapFee",type:"uint256"}],name:"setFactoryFees",outputs:[],stateMutability:"nonpayable",type:"function"},"setFeeDistributor(address)":{inputs:[{internalType:"address",name:"_feeDistributor",type:"address"}],name:"setFeeDistributor",outputs:[],stateMutability:"nonpayable",type:"function"},"setFeeExclusion(address,bool)":{inputs:[{internalType:"address",name:"_excludedAddr",type:"address"},{internalType:"bool",name:"excluded",type:"bool"}],name:"setFeeExclusion",outputs:[],stateMutability:"nonpayable",type:"function"},"setVaultFees(uint256,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"mintFee",type:"uint256"},{internalType:"uint256",name:"randomRedeemFee",type:"uint256"},{internalType:"uint256",name:"targetRedeemFee",type:"uint256"},{internalType:"uint256",name:"randomSwapFee",type:"uint256"},{internalType:"uint256",name:"targetSwapFee",type:"uint256"}],name:"setVaultFees",outputs:[],stateMutability:"nonpayable",type:"function"},"setZapContract(address)":{inputs:[{internalType:"address",name:"_zapContract",type:"address"}],name:"setZapContract",outputs:[],stateMutability:"nonpayable",type:"function"},"upgradeChildTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeChildTo",outputs:[],stateMutability:"nonpayable",type:"function"},"vault(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"vault",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"vaultFees(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"vaultFees",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"vaultsForAsset(address)":{inputs:[{internalType:"address",name:"asset",type:"address"}],name:"vaultsForAsset",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"zapContract()":{inputs:[],name:"zapContract",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/solidity/interface/IPrevNftxContract.sol:IPrevNftxContract":{source:"contracts/solidity/interface/IPrevNftxContract.sol",name:"IPrevNftxContract",methods:{"isEligible(uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"nftId",type:"uint256"}],name:"isEligible",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"}}},"contracts/solidity/interface/IRewardDistributionToken.sol:IRewardDistributionToken":{source:"contracts/solidity/interface/IRewardDistributionToken.sol",name:"IRewardDistributionToken",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"__RewardDistributionToken_init(address,string,string)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_target",type:"address"},{internalType:"string",name:"_name",type:"string"},{internalType:"string",name:"_symbol",type:"string"}],name:"__RewardDistributionToken_init",outputs:[],stateMutability:"nonpayable",type:"function"},"accumulativeRewardOf(address)":{inputs:[{internalType:"address",name:"_owner",type:"address"}],name:"accumulativeRewardOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"burnFrom(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burnFrom",outputs:[],stateMutability:"nonpayable",type:"function"},"distributeRewards(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"distributeRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"dividendOf(address)":{inputs:[{internalType:"address",name:"_owner",type:"address"}],name:"dividendOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mint(address,address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"withdrawReward(address)":{inputs:[{internalType:"address",name:"user",type:"address"}],name:"withdrawReward",outputs:[],stateMutability:"nonpayable",type:"function"},"withdrawnRewardOf(address)":{inputs:[{internalType:"address",name:"_owner",type:"address"}],name:"withdrawnRewardOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/solidity/interface/ITimelockExcludeList.sol:ITimelockExcludeList":{source:"contracts/solidity/interface/ITimelockExcludeList.sol",name:"ITimelockExcludeList",methods:{"isExcluded(address,uint256)":{inputs:[{internalType:"address",name:"addr",type:"address"},{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"isExcluded",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"}}},"contracts/solidity/interface/ITimelockRewardDistributionToken.sol:ITimelockRewardDistributionToken":{source:"contracts/solidity/interface/ITimelockRewardDistributionToken.sol",name:"ITimelockRewardDistributionToken",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"__TimelockRewardDistributionToken_init(address,string,string)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_target",type:"address"},{internalType:"string",name:"_name",type:"string"},{internalType:"string",name:"_symbol",type:"string"}],name:"__TimelockRewardDistributionToken_init",outputs:[],stateMutability:"nonpayable",type:"function"},"accumulativeRewardOf(address)":{inputs:[{internalType:"address",name:"_owner",type:"address"}],name:"accumulativeRewardOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"burnFrom(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burnFrom",outputs:[],stateMutability:"nonpayable",type:"function"},"distributeRewards(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"distributeRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"dividendOf(address)":{inputs:[{internalType:"address",name:"_owner",type:"address"}],name:"dividendOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mint(address,address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"},"timelockMint(address,uint256,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"timelockLength",type:"uint256"}],name:"timelockMint",outputs:[],stateMutability:"nonpayable",type:"function"},"timelockUntil(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"timelockUntil",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"withdrawReward(address)":{inputs:[{internalType:"address",name:"user",type:"address"}],name:"withdrawReward",outputs:[],stateMutability:"nonpayable",type:"function"},"withdrawnRewardOf(address)":{inputs:[{internalType:"address",name:"_owner",type:"address"}],name:"withdrawnRewardOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/solidity/interface/IUniswapV2Pair.sol:IUniswapV2Pair":{source:"contracts/solidity/interface/IUniswapV2Pair.sol",name:"IUniswapV2Pair",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Burn(address,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"},{indexed:!0,internalType:"address",name:"to",type:"address"}],name:"Burn",type:"event"},"Mint(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Mint",type:"event"},"Swap(address,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0In",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1In",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount0Out",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1Out",type:"uint256"},{indexed:!0,internalType:"address",name:"to",type:"address"}],name:"Swap",type:"event"},"Sync(uint112,uint112)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint112",name:"reserve0",type:"uint112"},{indexed:!1,internalType:"uint112",name:"reserve1",type:"uint112"}],name:"Sync",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"DOMAIN_SEPARATOR()":{inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"MINIMUM_LIQUIDITY()":{inputs:[],name:"MINIMUM_LIQUIDITY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"PERMIT_TYPEHASH()":{inputs:[],name:"PERMIT_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"pure",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"burn(address)":{inputs:[{internalType:"address",name:"to",type:"address"}],name:"burn",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"pure",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getReserves()":{inputs:[],name:"getReserves",outputs:[{internalType:"uint112",name:"reserve0",type:"uint112"},{internalType:"uint112",name:"reserve1",type:"uint112"},{internalType:"uint32",name:"blockTimestampLast",type:"uint32"}],stateMutability:"view",type:"function"},"initialize(address,address)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"kLast()":{inputs:[],name:"kLast",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mint(address)":{inputs:[{internalType:"address",name:"to",type:"address"}],name:"mint",outputs:[{internalType:"uint256",name:"liquidity",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"nonces(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"nonces",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"nonpayable",type:"function"},"price0CumulativeLast()":{inputs:[],name:"price0CumulativeLast",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"price1CumulativeLast()":{inputs:[],name:"price1CumulativeLast",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"skim(address)":{inputs:[{internalType:"address",name:"to",type:"address"}],name:"skim",outputs:[],stateMutability:"nonpayable",type:"function"},"swap(uint256,uint256,address,bytes)":{inputs:[{internalType:"uint256",name:"amount0Out",type:"uint256"},{internalType:"uint256",name:"amount1Out",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"swap",outputs:[],stateMutability:"nonpayable",type:"function"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"sync()":{inputs:[],name:"sync",outputs:[],stateMutability:"nonpayable",type:"function"},"token0()":{inputs:[],name:"token0",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"token1()":{inputs:[],name:"token1",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/interface/IUniswapV2Router01.sol:IUniswapV2Router01":{source:"contracts/solidity/interface/IUniswapV2Router01.sol",name:"IUniswapV2Router01",methods:{"WETH()":{inputs:[],name:"WETH",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"},"addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint256",name:"amountADesired",type:"uint256"},{internalType:"uint256",name:"amountBDesired",type:"uint256"},{internalType:"uint256",name:"amountAMin",type:"uint256"},{internalType:"uint256",name:"amountBMin",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"addLiquidity",outputs:[{internalType:"uint256",name:"amountA",type:"uint256"},{internalType:"uint256",name:"amountB",type:"uint256"},{internalType:"uint256",name:"liquidity",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"addLiquidityETH(address,uint256,uint256,uint256,address,uint256)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountTokenDesired",type:"uint256"},{internalType:"uint256",name:"amountTokenMin",type:"uint256"},{internalType:"uint256",name:"amountETHMin",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"addLiquidityETH",outputs:[{internalType:"uint256",name:"amountToken",type:"uint256"},{internalType:"uint256",name:"amountETH",type:"uint256"},{internalType:"uint256",name:"liquidity",type:"uint256"}],stateMutability:"payable",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"},"getAmountIn(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint256",name:"reserveIn",type:"uint256"},{internalType:"uint256",name:"reserveOut",type:"uint256"}],name:"getAmountIn",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"}],stateMutability:"pure",type:"function"},"getAmountOut(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"reserveIn",type:"uint256"},{internalType:"uint256",name:"reserveOut",type:"uint256"}],name:"getAmountOut",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"pure",type:"function"},"getAmountsIn(uint256,address[])":{inputs:[{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"}],name:"getAmountsIn",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"view",type:"function"},"getAmountsOut(uint256,address[])":{inputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"}],name:"getAmountsOut",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"view",type:"function"},"quote(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"amountA",type:"uint256"},{internalType:"uint256",name:"reserveA",type:"uint256"},{internalType:"uint256",name:"reserveB",type:"uint256"}],name:"quote",outputs:[{internalType:"uint256",name:"amountB",type:"uint256"}],stateMutability:"pure",type:"function"},"removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint256",name:"liquidity",type:"uint256"},{internalType:"uint256",name:"amountAMin",type:"uint256"},{internalType:"uint256",name:"amountBMin",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidity",outputs:[{internalType:"uint256",name:"amountA",type:"uint256"},{internalType:"uint256",name:"amountB",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"removeLiquidityETH(address,uint256,uint256,uint256,address,uint256)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"liquidity",type:"uint256"},{internalType:"uint256",name:"amountTokenMin",type:"uint256"},{internalType:"uint256",name:"amountETHMin",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidityETH",outputs:[{internalType:"uint256",name:"amountToken",type:"uint256"},{internalType:"uint256",name:"amountETH",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"removeLiquidityETHWithPermit(address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"liquidity",type:"uint256"},{internalType:"uint256",name:"amountTokenMin",type:"uint256"},{internalType:"uint256",name:"amountETHMin",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"bool",name:"approveMax",type:"bool"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"removeLiquidityETHWithPermit",outputs:[{internalType:"uint256",name:"amountToken",type:"uint256"},{internalType:"uint256",name:"amountETH",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"removeLiquidityWithPermit(address,address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint256",name:"liquidity",type:"uint256"},{internalType:"uint256",name:"amountAMin",type:"uint256"},{internalType:"uint256",name:"amountBMin",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"bool",name:"approveMax",type:"bool"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"removeLiquidityWithPermit",outputs:[{internalType:"uint256",name:"amountA",type:"uint256"},{internalType:"uint256",name:"amountB",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"swapETHForExactTokens(uint256,address[],address,uint256)":{inputs:[{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapETHForExactTokens",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"payable",type:"function"},"swapExactETHForTokens(uint256,address[],address,uint256)":{inputs:[{internalType:"uint256",name:"amountOutMin",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapExactETHForTokens",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"payable",type:"function"},"swapExactTokensForETH(uint256,uint256,address[],address,uint256)":{inputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"amountOutMin",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapExactTokensForETH",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)":{inputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"amountOutMin",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapExactTokensForTokens",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"swapTokensForExactETH(uint256,uint256,address[],address,uint256)":{inputs:[{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint256",name:"amountInMax",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapTokensForExactETH",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"swapTokensForExactTokens(uint256,uint256,address[],address,uint256)":{inputs:[{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint256",name:"amountInMax",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapTokensForExactTokens",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/interface/IVaultTokenUpgradeable.sol:IVaultTokenUpgradeable":{source:"contracts/solidity/interface/IVaultTokenUpgradeable.sol",name:"IVaultTokenUpgradeable",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"burnFrom(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burnFrom",outputs:[],stateMutability:"nonpayable",type:"function"},"mint(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}}},"contracts/solidity/other/PalmNFTXStakingZap.sol:IWETH":{source:"contracts/solidity/other/PalmNFTXStakingZap.sol",name:"IWETH",methods:{"deposit()":{inputs:[],name:"deposit",outputs:[],stateMutability:"payable",type:"function"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/other/PalmNFTXStakingZap.sol:Ownable":{source:"contracts/solidity/other/PalmNFTXStakingZap.sol",name:"Ownable",details:"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. By default, the owner account will be the one that deploys the contract. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.",events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/solidity/other/PalmNFTXStakingZap.sol:PalmNFTXStakingZap":{source:"contracts/solidity/other/PalmNFTXStakingZap.sol",name:"PalmNFTXStakingZap",constructor:{inputs:[{internalType:"address",name:"_nftxFactory",type:"address"},{internalType:"address",name:"_sushiRouter",type:"address"},{internalType:"address",name:"_pairedToken",type:"address"}],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"UserStaked(uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"count",type:"uint256"},{indexed:!1,internalType:"uint256",name:"lpBalance",type:"uint256"},{indexed:!1,internalType:"uint256",name:"timelockUntil",type:"uint256"},{indexed:!1,internalType:"address",name:"sender",type:"address"}],name:"UserStaked",type:"event"}},methods:{"addLiquidity1155(uint256,uint256[],uint256[],uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"minWethIn",type:"uint256"},{internalType:"uint256",name:"wethIn",type:"uint256"}],name:"addLiquidity1155",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"addLiquidity1155To(uint256,uint256[],uint256[],uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"minWethIn",type:"uint256"},{internalType:"uint256",name:"wethIn",type:"uint256"},{internalType:"address",name:"to",type:"address"}],name:"addLiquidity1155To",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"addLiquidity721(uint256,uint256[],uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256",name:"minWethIn",type:"uint256"},{internalType:"uint256",name:"wethIn",type:"uint256"}],name:"addLiquidity721",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"addLiquidity721To(uint256,uint256[],uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256",name:"minWethIn",type:"uint256"},{internalType:"uint256",name:"wethIn",type:"uint256"},{internalType:"address",name:"to",type:"address"}],name:"addLiquidity721To",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"lockTime()":{inputs:[],name:"lockTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lockedLPBalance(uint256,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"address",name:"who",type:"address"}],name:"lockedLPBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lockedUntil(uint256,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"address",name:"who",type:"address"}],name:"lockedUntil",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lpStaking()":{inputs:[],name:"lpStaking",outputs:[{internalType:"contract INFTXLPStaking",name:"",type:"address"}],stateMutability:"view",type:"function"},"nftxFactory()":{inputs:[],name:"nftxFactory",outputs:[{internalType:"contract INFTXVaultFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256[]",name:"",type:"uint256[]"},{internalType:"uint256[]",name:"",type:"uint256[]"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC1155BatchReceived",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function"},"onERC1155Received(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC1155Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function"},"onERC721Received(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC721Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"See {IERC721Receiver-onERC721Received}. Always returns `IERC721Receiver.onERC721Received.selector`."},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"pairedToken()":{inputs:[],name:"pairedToken",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setLockTime(uint256)":{inputs:[{internalType:"uint256",name:"newLockTime",type:"uint256"}],name:"setLockTime",outputs:[],stateMutability:"nonpayable",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"sushiRouter()":{inputs:[],name:"sushiRouter",outputs:[{internalType:"contract IUniswapV2Router01",name:"",type:"address"}],stateMutability:"view",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/solidity/other/PalmNFTXStakingZap.sol:ReentrancyGuard":{source:"contracts/solidity/other/PalmNFTXStakingZap.sol",name:"ReentrancyGuard",details:"Contract module that helps prevent reentrant calls to a function. Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier available, which can be applied to functions to make sure there are no nested (reentrant) calls to them. Note that because there is a single `nonReentrant` guard, functions marked as `nonReentrant` may not call one another. This can be worked around by making those functions `private`, and then adding `external` `nonReentrant` entry points to them. TIP: If you would like to learn more about reentrancy and alternative ways to protect against it, check out our blog post https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]."},"contracts/solidity/other/TimelockExcludeList.sol:TimelockExcludeList":{source:"contracts/solidity/other/TimelockExcludeList.sol",name:"TimelockExcludeList",events:{"ExcludeFromAllSet(address,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"",type:"address"},{indexed:!1,internalType:"bool",name:"",type:"bool"}],name:"ExcludeFromAllSet",type:"event"},"ExcludeFromVaultSet(address,uint256,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"",type:"address"},{indexed:!1,internalType:"uint256",name:"",type:"uint256"},{indexed:!1,internalType:"bool",name:"",type:"bool"}],name:"ExcludeFromVaultSet",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"excludeFromAll(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"excludeFromAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"excludeFromVault(address,uint256)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"}],name:"excludeFromVault",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isExcluded(address,uint256)":{inputs:[{internalType:"address",name:"addr",type:"address"},{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"isExcluded",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isExcludedFromAll(address)":{inputs:[{internalType:"address",name:"addr",type:"address"}],name:"isExcludedFromAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isExcludedFromVault(address,uint256)":{inputs:[{internalType:"address",name:"addr",type:"address"},{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"isExcludedFromVault",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setExcludeFromAll(address,bool)":{inputs:[{internalType:"address",name:"addr",type:"address"},{internalType:"bool",name:"setting",type:"bool"}],name:"setExcludeFromAll",outputs:[],stateMutability:"nonpayable",type:"function"},"setExcludeFromVault(address,uint256,bool)":{inputs:[{internalType:"address",name:"addr",type:"address"},{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"bool",name:"setting",type:"bool"}],name:"setExcludeFromVault",outputs:[],stateMutability:"nonpayable",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/solidity/proxy/BeaconProxy.sol:BeaconProxy":{source:"contracts/solidity/proxy/BeaconProxy.sol",name:"BeaconProxy",details:"This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}. The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't conflict with the storage layout of the implementation behind the proxy. _Available since v3.4._",constructor:{inputs:[{internalType:"address",name:"beacon",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],stateMutability:"payable",type:"constructor"},fallback:{stateMutability:"payable",type:"fallback"},receive:{stateMutability:"payable",type:"receive"}},"contracts/solidity/proxy/ClonesUpgradeable.sol:ClonesUpgradeable":{source:"contracts/solidity/proxy/ClonesUpgradeable.sol",name:"ClonesUpgradeable",details:'https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for deploying minimal proxy contracts, also known as "clones". > To simply and cheaply clone contract functionality in an immutable way, this standard specifies > a minimal bytecode implementation that delegates all calls to a known, fixed address. The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2` (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the deterministic method. _Available since v3.4._'},"contracts/solidity/proxy/Create2BeaconProxy.sol:Create2BeaconProxy":{source:"contracts/solidity/proxy/Create2BeaconProxy.sol",name:"Create2BeaconProxy",details:"This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}. Slightly modified to allow using beacon proxies with Create2. The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't conflict with the storage layout of the implementation behind the proxy. _Available since v3.4._",constructor:{inputs:[],stateMutability:"payable",type:"constructor"},fallback:{stateMutability:"payable",type:"fallback"},receive:{stateMutability:"payable",type:"receive"}},"contracts/solidity/proxy/IBeacon.sol:IBeacon":{source:"contracts/solidity/proxy/IBeacon.sol",name:"IBeacon",details:"This is the interface that {BeaconProxy} expects of its beacon.",methods:{"childImplementation()":{inputs:[],name:"childImplementation",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Must return an address that can be used as a delegate call target. {BeaconProxy} will check that this address is a contract."},"upgradeChildTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeChildTo",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/proxy/Initializable.sol:Initializable":{source:"contracts/solidity/proxy/Initializable.sol",name:"Initializable",details:"This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer function so it can only be called once. The {initializer} modifier provided by this contract will have this effect. TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}. CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure that all initializers are idempotent. This is not verified automatically as constructors are by Solidity."},"contracts/solidity/proxy/MultiProxyController.sol:MultiProxyController":{source:"contracts/solidity/proxy/MultiProxyController.sol",name:"MultiProxyController",constructor:{inputs:[{internalType:"string[]",name:"_names",type:"string[]"},{internalType:"address[]",name:"_proxies",type:"address[]"}],stateMutability:"nonpayable",type:"constructor"},events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"ProxyAdded(string,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"string",name:"name",type:"string"},{indexed:!1,internalType:"address",name:"proxy",type:"address"}],name:"ProxyAdded",type:"event"},"ProxyAdminChanged(uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"index",type:"uint256"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"ProxyAdminChanged",type:"event"},"ProxyRemoved(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"index",type:"uint256"}],name:"ProxyRemoved",type:"event"}},methods:{"addProxy(string,address)":{inputs:[{internalType:"string",name:"name",type:"string"},{internalType:"address",name:"proxy",type:"address"}],name:"addProxy",outputs:[],stateMutability:"nonpayable",type:"function"},"changeAllAdmins(address)":{inputs:[{internalType:"address",name:"newAdmin",type:"address"}],name:"changeAllAdmins",outputs:[],stateMutability:"nonpayable",type:"function"},"changeAllAdmins(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"start",type:"uint256"},{internalType:"uint256",name:"count",type:"uint256"},{internalType:"address",name:"newAdmin",type:"address"}],name:"changeAllAdmins",outputs:[],stateMutability:"nonpayable",type:"function"},"changeProxyAdmin(uint256,address)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"address",name:"newAdmin",type:"address"}],name:"changeProxyAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"getAdmin(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"getAdmin",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getAllImpls()":{inputs:[],name:"getAllImpls",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"getAllProxies()":{inputs:[],name:"getAllProxies",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"getAllProxiesInfo()":{inputs:[],name:"getAllProxiesInfo",outputs:[{internalType:"string[]",name:"",type:"string[]"}],stateMutability:"view",type:"function"},"getImpl(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"getImpl",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getName(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"getName",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"removeProxy(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"removeProxy",outputs:[],stateMutability:"nonpayable",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"upgradeProxyTo(uint256,address)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"address",name:"newImpl",type:"address"}],name:"upgradeProxyTo",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/proxy/Proxy.sol:Proxy":{source:"contracts/solidity/proxy/Proxy.sol",name:"Proxy",details:"This abstract contract provides a fallback function that delegates all calls to another contract using the EVM instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to be specified by overriding the virtual {_implementation} function. Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a different contract through the {_delegate} function. The success and return data of the delegated call will be returned back to the caller of the proxy.",fallback:{stateMutability:"payable",type:"fallback"},receive:{stateMutability:"payable",type:"receive"}},"contracts/solidity/proxy/ProxyController.sol:ProxyController":{source:"contracts/solidity/proxy/ProxyController.sol",name:"ProxyController",constructor:{inputs:[{internalType:"address",name:"vaultFactory",type:"address"},{internalType:"address",name:"eligManager",type:"address"},{internalType:"address",name:"stakingProvider",type:"address"},{internalType:"address",name:"staking",type:"address"},{internalType:"address",name:"feeDistrib",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"ImplAddressSet(uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"index",type:"uint256"},{indexed:!1,internalType:"address",name:"impl",type:"address"}],name:"ImplAddressSet",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"ProxyAdminChanged(uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"index",type:"uint256"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"ProxyAdminChanged",type:"event"}},methods:{"changeAllProxyAdmins(address)":{inputs:[{internalType:"address",name:"newAdmin",type:"address"}],name:"changeAllProxyAdmins",outputs:[],stateMutability:"nonpayable",type:"function"},"changeProxyAdmin(uint256,address)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"address",name:"newAdmin",type:"address"}],name:"changeProxyAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"eligManagerImpl()":{inputs:[],name:"eligManagerImpl",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeDistribImpl()":{inputs:[],name:"feeDistribImpl",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"fetchImplAddress(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"fetchImplAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"getAdmin(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"getAdmin",outputs:[{internalType:"address",name:"admin",type:"address"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"stakingImpl()":{inputs:[],name:"stakingImpl",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"stakingProviderImpl()":{inputs:[],name:"stakingProviderImpl",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"upgradeProxyTo(uint256,address)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"address",name:"newImpl",type:"address"}],name:"upgradeProxyTo",outputs:[],stateMutability:"nonpayable",type:"function"},"vaultFactoryImpl()":{inputs:[],name:"vaultFactoryImpl",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/solidity/proxy/ProxyControllerSimple.sol:ProxyControllerSimple":{source:"contracts/solidity/proxy/ProxyControllerSimple.sol",name:"ProxyControllerSimple",constructor:{inputs:[{internalType:"address",name:"_proxy",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"ImplAddressSet(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"impl",type:"address"}],name:"ImplAddressSet",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"ProxyAdminChanged(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"ProxyAdminChanged",type:"event"}},methods:{"changeProxyAdmin(address)":{inputs:[{internalType:"address",name:"newAdmin",type:"address"}],name:"changeProxyAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"fetchImplAddress()":{inputs:[],name:"fetchImplAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"getAdmin()":{inputs:[],name:"getAdmin",outputs:[{internalType:"address",name:"admin",type:"address"}],stateMutability:"view",type:"function"},"impl()":{inputs:[],name:"impl",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"upgradeProxyTo(address)":{inputs:[{internalType:"address",name:"newImpl",type:"address"}],name:"upgradeProxyTo",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/proxy/UpgradeableBeacon.sol:UpgradeableBeacon":{source:"contracts/solidity/proxy/UpgradeableBeacon.sol",name:"UpgradeableBeacon",details:"This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their implementation contract, which is where they will delegate all function calls. An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.",events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"childImplementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the child implementation returned by the beacon is changed."}},methods:{"__UpgradeableBeacon__init(address)":{inputs:[{internalType:"address",name:"childImplementation_",type:"address"}],name:"__UpgradeableBeacon__init",outputs:[],stateMutability:"nonpayable",type:"function",details:"Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the beacon."},"childImplementation()":{inputs:[],name:"childImplementation",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the current child implementation address."},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"upgradeChildTo(address)":{inputs:[{internalType:"address",name:"newChildImplementation",type:"address"}],name:"upgradeChildTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrades the beacon to a new implementation. Emits an {Upgraded} event. Requirements: - msg.sender must be the owner of the contract. - `newChildImplementation` must be a contract."}}},"contracts/solidity/testing/Address.sol:Address":{source:"contracts/solidity/testing/Address.sol",name:"Address",details:"Collection of functions related to the address type"},"contracts/solidity/testing/Context.sol:Context":{source:"contracts/solidity/testing/Context.sol",name:"Context"},"contracts/solidity/testing/CryptoPunks.sol:CryptoPunksMarket":{source:"contracts/solidity/testing/CryptoPunks.sol",name:"CryptoPunksMarket",constructor:{inputs:[],stateMutability:"payable",type:"constructor"},events:{"Assign(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"punkIndex",type:"uint256"}],name:"Assign",type:"event"},"PunkBidEntered(uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"punkIndex",type:"uint256"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"},{indexed:!0,internalType:"address",name:"fromAddress",type:"address"}],name:"PunkBidEntered",type:"event"},"PunkBidWithdrawn(uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"punkIndex",type:"uint256"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"},{indexed:!0,internalType:"address",name:"fromAddress",type:"address"}],name:"PunkBidWithdrawn",type:"event"},"PunkBought(uint256,uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"punkIndex",type:"uint256"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"},{indexed:!0,internalType:"address",name:"fromAddress",type:"address"},{indexed:!0,internalType:"address",name:"toAddress",type:"address"}],name:"PunkBought",type:"event"},"PunkNoLongerForSale(uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"punkIndex",type:"uint256"}],name:"PunkNoLongerForSale",type:"event"},"PunkOffered(uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"punkIndex",type:"uint256"},{indexed:!1,internalType:"uint256",name:"minValue",type:"uint256"},{indexed:!0,internalType:"address",name:"toAddress",type:"address"}],name:"PunkOffered",type:"event"},"PunkTransfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"punkIndex",type:"uint256"}],name:"PunkTransfer",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"acceptBidForPunk(uint256,uint256)":{inputs:[{internalType:"uint256",name:"punkIndex",type:"uint256"},{internalType:"uint256",name:"minPrice",type:"uint256"}],name:"acceptBidForPunk",outputs:[],stateMutability:"nonpayable",type:"function"},"allInitialOwnersAssigned()":{inputs:[],name:"allInitialOwnersAssigned",outputs:[],stateMutability:"nonpayable",type:"function"},"allPunksAssigned()":{inputs:[],name:"allPunksAssigned",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"balanceOf(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"buyPunk(uint256)":{inputs:[{internalType:"uint256",name:"punkIndex",type:"uint256"}],name:"buyPunk",outputs:[],stateMutability:"payable",type:"function"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"enterBidForPunk(uint256)":{inputs:[{internalType:"uint256",name:"punkIndex",type:"uint256"}],name:"enterBidForPunk",outputs:[],stateMutability:"payable",type:"function"},"getPunk(uint256)":{inputs:[{internalType:"uint256",name:"punkIndex",type:"uint256"}],name:"getPunk",outputs:[],stateMutability:"nonpayable",type:"function"},"imageHash()":{inputs:[],name:"imageHash",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"nextPunkIndexToAssign()":{inputs:[],name:"nextPunkIndexToAssign",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"offerPunkForSale(uint256,uint256)":{inputs:[{internalType:"uint256",name:"punkIndex",type:"uint256"},{internalType:"uint256",name:"minSalePriceInWei",type:"uint256"}],name:"offerPunkForSale",outputs:[],stateMutability:"nonpayable",type:"function"},"offerPunkForSaleToAddress(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"punkIndex",type:"uint256"},{internalType:"uint256",name:"minSalePriceInWei",type:"uint256"},{internalType:"address",name:"toAddress",type:"address"}],name:"offerPunkForSaleToAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"pendingWithdrawals(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"pendingWithdrawals",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"punkBids(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"punkBids",outputs:[{internalType:"bool",name:"hasBid",type:"bool"},{internalType:"uint256",name:"punkIndex",type:"uint256"},{internalType:"address",name:"bidder",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],stateMutability:"view",type:"function"},"punkIndexToAddress(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"punkIndexToAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"punkNoLongerForSale(uint256)":{inputs:[{internalType:"uint256",name:"punkIndex",type:"uint256"}],name:"punkNoLongerForSale",outputs:[],stateMutability:"nonpayable",type:"function"},"punksOfferedForSale(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"punksOfferedForSale",outputs:[{internalType:"bool",name:"isForSale",type:"bool"},{internalType:"uint256",name:"punkIndex",type:"uint256"},{internalType:"address",name:"seller",type:"address"},{internalType:"uint256",name:"minValue",type:"uint256"},{internalType:"address",name:"onlySellTo",type:"address"}],stateMutability:"view",type:"function"},"punksRemainingToAssign()":{inputs:[],name:"punksRemainingToAssign",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"setInitialOwner(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"punkIndex",type:"uint256"}],name:"setInitialOwner",outputs:[],stateMutability:"nonpayable",type:"function"},"setInitialOwners(address[],uint256[])":{inputs:[{internalType:"address[]",name:"addresses",type:"address[]"},{internalType:"uint256[]",name:"indices",type:"uint256[]"}],name:"setInitialOwners",outputs:[],stateMutability:"nonpayable",type:"function"},"standard()":{inputs:[],name:"standard",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transferPunk(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"punkIndex",type:"uint256"}],name:"transferPunk",outputs:[],stateMutability:"nonpayable",type:"function"},"withdraw()":{inputs:[],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"},"withdrawBidForPunk(uint256)":{inputs:[{internalType:"uint256",name:"punkIndex",type:"uint256"}],name:"withdrawBidForPunk",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/testing/DummyToken.sol:DummyToken":{source:"contracts/solidity/testing/DummyToken.sol",name:"DummyToken",constructor:{inputs:[{internalType:"string",name:"_name",type:"string"},{internalType:"string",name:"_symbol",type:"string"}],stateMutability:"nonpayable",type:"constructor"},methods:{"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"}}},"contracts/solidity/testing/DummyXToken.sol:DummyXToken":{source:"contracts/solidity/testing/DummyXToken.sol",name:"DummyXToken",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"burnFrom(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burnFrom",outputs:[],stateMutability:"nonpayable",type:"function"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless this function is overridden; NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."}}},"contracts/solidity/testing/ERC1155.sol:ERC1155":{source:"contracts/solidity/testing/ERC1155.sol",name:"ERC1155",details:"Implementation of the basic standard multi-token. See https://eips.ethereum.org/EIPS/eip-1155 Originally based on code by Enjin: https://github.com/enjin/erc-1155 _Available since v3.1._",constructor:{inputs:[{internalType:"string",name:"uri_",type:"string"}],stateMutability:"nonpayable",type:"constructor"},events:{"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"TransferBatch(address,address,address,uint256[],uint256[])":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256[]",name:"ids",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"values",type:"uint256[]"}],name:"TransferBatch",type:"event"},"TransferSingle(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"id",type:"uint256"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"TransferSingle",type:"event"},"URI(string,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"string",name:"value",type:"string"},{indexed:!0,internalType:"uint256",name:"id",type:"uint256"}],name:"URI",type:"event"}},methods:{"balanceOf(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"id",type:"uint256"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address."},"balanceOfBatch(address[],uint256[])":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"},{internalType:"uint256[]",name:"ids",type:"uint256[]"}],name:"balanceOfBatch",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",details:"See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC1155-isApprovedForAll}."},"publicMint(address,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"publicMint",outputs:[],stateMutability:"nonpayable",type:"function"},"publicMintBatch(address,uint256[],uint256[])":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],name:"publicMintBatch",outputs:[],stateMutability:"nonpayable",type:"function"},"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeBatchTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC1155-safeBatchTransferFrom}."},"safeTransferFrom(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC1155-safeTransferFrom}."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC1155-setApprovalForAll}."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"uri(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"uri",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\\{id\\}` substring with the actual token type ID."}}},"contracts/solidity/testing/ERC1155Receiver.sol:ERC1155Receiver":{source:"contracts/solidity/testing/ERC1155Receiver.sol",name:"ERC1155Receiver",details:"_Available since v3.1._",methods:{"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"from",type:"address"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes",name:"data",type:"bytes"}],name:"onERC1155BatchReceived",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:'Handles the receipt of a multiple ERC1155 token types. This function is called at the end of a `safeBatchTransferFrom` after the balances have been updated. To accept the transfer(s), this must return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` (i.e. 0xbc197c81, or its own function selector).',params:{data:"Additional data with no specified format",from:"The address which previously owned the token",ids:"An array containing ids of each token being transferred (order and length must match values array)",operator:"The address which initiated the batch transfer (i.e. msg.sender)",values:"An array containing amounts of each token being transferred (order and length must match ids array)"},returns:{_0:'`bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed'}},"onERC1155Received(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"from",type:"address"},{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"onERC1155Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:'Handles the receipt of a single ERC1155 token type. This function is called at the end of a `safeTransferFrom` after the balance has been updated. To accept the transfer, this must return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` (i.e. 0xf23a6e61, or its own function selector).',params:{data:"Additional data with no specified format",from:"The address which previously owned the token",id:"The ID of the token being transferred",operator:"The address which initiated the transfer (i.e. msg.sender)",value:"The amount of tokens being transferred"},returns:{_0:'`bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed'}},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."}}},"contracts/solidity/testing/ERC165.sol:ERC165":{source:"contracts/solidity/testing/ERC165.sol",name:"ERC165",details:"Implementation of the {IERC165} interface. Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check for the additional interface id that will be supported. For example: ```solidity function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId); } ``` Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.",methods:{"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."}}},"contracts/solidity/testing/ERC721.sol:ERC721":{source:"contracts/solidity/testing/ERC721.sol",name:"ERC721",details:"Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including the Metadata extension, but not including the Enumerable extension, which is available separately as {ERC721Enumerable}.",constructor:{inputs:[{internalType:"string",name:"name_",type:"string"},{internalType:"string",name:"symbol_",type:"string"}],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-approve}."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721-balanceOf}."},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"See {IERC721-getApproved}."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC721-isApprovedForAll}."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721Metadata-name}."},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"See {IERC721-ownerOf}."},"publicMint(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"publicMint",outputs:[],stateMutability:"nonpayable",type:"function"},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-safeTransferFrom}."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-safeTransferFrom}."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-setApprovalForAll}."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721Metadata-symbol}."},"tokenURI(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721Metadata-tokenURI}."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-transferFrom}."}}},"contracts/solidity/testing/EnumerableMap.sol:EnumerableMap":{source:"contracts/solidity/testing/EnumerableMap.sol",name:"EnumerableMap",details:"Library for managing an enumerable variant of Solidity's https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`] type. Maps have the following properties: - Entries are added, removed, and checked for existence in constant time (O(1)). - Entries are enumerated in O(n). No guarantees are made on the ordering. ``` contract Example {     // Add the library methods     using EnumerableMap for EnumerableMap.UintToAddressMap;     // Declare a set state variable     EnumerableMap.UintToAddressMap private myMap; } ``` As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are supported."},"contracts/solidity/testing/EnumerableSet.sol:EnumerableSet":{source:"contracts/solidity/testing/EnumerableSet.sol",name:"EnumerableSet",details:"Library for managing https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive types. Sets have the following properties: - Elements are added, removed, and checked for existence in constant time (O(1)). - Elements are enumerated in O(n). No guarantees are made on the ordering. ``` contract Example {     // Add the library methods     using EnumerableSet for EnumerableSet.AddressSet;     // Declare a set state variable     EnumerableSet.AddressSet private mySet; } ``` As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) and `uint256` (`UintSet`) are supported."},"contracts/solidity/testing/FlashBorrower.sol:FlashBorrower":{source:"contracts/solidity/testing/FlashBorrower.sol",name:"FlashBorrower",methods:{"flashBalance()":{inputs:[],name:"flashBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"flashBorrow(address,address,uint256)":{inputs:[{internalType:"address",name:"lender",type:"address"},{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"flashBorrow",outputs:[],stateMutability:"nonpayable",type:"function"},"flashBorrowAndReenter(address,address,uint256)":{inputs:[{internalType:"address",name:"lender",type:"address"},{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"flashBorrowAndReenter",outputs:[],stateMutability:"nonpayable",type:"function"},"flashBorrowAndSteal(address,address,uint256)":{inputs:[{internalType:"address",name:"lender",type:"address"},{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"flashBorrowAndSteal",outputs:[],stateMutability:"nonpayable",type:"function"},"flashFee()":{inputs:[],name:"flashFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"flashToken()":{inputs:[],name:"flashToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"flashUser()":{inputs:[],name:"flashUser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"flashValue()":{inputs:[],name:"flashValue",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"onFlashLoan(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"user",type:"address"},{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"fee",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"onFlashLoan",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"nonpayable",type:"function",details:"ERC-3156 Flash loan callback"}}},"contracts/solidity/testing/IERC1155.sol:IERC1155":{source:"contracts/solidity/testing/IERC1155.sol",name:"IERC1155",details:"Required interface of an ERC1155 compliant contract, as defined in the https://eips.ethereum.org/EIPS/eip-1155[EIP]. _Available since v3.1._",events:{"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event",details:"Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to `approved`."},"TransferBatch(address,address,address,uint256[],uint256[])":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256[]",name:"ids",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"values",type:"uint256[]"}],name:"TransferBatch",type:"event",details:"Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all transfers."},"TransferSingle(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"id",type:"uint256"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"TransferSingle",type:"event",details:"Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`."},"URI(string,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"string",name:"value",type:"string"},{indexed:!0,internalType:"uint256",name:"id",type:"uint256"}],name:"URI",type:"event",details:"Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI. If an {URI} event was emitted for `id`, the standard https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value returned by {IERC1155MetadataURI-uri}."}},methods:{"balanceOf(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"id",type:"uint256"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens of token type `id` owned by `account`. Requirements: - `account` cannot be the zero address."},"balanceOfBatch(address[],uint256[])":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"},{internalType:"uint256[]",name:"ids",type:"uint256[]"}],name:"balanceOfBatch",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",details:"xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}. Requirements: - `accounts` and `ids` must have the same length."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if `operator` is approved to transfer ``account``'s tokens. See {setApprovalForAll}."},"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeBatchTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}. Emits a {TransferBatch} event. Requirements: - `ids` and `amounts` must have the same length. - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value."},"safeTransferFrom(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers `amount` tokens of token type `id` from `from` to `to`. Emits a {TransferSingle} event. Requirements: - `to` cannot be the zero address. - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}. - `from` must have a balance of tokens of type `id` of at least `amount`. - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`, Emits an {ApprovalForAll} event. Requirements: - `operator` cannot be the caller."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."}}},"contracts/solidity/testing/IERC1155MetadataURI.sol:IERC1155MetadataURI":{source:"contracts/solidity/testing/IERC1155MetadataURI.sol",name:"IERC1155MetadataURI",details:"Interface of the optional ERC1155MetadataExtension interface, as defined in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP]. _Available since v3.1._",events:{"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"TransferBatch(address,address,address,uint256[],uint256[])":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256[]",name:"ids",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"values",type:"uint256[]"}],name:"TransferBatch",type:"event"},"TransferSingle(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"id",type:"uint256"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"TransferSingle",type:"event"},"URI(string,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"string",name:"value",type:"string"},{indexed:!0,internalType:"uint256",name:"id",type:"uint256"}],name:"URI",type:"event"}},methods:{"balanceOf(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"id",type:"uint256"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens of token type `id` owned by `account`. Requirements: - `account` cannot be the zero address."},"balanceOfBatch(address[],uint256[])":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"},{internalType:"uint256[]",name:"ids",type:"uint256[]"}],name:"balanceOfBatch",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",details:"xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}. Requirements: - `accounts` and `ids` must have the same length."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if `operator` is approved to transfer ``account``'s tokens. See {setApprovalForAll}."},"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeBatchTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}. Emits a {TransferBatch} event. Requirements: - `ids` and `amounts` must have the same length. - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value."},"safeTransferFrom(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers `amount` tokens of token type `id` from `from` to `to`. Emits a {TransferSingle} event. Requirements: - `to` cannot be the zero address. - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}. - `from` must have a balance of tokens of type `id` of at least `amount`. - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`, Emits an {ApprovalForAll} event. Requirements: - `operator` cannot be the caller."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"uri(uint256)":{inputs:[{internalType:"uint256",name:"id",type:"uint256"}],name:"uri",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the URI for token type `id`. If the `\\{id\\}` substring is present in the URI, it must be replaced by clients with the actual token type ID."}}},"contracts/solidity/testing/IERC1155Receiver.sol:IERC1155Receiver":{source:"contracts/solidity/testing/IERC1155Receiver.sol",name:"IERC1155Receiver",notice:"_Available since v3.1._",methods:{"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"from",type:"address"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes",name:"data",type:"bytes"}],name:"onERC1155BatchReceived",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:'Handles the receipt of a multiple ERC1155 token types. This function is called at the end of a `safeBatchTransferFrom` after the balances have been updated. To accept the transfer(s), this must return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` (i.e. 0xbc197c81, or its own function selector).',params:{data:"Additional data with no specified format",from:"The address which previously owned the token",ids:"An array containing ids of each token being transferred (order and length must match values array)",operator:"The address which initiated the batch transfer (i.e. msg.sender)",values:"An array containing amounts of each token being transferred (order and length must match ids array)"},returns:{_0:'`bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed'}},"onERC1155Received(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"from",type:"address"},{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"onERC1155Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:'Handles the receipt of a single ERC1155 token type. This function is called at the end of a `safeTransferFrom` after the balance has been updated. To accept the transfer, this must return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` (i.e. 0xf23a6e61, or its own function selector).',params:{data:"Additional data with no specified format",from:"The address which previously owned the token",id:"The ID of the token being transferred",operator:"The address which initiated the transfer (i.e. msg.sender)",value:"The amount of tokens being transferred"},returns:{_0:'`bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed'}},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."}}},"contracts/solidity/testing/IERC165.sol:IERC165":{source:"contracts/solidity/testing/IERC165.sol",name:"IERC165",details:"Interface of the ERC165 standard, as defined in the https://eips.ethereum.org/EIPS/eip-165[EIP]. Implementers can declare support of contract interfaces, which can then be queried by others ({ERC165Checker}). For an implementation, see {ERC165}.",methods:{"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."}}},"contracts/solidity/testing/IERC721.sol:IERC721":{source:"contracts/solidity/testing/IERC721.sol",name:"IERC721",details:"Required interface of an ERC721 compliant contract.",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when `owner` enables `approved` to manage the `tokenId` token."},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event",details:"Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets."},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `tokenId` token is transferred from `from` to `to`."}},methods:{"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred. Only a single account can be approved at a time, so approving the zero address clears previous approvals. Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist. Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"balance",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of tokens in ``owner``'s account."},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"operator",type:"address"}],stateMutability:"view",type:"function",details:"Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns if the `operator` is allowed to manage all of the assets of `owner`. See {setApprovalForAll}"},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"owner",type:"address"}],stateMutability:"view",type:"function",details:"Returns the owner of the `tokenId` token. Requirements: - `tokenId` must exist."},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"_approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"Approve or remove `operator` as an operator for the caller. Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller. Requirements: - The `operator` cannot be the caller. Emits an {ApprovalForAll} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers `tokenId` token from `from` to `to`. WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. Emits a {Transfer} event."}}},"contracts/solidity/testing/IERC721Enumerable.sol:IERC721Enumerable":{source:"contracts/solidity/testing/IERC721Enumerable.sol",name:"IERC721Enumerable",title:"ERC-721 Non-Fungible Token Standard, optional enumeration extension",details:"See https://eips.ethereum.org/EIPS/eip-721",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred. Only a single account can be approved at a time, so approving the zero address clears previous approvals. Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist. Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"balance",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of tokens in ``owner``'s account."},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"operator",type:"address"}],stateMutability:"view",type:"function",details:"Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns if the `operator` is allowed to manage all of the assets of `owner`. See {setApprovalForAll}"},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"owner",type:"address"}],stateMutability:"view",type:"function",details:"Returns the owner of the `tokenId` token. Requirements: - `tokenId` must exist."},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"_approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"Approve or remove `operator` as an operator for the caller. Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller. Requirements: - The `operator` cannot be the caller. Emits an {ApprovalForAll} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"tokenByIndex(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenByIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns a token ID at a given `index` of all the tokens stored by the contract. Use along with {totalSupply} to enumerate all tokens."},"tokenOfOwnerByIndex(address,uint256)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenOfOwnerByIndex",outputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns a token ID owned by `owner` at a given `index` of its token list. Use along with {balanceOf} to enumerate all of ``owner``'s tokens."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the total amount of tokens stored by the contract."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers `tokenId` token from `from` to `to`. WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. Emits a {Transfer} event."}}},"contracts/solidity/testing/IERC721Metadata.sol:IERC721Metadata":{source:"contracts/solidity/testing/IERC721Metadata.sol",name:"IERC721Metadata",title:"ERC-721 Non-Fungible Token Standard, optional metadata extension",details:"See https://eips.ethereum.org/EIPS/eip-721",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred. Only a single account can be approved at a time, so approving the zero address clears previous approvals. Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist. Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"balance",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of tokens in ``owner``'s account."},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"operator",type:"address"}],stateMutability:"view",type:"function",details:"Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns if the `operator` is allowed to manage all of the assets of `owner`. See {setApprovalForAll}"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the token collection name."},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"owner",type:"address"}],stateMutability:"view",type:"function",details:"Returns the owner of the `tokenId` token. Requirements: - `tokenId` must exist."},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"_approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"Approve or remove `operator` as an operator for the caller. Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller. Requirements: - The `operator` cannot be the caller. Emits an {ApprovalForAll} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the token collection symbol."},"tokenURI(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the Uniform Resource Identifier (URI) for `tokenId` token."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers `tokenId` token from `from` to `to`. WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. Emits a {Transfer} event."}}},"contracts/solidity/testing/IERC721Receiver.sol:IERC721Receiver":{source:"contracts/solidity/testing/IERC721Receiver.sol",name:"IERC721Receiver",title:"ERC721 token receiver interface",details:"Interface for any contract that wants to support safeTransfers from ERC721 asset contracts.",methods:{"onERC721Received(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"from",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"onERC721Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom} by `operator` from `from`, this function is called. It must return its Solidity selector to confirm the token transfer. If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted. The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`."}}},"contracts/solidity/testing/MockDistributor.sol:MockDistributor":{source:"contracts/solidity/testing/MockDistributor.sol",name:"MockDistributor",events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"__MockDistributor_init()":{inputs:[],name:"__MockDistributor_init",outputs:[],stateMutability:"nonpayable",type:"function"},"distribute(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function"},"initializeVaultReceivers(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"initializeVaultReceivers",outputs:[],stateMutability:"nonpayable",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"withdrawTokens(address)":{inputs:[{internalType:"address",name:"token",type:"address"}],name:"withdrawTokens",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/testing/MockStakingProvider.sol:MockStakingProvider":{source:"contracts/solidity/testing/MockStakingProvider.sol",name:"MockStakingProvider",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"nameForStakingToken(address)":{inputs:[{internalType:"address",name:"_vaultToken",type:"address"}],name:"nameForStakingToken",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setChanged(bool)":{inputs:[{internalType:"bool",name:"_changed",type:"bool"}],name:"setChanged",outputs:[],stateMutability:"nonpayable",type:"function"},"stakingTokenForVaultToken(address)":{inputs:[{internalType:"address",name:"_vaultToken",type:"address"}],name:"stakingTokenForVaultToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/solidity/testing/MockVault.sol:MockVault":{source:"contracts/solidity/testing/MockVault.sol",name:"MockVault",constructor:{inputs:[{internalType:"address",name:"_assetAddress",type:"address"},{internalType:"bool",name:"_is1155",type:"bool"}],stateMutability:"nonpayable",type:"constructor"},methods:{"assetAddress()":{inputs:[],name:"assetAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"is1155()":{inputs:[],name:"is1155",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"mintTo(uint256[],uint256[],address)":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"address",name:"to",type:"address"}],name:"mintTo",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"onERC721Received(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC721Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"See {IERC721Receiver-onERC721Received}. Always returns `IERC721Receiver.onERC721Received.selector`."}}},"contracts/solidity/testing/NFTXEligibilityManager2.sol:NFTXEligibilityManager2":{source:"contracts/solidity/testing/NFTXEligibilityManager2.sol",name:"NFTXEligibilityManager2",events:{"ModuleAdded(address,address,string,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"implementation",type:"address"},{indexed:!1,internalType:"address",name:"targetAsset",type:"address"},{indexed:!1,internalType:"string",name:"name",type:"string"},{indexed:!1,internalType:"bool",name:"finalizedOnDeploy",type:"bool"}],name:"ModuleAdded",type:"event"},"ModuleUpdated(address,string,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"implementation",type:"address"},{indexed:!1,internalType:"string",name:"name",type:"string"},{indexed:!1,internalType:"bool",name:"finalizedOnDeploy",type:"bool"}],name:"ModuleUpdated",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"__NFTXEligibilityManager_init()":{inputs:[],name:"__NFTXEligibilityManager_init",outputs:[],stateMutability:"nonpayable",type:"function"},"addModule(address)":{inputs:[{internalType:"address",name:"implementation",type:"address"}],name:"addModule",outputs:[],stateMutability:"nonpayable",type:"function"},"allModuleNames()":{inputs:[],name:"allModuleNames",outputs:[{internalType:"string[]",name:"",type:"string[]"}],stateMutability:"view",type:"function"},"allModules()":{inputs:[],name:"allModules",outputs:[{components:[{internalType:"address",name:"implementation",type:"address"},{internalType:"address",name:"targetAsset",type:"address"},{internalType:"string",name:"name",type:"string"}],internalType:"struct NFTXEligibilityManager.EligibilityModule[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function"},"deployEligibility(uint256,bytes)":{inputs:[{internalType:"uint256",name:"moduleIndex",type:"uint256"},{internalType:"bytes",name:"configData",type:"bytes"}],name:"deployEligibility",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"},"modules(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"modules",outputs:[{internalType:"address",name:"implementation",type:"address"},{internalType:"address",name:"targetAsset",type:"address"},{internalType:"string",name:"name",type:"string"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"sum(uint256,uint256)":{inputs:[{internalType:"uint256",name:"a",type:"uint256"},{internalType:"uint256",name:"b",type:"uint256"}],name:"sum",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"updateModule(uint256,address)":{inputs:[{internalType:"uint256",name:"moduleIndex",type:"uint256"},{internalType:"address",name:"implementation",type:"address"}],name:"updateModule",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/testing/NFTXLPStaking2.sol:NFTXLPStaking2":{source:"contracts/solidity/testing/NFTXLPStaking2.sol",name:"NFTXLPStaking2",events:{"FeesReceived(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"FeesReceived",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"PoolCreated(uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"address",name:"pool",type:"address"}],name:"PoolCreated",type:"event"},"PoolUpdated(uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"address",name:"pool",type:"address"}],name:"PoolUpdated",type:"event"},"SetIsGuardian(address,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"addr",type:"address"},{indexed:!1,internalType:"bool",name:"isGuardian",type:"bool"}],name:"SetIsGuardian",type:"event"},"SetPaused(uint256,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"lockId",type:"uint256"},{indexed:!1,internalType:"bool",name:"paused",type:"bool"}],name:"SetPaused",type:"event"}},methods:{"__NFTXLPStaking__init(address)":{inputs:[{internalType:"address",name:"_stakingTokenProvider",type:"address"}],name:"__NFTXLPStaking__init",outputs:[],stateMutability:"nonpayable",type:"function"},"_oldRewardDistributionTokenAddr((address,address))":{inputs:[{components:[{internalType:"address",name:"stakingToken",type:"address"},{internalType:"address",name:"rewardToken",type:"address"}],internalType:"struct NFTXLPStaking.StakingPool",name:"pool",type:"tuple"}],name:"_oldRewardDistributionTokenAddr",outputs:[{internalType:"contract IRewardDistributionToken",name:"",type:"address"}],stateMutability:"view",type:"function"},"_rewardDistributionTokenAddr((address,address))":{inputs:[{components:[{internalType:"address",name:"stakingToken",type:"address"},{internalType:"address",name:"rewardToken",type:"address"}],internalType:"struct NFTXLPStaking.StakingPool",name:"pool",type:"tuple"}],name:"_rewardDistributionTokenAddr",outputs:[{internalType:"contract TimelockRewardDistributionTokenImpl",name:"",type:"address"}],stateMutability:"view",type:"function"},"_unusedRewardDistributionTokenAddr((address,address))":{inputs:[{components:[{internalType:"address",name:"stakingToken",type:"address"},{internalType:"address",name:"rewardToken",type:"address"}],internalType:"struct NFTXLPStaking.StakingPool",name:"pool",type:"tuple"}],name:"_unusedRewardDistributionTokenAddr",outputs:[{internalType:"contract IRewardDistributionToken",name:"",type:"address"}],stateMutability:"view",type:"function"},"addPoolForVault(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"addPoolForVault",outputs:[],stateMutability:"nonpayable",type:"function"},"balanceOf(uint256,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"address",name:"addr",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimMultipleRewards(uint256[])":{inputs:[{internalType:"uint256[]",name:"vaultIds",type:"uint256[]"}],name:"claimMultipleRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"claimRewards(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"claimRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"deposit(uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function"},"emergencyExit(address,address)":{inputs:[{internalType:"address",name:"_stakingToken",type:"address"},{internalType:"address",name:"_rewardToken",type:"address"}],name:"emergencyExit",outputs:[],stateMutability:"nonpayable",type:"function"},"emergencyExitAndClaim(address,address)":{inputs:[{internalType:"address",name:"_stakingToken",type:"address"},{internalType:"address",name:"_rewardToken",type:"address"}],name:"emergencyExitAndClaim",outputs:[],stateMutability:"nonpayable",type:"function"},"emergencyMigrate(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"emergencyMigrate",outputs:[],stateMutability:"nonpayable",type:"function"},"exit(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"exit",outputs:[],stateMutability:"nonpayable",type:"function"},"isGuardian(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isGuardian",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isPaused(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"isPaused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"lockedLPBalance(uint256,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"address",name:"who",type:"address"}],name:"lockedLPBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lockedUntil(uint256,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"address",name:"who",type:"address"}],name:"lockedUntil",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"newRewardDistributionToken(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"newRewardDistributionToken",outputs:[{internalType:"contract TimelockRewardDistributionTokenImpl",name:"",type:"address"}],stateMutability:"view",type:"function"},"newTimelockRewardDistTokenImpl()":{inputs:[],name:"newTimelockRewardDistTokenImpl",outputs:[{internalType:"contract TimelockRewardDistributionTokenImpl",name:"",type:"address"}],stateMutability:"view",type:"function"},"nftxVaultFactory()":{inputs:[],name:"nftxVaultFactory",outputs:[{internalType:"contract INFTXVaultFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"oldBalanceOf(uint256,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"address",name:"addr",type:"address"}],name:"oldBalanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"oldRewardDistributionToken(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"oldRewardDistributionToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"onlyOwnerIfPaused(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"onlyOwnerIfPaused",outputs:[],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"pause(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function"},"receiveRewards(uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"receiveRewards",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"retrieveTokens(uint256,uint256,address,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"}],name:"retrieveTokens",outputs:[],stateMutability:"nonpayable",type:"function"},"rewardDistTokenImpl()":{inputs:[],name:"rewardDistTokenImpl",outputs:[{internalType:"contract IRewardDistributionToken",name:"",type:"address"}],stateMutability:"view",type:"function"},"rewardDistributionToken(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"rewardDistributionToken",outputs:[{internalType:"contract IRewardDistributionToken",name:"",type:"address"}],stateMutability:"view",type:"function"},"rewardDistributionTokenAddr(address,address)":{inputs:[{internalType:"address",name:"stakedToken",type:"address"},{internalType:"address",name:"rewardToken",type:"address"}],name:"rewardDistributionTokenAddr",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"setIsGuardian(address,bool)":{inputs:[{internalType:"address",name:"addr",type:"address"},{internalType:"bool",name:"_isGuardian",type:"bool"}],name:"setIsGuardian",outputs:[],stateMutability:"nonpayable",type:"function"},"setNFTXVaultFactory(address)":{inputs:[{internalType:"address",name:"newFactory",type:"address"}],name:"setNFTXVaultFactory",outputs:[],stateMutability:"nonpayable",type:"function"},"setStakingTokenProvider(address)":{inputs:[{internalType:"address",name:"newProvider",type:"address"}],name:"setStakingTokenProvider",outputs:[],stateMutability:"nonpayable",type:"function"},"stakingTokenProvider()":{inputs:[],name:"stakingTokenProvider",outputs:[{internalType:"contract StakingTokenProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"sum(uint256,uint256)":{inputs:[{internalType:"uint256",name:"a",type:"uint256"},{internalType:"uint256",name:"b",type:"uint256"}],name:"sum",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"timelockDepositFor(uint256,address,uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"timelockLength",type:"uint256"}],name:"timelockDepositFor",outputs:[],stateMutability:"nonpayable",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"unpause(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function"},"unusedBalanceOf(uint256,address)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"address",name:"addr",type:"address"}],name:"unusedBalanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"unusedRewardDistributionToken(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"unusedRewardDistributionToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"updatePoolForVault(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"updatePoolForVault",outputs:[],stateMutability:"nonpayable",type:"function"},"updatePoolForVaults(uint256[])":{inputs:[{internalType:"uint256[]",name:"vaultIds",type:"uint256[]"}],name:"updatePoolForVaults",outputs:[],stateMutability:"nonpayable",type:"function"},"vaultStakingInfo(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"vaultStakingInfo",outputs:[{internalType:"address",name:"stakingToken",type:"address"},{internalType:"address",name:"rewardToken",type:"address"}],stateMutability:"view",type:"function"},"withdraw(uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/testing/NFTXVaultFactoryUpgradeable2.sol:NFTXVaultFactoryUpgradeable2":{source:"contracts/solidity/testing/NFTXVaultFactoryUpgradeable2.sol",name:"NFTXVaultFactoryUpgradeable2",events:{"DisableVaultFees(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"vaultId",type:"uint256"}],name:"DisableVaultFees",type:"event"},"FeeExclusion(address,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"feeExcluded",type:"address"},{indexed:!1,internalType:"bool",name:"excluded",type:"bool"}],name:"FeeExclusion",type:"event"},"NewEligibilityManager(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldEligManager",type:"address"},{indexed:!1,internalType:"address",name:"newEligManager",type:"address"}],name:"NewEligibilityManager",type:"event"},"NewFeeDistributor(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldDistributor",type:"address"},{indexed:!1,internalType:"address",name:"newDistributor",type:"address"}],name:"NewFeeDistributor",type:"event"},"NewVault(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"address",name:"vaultAddress",type:"address"},{indexed:!1,internalType:"address",name:"assetAddress",type:"address"}],name:"NewVault",type:"event"},"NewZapContract(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldZap",type:"address"},{indexed:!1,internalType:"address",name:"newZap",type:"address"}],name:"NewZapContract",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"SetIsGuardian(address,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"addr",type:"address"},{indexed:!1,internalType:"bool",name:"isGuardian",type:"bool"}],name:"SetIsGuardian",type:"event"},"SetPaused(uint256,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"lockId",type:"uint256"},{indexed:!1,internalType:"bool",name:"paused",type:"bool"}],name:"SetPaused",type:"event"},"UpdateFactoryFees(uint256,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"mintFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"randomRedeemFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"targetRedeemFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"randomSwapFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"targetSwapFee",type:"uint256"}],name:"UpdateFactoryFees",type:"event"},"UpdateVaultFees(uint256,uint256,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"mintFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"randomRedeemFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"targetRedeemFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"randomSwapFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"targetSwapFee",type:"uint256"}],name:"UpdateVaultFees",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"childImplementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"__NFTXVaultFactory_init(address,address)":{inputs:[{internalType:"address",name:"_vaultImpl",type:"address"},{internalType:"address",name:"_feeDistributor",type:"address"}],name:"__NFTXVaultFactory_init",outputs:[],stateMutability:"nonpayable",type:"function"},"__UpgradeableBeacon__init(address)":{inputs:[{internalType:"address",name:"childImplementation_",type:"address"}],name:"__UpgradeableBeacon__init",outputs:[],stateMutability:"nonpayable",type:"function",details:"Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the beacon."},"allVaults()":{inputs:[],name:"allVaults",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"childImplementation()":{inputs:[],name:"childImplementation",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the current child implementation address."},"createVault(string,string,address,bool,bool)":{inputs:[{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"symbol",type:"string"},{internalType:"address",name:"_assetAddress",type:"address"},{internalType:"bool",name:"is1155",type:"bool"},{internalType:"bool",name:"allowAllItems",type:"bool"}],name:"createVault",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"disableVaultFees(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"disableVaultFees",outputs:[],stateMutability:"nonpayable",type:"function"},"eligibilityManager()":{inputs:[],name:"eligibilityManager",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"excludedFromFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"excludedFromFees",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"factoryMintFee()":{inputs:[],name:"factoryMintFee",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function"},"factoryRandomRedeemFee()":{inputs:[],name:"factoryRandomRedeemFee",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function"},"factoryRandomSwapFee()":{inputs:[],name:"factoryRandomSwapFee",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function"},"factoryTargetRedeemFee()":{inputs:[],name:"factoryTargetRedeemFee",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function"},"factoryTargetSwapFee()":{inputs:[],name:"factoryTargetSwapFee",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function"},"feeDistributor()":{inputs:[],name:"feeDistributor",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"isGuardian(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isGuardian",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isLocked(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"isLocked",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isPaused(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"isPaused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"numVaults()":{inputs:[],name:"numVaults",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"onlyOwnerIfPaused(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"onlyOwnerIfPaused",outputs:[],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"pause(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setEligibilityManager(address)":{inputs:[{internalType:"address",name:"_eligibilityManager",type:"address"}],name:"setEligibilityManager",outputs:[],stateMutability:"nonpayable",type:"function"},"setFactoryFees(uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"mintFee",type:"uint256"},{internalType:"uint256",name:"randomRedeemFee",type:"uint256"},{internalType:"uint256",name:"targetRedeemFee",type:"uint256"},{internalType:"uint256",name:"randomSwapFee",type:"uint256"},{internalType:"uint256",name:"targetSwapFee",type:"uint256"}],name:"setFactoryFees",outputs:[],stateMutability:"nonpayable",type:"function"},"setFeeDistributor(address)":{inputs:[{internalType:"address",name:"_feeDistributor",type:"address"}],name:"setFeeDistributor",outputs:[],stateMutability:"nonpayable",type:"function"},"setFeeExclusion(address,bool)":{inputs:[{internalType:"address",name:"_excludedAddr",type:"address"},{internalType:"bool",name:"excluded",type:"bool"}],name:"setFeeExclusion",outputs:[],stateMutability:"nonpayable",type:"function"},"setIsGuardian(address,bool)":{inputs:[{internalType:"address",name:"addr",type:"address"},{internalType:"bool",name:"_isGuardian",type:"bool"}],name:"setIsGuardian",outputs:[],stateMutability:"nonpayable",type:"function"},"setVaultFees(uint256,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"mintFee",type:"uint256"},{internalType:"uint256",name:"randomRedeemFee",type:"uint256"},{internalType:"uint256",name:"targetRedeemFee",type:"uint256"},{internalType:"uint256",name:"randomSwapFee",type:"uint256"},{internalType:"uint256",name:"targetSwapFee",type:"uint256"}],name:"setVaultFees",outputs:[],stateMutability:"nonpayable",type:"function"},"setZapContract(address)":{inputs:[{internalType:"address",name:"_zapContract",type:"address"}],name:"setZapContract",outputs:[],stateMutability:"nonpayable",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"twiceNumVaults()":{inputs:[],name:"twiceNumVaults",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"unpause(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function"},"upgradeChildTo(address)":{inputs:[{internalType:"address",name:"newChildImplementation",type:"address"}],name:"upgradeChildTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrades the beacon to a new implementation. Emits an {Upgraded} event. Requirements: - msg.sender must be the owner of the contract. - `newChildImplementation` must be a contract."},"vault(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"vault",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"vaultFees(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"vaultFees",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"vaultsForAsset(address)":{inputs:[{internalType:"address",name:"assetAddress",type:"address"}],name:"vaultsForAsset",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"zapContract()":{inputs:[],name:"zapContract",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/solidity/testing/SafeMath.sol:SafeMath":{source:"contracts/solidity/testing/SafeMath.sol",name:"SafeMath",details:"Wrappers over Solidity's arithmetic operations with added overflow checks. Arithmetic operations in Solidity wrap on overflow. This can easily result in bugs, because programmers usually assume that an overflow raises an error, which is the standard behavior in high level programming languages. `SafeMath` restores this intuition by reverting the transaction when an operation overflows. Using this library instead of the unchecked operations eliminates an entire class of bugs, so it's recommended to use it always."},"contracts/solidity/testing/Strings.sol:Strings":{source:"contracts/solidity/testing/Strings.sol",name:"Strings",details:"String operations."},"contracts/solidity/testing/TestUpgrade.sol:TestFactoryUpgrade":{source:"contracts/solidity/testing/TestUpgrade.sol",name:"TestFactoryUpgrade",events:{"DisableVaultFees(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"vaultId",type:"uint256"}],name:"DisableVaultFees",type:"event"},"FeeExclusion(address,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"feeExcluded",type:"address"},{indexed:!1,internalType:"bool",name:"excluded",type:"bool"}],name:"FeeExclusion",type:"event"},"NewEligibilityManager(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldEligManager",type:"address"},{indexed:!1,internalType:"address",name:"newEligManager",type:"address"}],name:"NewEligibilityManager",type:"event"},"NewFeeDistributor(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldDistributor",type:"address"},{indexed:!1,internalType:"address",name:"newDistributor",type:"address"}],name:"NewFeeDistributor",type:"event"},"NewVault(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"address",name:"vaultAddress",type:"address"},{indexed:!1,internalType:"address",name:"assetAddress",type:"address"}],name:"NewVault",type:"event"},"NewZapContract(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldZap",type:"address"},{indexed:!1,internalType:"address",name:"newZap",type:"address"}],name:"NewZapContract",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"SetIsGuardian(address,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"addr",type:"address"},{indexed:!1,internalType:"bool",name:"isGuardian",type:"bool"}],name:"SetIsGuardian",type:"event"},"SetPaused(uint256,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"lockId",type:"uint256"},{indexed:!1,internalType:"bool",name:"paused",type:"bool"}],name:"SetPaused",type:"event"},"UpdateFactoryFees(uint256,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"mintFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"randomRedeemFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"targetRedeemFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"randomSwapFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"targetSwapFee",type:"uint256"}],name:"UpdateFactoryFees",type:"event"},"UpdateVaultFees(uint256,uint256,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"mintFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"randomRedeemFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"targetRedeemFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"randomSwapFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"targetSwapFee",type:"uint256"}],name:"UpdateVaultFees",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"childImplementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"__NFTXVaultFactory_init(address,address)":{inputs:[{internalType:"address",name:"_vaultImpl",type:"address"},{internalType:"address",name:"_feeDistributor",type:"address"}],name:"__NFTXVaultFactory_init",outputs:[],stateMutability:"nonpayable",type:"function"},"__UpgradeableBeacon__init(address)":{inputs:[{internalType:"address",name:"childImplementation_",type:"address"}],name:"__UpgradeableBeacon__init",outputs:[],stateMutability:"nonpayable",type:"function",details:"Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the beacon."},"allVaults()":{inputs:[],name:"allVaults",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"childImplementation()":{inputs:[],name:"childImplementation",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the current child implementation address."},"createVault(string,string,address,bool,bool)":{inputs:[{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"symbol",type:"string"},{internalType:"address",name:"_assetAddress",type:"address"},{internalType:"bool",name:"is1155",type:"bool"},{internalType:"bool",name:"allowAllItems",type:"bool"}],name:"createVault",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"disableVaultFees(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"disableVaultFees",outputs:[],stateMutability:"nonpayable",type:"function"},"eligibilityManager()":{inputs:[],name:"eligibilityManager",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"excludedFromFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"excludedFromFees",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"factoryMintFee()":{inputs:[],name:"factoryMintFee",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function"},"factoryRandomRedeemFee()":{inputs:[],name:"factoryRandomRedeemFee",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function"},"factoryRandomSwapFee()":{inputs:[],name:"factoryRandomSwapFee",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function"},"factoryTargetRedeemFee()":{inputs:[],name:"factoryTargetRedeemFee",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function"},"factoryTargetSwapFee()":{inputs:[],name:"factoryTargetSwapFee",outputs:[{internalType:"uint64",name:"",type:"uint64"}],stateMutability:"view",type:"function"},"feeDistributor()":{inputs:[],name:"feeDistributor",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"isGuardian(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isGuardian",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isLocked(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"isLocked",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isPaused(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"isPaused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isUpgraded()":{inputs:[],name:"isUpgraded",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"pure",type:"function"},"numVaults()":{inputs:[],name:"numVaults",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"onlyOwnerIfPaused(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"onlyOwnerIfPaused",outputs:[],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"pause(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setEligibilityManager(address)":{inputs:[{internalType:"address",name:"_eligibilityManager",type:"address"}],name:"setEligibilityManager",outputs:[],stateMutability:"nonpayable",type:"function"},"setFactoryFees(uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"mintFee",type:"uint256"},{internalType:"uint256",name:"randomRedeemFee",type:"uint256"},{internalType:"uint256",name:"targetRedeemFee",type:"uint256"},{internalType:"uint256",name:"randomSwapFee",type:"uint256"},{internalType:"uint256",name:"targetSwapFee",type:"uint256"}],name:"setFactoryFees",outputs:[],stateMutability:"nonpayable",type:"function"},"setFeeDistributor(address)":{inputs:[{internalType:"address",name:"_feeDistributor",type:"address"}],name:"setFeeDistributor",outputs:[],stateMutability:"nonpayable",type:"function"},"setFeeExclusion(address,bool)":{inputs:[{internalType:"address",name:"_excludedAddr",type:"address"},{internalType:"bool",name:"excluded",type:"bool"}],name:"setFeeExclusion",outputs:[],stateMutability:"nonpayable",type:"function"},"setIsGuardian(address,bool)":{inputs:[{internalType:"address",name:"addr",type:"address"},{internalType:"bool",name:"_isGuardian",type:"bool"}],name:"setIsGuardian",outputs:[],stateMutability:"nonpayable",type:"function"},"setVaultFees(uint256,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"mintFee",type:"uint256"},{internalType:"uint256",name:"randomRedeemFee",type:"uint256"},{internalType:"uint256",name:"targetRedeemFee",type:"uint256"},{internalType:"uint256",name:"randomSwapFee",type:"uint256"},{internalType:"uint256",name:"targetSwapFee",type:"uint256"}],name:"setVaultFees",outputs:[],stateMutability:"nonpayable",type:"function"},"setZapContract(address)":{inputs:[{internalType:"address",name:"_zapContract",type:"address"}],name:"setZapContract",outputs:[],stateMutability:"nonpayable",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"unpause(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function"},"upgradeChildTo(address)":{inputs:[{internalType:"address",name:"newChildImplementation",type:"address"}],name:"upgradeChildTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrades the beacon to a new implementation. Emits an {Upgraded} event. Requirements: - msg.sender must be the owner of the contract. - `newChildImplementation` must be a contract."},"vault(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"vault",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"vaultFees(uint256)":{inputs:[{internalType:"uint256",name:"vaultId",type:"uint256"}],name:"vaultFees",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"vaultsForAsset(address)":{inputs:[{internalType:"address",name:"assetAddress",type:"address"}],name:"vaultsForAsset",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"zapContract()":{inputs:[],name:"zapContract",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/solidity/testing/TestVaultUpgrade.sol:TestVaultUpgrade":{source:"contracts/solidity/testing/TestVaultUpgrade.sol",name:"TestVaultUpgrade",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"EligibilityDeployed(uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"moduleIndex",type:"uint256"},{indexed:!1,internalType:"address",name:"eligibilityAddr",type:"address"}],name:"EligibilityDeployed",type:"event"},"EnableMintUpdated(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"enabled",type:"bool"}],name:"EnableMintUpdated",type:"event"},"EnableRandomRedeemUpdated(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"enabled",type:"bool"}],name:"EnableRandomRedeemUpdated",type:"event"},"EnableRandomSwapUpdated(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"enabled",type:"bool"}],name:"EnableRandomSwapUpdated",type:"event"},"EnableTargetRedeemUpdated(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"enabled",type:"bool"}],name:"EnableTargetRedeemUpdated",type:"event"},"EnableTargetSwapUpdated(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"enabled",type:"bool"}],name:"EnableTargetSwapUpdated",type:"event"},"ManagerSet(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"manager",type:"address"}],name:"ManagerSet",type:"event"},"MetaDataChange(string,string,string,string)":{anonymous:!1,inputs:[{indexed:!1,internalType:"string",name:"oldName",type:"string"},{indexed:!1,internalType:"string",name:"oldSymbol",type:"string"},{indexed:!1,internalType:"string",name:"newName",type:"string"},{indexed:!1,internalType:"string",name:"newSymbol",type:"string"}],name:"MetaDataChange",type:"event"},"Minted(uint256[],uint256[],address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256[]",name:"nftIds",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"amounts",type:"uint256[]"},{indexed:!1,internalType:"address",name:"to",type:"address"}],name:"Minted",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Redeemed(uint256[],uint256[],address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256[]",name:"nftIds",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"specificIds",type:"uint256[]"},{indexed:!1,internalType:"address",name:"to",type:"address"}],name:"Redeemed",type:"event"},"Swapped(uint256[],uint256[],uint256[],uint256[],address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256[]",name:"nftIds",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"amounts",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"specificIds",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"redeemedIds",type:"uint256[]"},{indexed:!1,internalType:"address",name:"to",type:"address"}],name:"Swapped",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"},"VaultInit(uint256,address,bool,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"vaultId",type:"uint256"},{indexed:!1,internalType:"address",name:"assetAddress",type:"address"},{indexed:!1,internalType:"bool",name:"is1155",type:"bool"},{indexed:!1,internalType:"bool",name:"allowAllItems",type:"bool"}],name:"VaultInit",type:"event"},"VaultShutdown(address,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"assetAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"numItems",type:"uint256"},{indexed:!1,internalType:"address",name:"recipient",type:"address"}],name:"VaultShutdown",type:"event"}},methods:{"__NFTXVault_init(string,string,address,bool,bool)":{inputs:[{internalType:"string",name:"_name",type:"string"},{internalType:"string",name:"_symbol",type:"string"},{internalType:"address",name:"_assetAddress",type:"address"},{internalType:"bool",name:"_is1155",type:"bool"},{internalType:"bool",name:"_allowAllItems",type:"bool"}],name:"__NFTXVault_init",outputs:[],stateMutability:"nonpayable",type:"function"},"allHoldings()":{inputs:[],name:"allHoldings",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function"},"allValidNFTs(uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"}],name:"allValidNFTs",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"allowAllItems()":{inputs:[],name:"allowAllItems",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"assetAddress()":{inputs:[],name:"assetAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless this function is overridden; NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"deployEligibilityStorage(uint256,bytes)":{inputs:[{internalType:"uint256",name:"moduleIndex",type:"uint256"},{internalType:"bytes",name:"initData",type:"bytes"}],name:"deployEligibilityStorage",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"},"disableVaultFees()":{inputs:[],name:"disableVaultFees",outputs:[],stateMutability:"nonpayable",type:"function"},"eligibilityStorage()":{inputs:[],name:"eligibilityStorage",outputs:[{internalType:"contract INFTXEligibility",name:"",type:"address"}],stateMutability:"view",type:"function"},"enableMint()":{inputs:[],name:"enableMint",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"enableRandomRedeem()":{inputs:[],name:"enableRandomRedeem",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"enableRandomSwap()":{inputs:[],name:"enableRandomSwap",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"enableTargetRedeem()":{inputs:[],name:"enableTargetRedeem",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"enableTargetSwap()":{inputs:[],name:"enableTargetSwap",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"finalizeVault()":{inputs:[],name:"finalizeVault",outputs:[],stateMutability:"nonpayable",type:"function"},"flashFee(address,uint256)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"flashFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the fee applied when doing flash loans. By default this implementation has 0 fees. This function can be overloaded to make the flash loan mechanism deflationary.",params:{amount:"The amount of tokens to be loaned.",token:"The token to be flash loaned."},returns:{_0:"The fees applied to the corresponding flash loan."}},"flashLoan(address,address,uint256,bytes)":{inputs:[{internalType:"contract IERC3156FlashBorrowerUpgradeable",name:"receiver",type:"address"},{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"flashLoan",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Performs a flash loan. New tokens are minted and sent to the `receiver`, who is required to implement the {IERC3156FlashBorrower} interface. By the end of the flash loan, the receiver is expected to own amount + fee tokens and have them approved back to the token contract itself so they can be burned.",params:{amount:"The amount of tokens to be loaned.",data:"An arbitrary datafield that is passed to the receiver.",receiver:"The receiver of the flash loan. Should implement the {IERC3156FlashBorrower.onFlashLoan} interface.",token:"The token to be flash loaned. Only `address(this)` is supported."},returns:{_0:"`true` is the flash loan was successfull."}},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"is1155()":{inputs:[],name:"is1155",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isUpgraded()":{inputs:[],name:"isUpgraded",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"pure",type:"function"},"manager()":{inputs:[],name:"manager",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxFlashLoan(address)":{inputs:[{internalType:"address",name:"token",type:"address"}],name:"maxFlashLoan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the maximum amount of tokens available for loan.",params:{token:"The address of the token that is requested."},returns:{_0:"The amont of token that can be loaned."}},"mint(uint256[],uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],name:"mint",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"mintFee()":{inputs:[],name:"mintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mintTo(uint256[],uint256[],address)":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"address",name:"to",type:"address"}],name:"mintTo",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"nftIdAt(uint256)":{inputs:[{internalType:"uint256",name:"holdingsIndex",type:"uint256"}],name:"nftIdAt",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256[]",name:"",type:"uint256[]"},{internalType:"uint256[]",name:"",type:"uint256[]"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC1155BatchReceived",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function"},"onERC1155Received(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC1155Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function"},"onERC721Received(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC721Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"See {IERC721Receiver-onERC721Received}. Always returns `IERC721Receiver.onERC721Received.selector`."},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"randomRedeemFee()":{inputs:[],name:"randomRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"randomSwapFee()":{inputs:[],name:"randomSwapFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeem(uint256,uint256[])":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256[]",name:"specificIds",type:"uint256[]"}],name:"redeem",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"redeemTo(uint256,uint256[],address)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256[]",name:"specificIds",type:"uint256[]"},{internalType:"address",name:"to",type:"address"}],name:"redeemTo",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"retrieveTokens(uint256,address,address)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"}],name:"retrieveTokens",outputs:[],stateMutability:"nonpayable",type:"function"},"setFees(uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_mintFee",type:"uint256"},{internalType:"uint256",name:"_randomRedeemFee",type:"uint256"},{internalType:"uint256",name:"_targetRedeemFee",type:"uint256"},{internalType:"uint256",name:"_randomSwapFee",type:"uint256"},{internalType:"uint256",name:"_targetSwapFee",type:"uint256"}],name:"setFees",outputs:[],stateMutability:"nonpayable",type:"function"},"setManager(address)":{inputs:[{internalType:"address",name:"_manager",type:"address"}],name:"setManager",outputs:[],stateMutability:"nonpayable",type:"function"},"setVaultFeatures(bool,bool,bool,bool,bool)":{inputs:[{internalType:"bool",name:"_enableMint",type:"bool"},{internalType:"bool",name:"_enableRandomRedeem",type:"bool"},{internalType:"bool",name:"_enableTargetRedeem",type:"bool"},{internalType:"bool",name:"_enableRandomSwap",type:"bool"},{internalType:"bool",name:"_enableTargetSwap",type:"bool"}],name:"setVaultFeatures",outputs:[],stateMutability:"nonpayable",type:"function"},"setVaultMetadata(string,string)":{inputs:[{internalType:"string",name:"name_",type:"string"},{internalType:"string",name:"symbol_",type:"string"}],name:"setVaultMetadata",outputs:[],stateMutability:"nonpayable",type:"function"},"shutdown(address)":{inputs:[{internalType:"address",name:"recipient",type:"address"}],name:"shutdown",outputs:[],stateMutability:"nonpayable",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"swap(uint256[],uint256[],uint256[])":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256[]",name:"specificIds",type:"uint256[]"}],name:"swap",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"swapTo(uint256[],uint256[],uint256[],address)":{inputs:[{internalType:"uint256[]",name:"tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256[]",name:"specificIds",type:"uint256[]"},{internalType:"address",name:"to",type:"address"}],name:"swapTo",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"targetRedeemFee()":{inputs:[],name:"targetRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"targetSwapFee()":{inputs:[],name:"targetSwapFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalHoldings()":{inputs:[],name:"totalHoldings",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"vaultFactory()":{inputs:[],name:"vaultFactory",outputs:[{internalType:"contract INFTXVaultFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"vaultFees()":{inputs:[],name:"vaultFees",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"vaultId()":{inputs:[],name:"vaultId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"version()":{inputs:[],name:"version",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"}}},"contracts/solidity/token/ERC1155HolderUpgradeable.sol:ERC1155HolderUpgradeable":{source:"contracts/solidity/token/ERC1155HolderUpgradeable.sol",name:"ERC1155HolderUpgradeable",details:"_Available since v3.1._",methods:{"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256[]",name:"",type:"uint256[]"},{internalType:"uint256[]",name:"",type:"uint256[]"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC1155BatchReceived",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function"},"onERC1155Received(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC1155Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."}}},"contracts/solidity/token/ERC1155ReceiverUpgradeable.sol:ERC1155ReceiverUpgradeable":{source:"contracts/solidity/token/ERC1155ReceiverUpgradeable.sol",name:"ERC1155ReceiverUpgradeable",details:"_Available since v3.1._",methods:{"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"from",type:"address"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes",name:"data",type:"bytes"}],name:"onERC1155BatchReceived",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:'Handles the receipt of a multiple ERC1155 token types. This function is called at the end of a `safeBatchTransferFrom` after the balances have been updated. To accept the transfer(s), this must return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` (i.e. 0xbc197c81, or its own function selector).',params:{data:"Additional data with no specified format",from:"The address which previously owned the token",ids:"An array containing ids of each token being transferred (order and length must match values array)",operator:"The address which initiated the batch transfer (i.e. msg.sender)",values:"An array containing amounts of each token being transferred (order and length must match ids array)"},returns:{_0:'`bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed'}},"onERC1155Received(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"from",type:"address"},{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"onERC1155Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:'Handles the receipt of a single ERC1155 token type. This function is called at the end of a `safeTransferFrom` after the balance has been updated. To accept the transfer, this must return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` (i.e. 0xf23a6e61, or its own function selector).',params:{data:"Additional data with no specified format",from:"The address which previously owned the token",id:"The ID of the token being transferred",operator:"The address which initiated the transfer (i.e. msg.sender)",value:"The amount of tokens being transferred"},returns:{_0:'`bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed'}},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."}}},"contracts/solidity/token/ERC1155SafeHolderUpgradeable.sol:ERC1155SafeHolderUpgradeable":{source:"contracts/solidity/token/ERC1155SafeHolderUpgradeable.sol",name:"ERC1155SafeHolderUpgradeable",details:"_Available since v3.1._",methods:{"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256[]",name:"",type:"uint256[]"},{internalType:"uint256[]",name:"",type:"uint256[]"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC1155BatchReceived",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function"},"onERC1155Received(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC1155Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."}}},"contracts/solidity/token/ERC20FlashMintUpgradeable.sol:ERC20FlashMintUpgradeable":{source:"contracts/solidity/token/ERC20FlashMintUpgradeable.sol",name:"ERC20FlashMintUpgradeable",details:"Implementation of the ERC3156 Flash loans extension, as defined in https://eips.ethereum.org/EIPS/eip-3156[ERC-3156]. Adds the {flashLoan} method, which provides flash loan support at the token level. By default there is no fee, but this can be changed by overriding {flashFee}.",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless this function is overridden; NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"flashFee(address,uint256)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"flashFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the fee applied when doing flash loans. By default this implementation has 0 fees. This function can be overloaded to make the flash loan mechanism deflationary.",params:{amount:"The amount of tokens to be loaned.",token:"The token to be flash loaned."},returns:{_0:"The fees applied to the corresponding flash loan."}},"flashLoan(address,address,uint256,bytes)":{inputs:[{internalType:"contract IERC3156FlashBorrowerUpgradeable",name:"receiver",type:"address"},{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"flashLoan",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Performs a flash loan. New tokens are minted and sent to the `receiver`, who is required to implement the {IERC3156FlashBorrower} interface. By the end of the flash loan, the receiver is expected to own amount + fee tokens and have them approved back to the token contract itself so they can be burned.",params:{amount:"The amount of tokens to be loaned.",data:"An arbitrary datafield that is passed to the receiver.",receiver:"The receiver of the flash loan. Should implement the {IERC3156FlashBorrower.onFlashLoan} interface.",token:"The token to be flash loaned. Only `address(this)` is supported."},returns:{_0:"`true` is the flash loan was successfull."}},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"maxFlashLoan(address)":{inputs:[{internalType:"address",name:"token",type:"address"}],name:"maxFlashLoan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the maximum amount of tokens available for loan.",params:{token:"The address of the token that is requested."},returns:{_0:"The amont of token that can be loaned."}},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."}}},"contracts/solidity/token/ERC20Upgradeable.sol:ERC20Upgradeable":{source:"contracts/solidity/token/ERC20Upgradeable.sol",name:"ERC20Upgradeable",details:"Implementation of the {IERC20} interface. This implementation is agnostic to the way tokens are created. This means that a supply mechanism has to be added in a derived contract using {_mint}. For a generic mechanism see {ERC20PresetMinterPauser}. TIP: For a detailed writeup see our guide https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How to implement supply mechanisms]. We have followed general OpenZeppelin guidelines: functions revert instead of returning `false` on failure. This behavior is nonetheless conventional and does not conflict with the expectations of ERC20 applications. Additionally, an {Approval} event is emitted on calls to {transferFrom}. This allows applications to reconstruct the allowance for all accounts just by listening to said events. Other implementations of the EIP may not emit these events, as it isn't required by the specification. Finally, the non-standard {decreaseAllowance} and {increaseAllowance} functions have been added to mitigate the well-known issues around setting allowances. See {IERC20-approve}.",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless this function is overridden; NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."}}},"contracts/solidity/token/ERC721HolderUpgradeable.sol:ERC721HolderUpgradeable":{source:"contracts/solidity/token/ERC721HolderUpgradeable.sol",name:"ERC721HolderUpgradeable",details:"Implementation of the {IERC721Receiver} interface. Accepts all token transfers. Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.",methods:{"onERC721Received(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC721Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"See {IERC721Receiver-onERC721Received}. Always returns `IERC721Receiver.onERC721Received.selector`."}}},"contracts/solidity/token/ERC721SafeHolderUpgradeable.sol:ERC721SafeHolderUpgradeable":{source:"contracts/solidity/token/ERC721SafeHolderUpgradeable.sol",name:"ERC721SafeHolderUpgradeable",details:"Implementation of the {IERC721Receiver} interface. Accepts all token transfers. Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.",methods:{"onERC721Received(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC721Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"See {IERC721Receiver-onERC721Received}. Always returns `IERC721Receiver.onERC721Received.selector`."}}},"contracts/solidity/token/IERC1155ReceiverUpgradeable.sol:IERC1155ReceiverUpgradeable":{source:"contracts/solidity/token/IERC1155ReceiverUpgradeable.sol",name:"IERC1155ReceiverUpgradeable",details:"_Available since v3.1._",methods:{"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"from",type:"address"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes",name:"data",type:"bytes"}],name:"onERC1155BatchReceived",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:'Handles the receipt of a multiple ERC1155 token types. This function is called at the end of a `safeBatchTransferFrom` after the balances have been updated. To accept the transfer(s), this must return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` (i.e. 0xbc197c81, or its own function selector).',params:{data:"Additional data with no specified format",from:"The address which previously owned the token",ids:"An array containing ids of each token being transferred (order and length must match values array)",operator:"The address which initiated the batch transfer (i.e. msg.sender)",values:"An array containing amounts of each token being transferred (order and length must match ids array)"},returns:{_0:'`bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed'}},"onERC1155Received(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"from",type:"address"},{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"onERC1155Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:'Handles the receipt of a single ERC1155 token type. This function is called at the end of a `safeTransferFrom` after the balance has been updated. To accept the transfer, this must return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` (i.e. 0xf23a6e61, or its own function selector).',params:{data:"Additional data with no specified format",from:"The address which previously owned the token",id:"The ID of the token being transferred",operator:"The address which initiated the transfer (i.e. msg.sender)",value:"The amount of tokens being transferred"},returns:{_0:'`bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed'}},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."}}},"contracts/solidity/token/IERC1155Upgradeable.sol:IERC1155Upgradeable":{source:"contracts/solidity/token/IERC1155Upgradeable.sol",name:"IERC1155Upgradeable",details:"Required interface of an ERC1155 compliant contract, as defined in the https://eips.ethereum.org/EIPS/eip-1155[EIP]. _Available since v3.1._",events:{"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event",details:"Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to `approved`."},"TransferBatch(address,address,address,uint256[],uint256[])":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256[]",name:"ids",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"values",type:"uint256[]"}],name:"TransferBatch",type:"event",details:"Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all transfers."},"TransferSingle(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"id",type:"uint256"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"TransferSingle",type:"event",details:"Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`."},"URI(string,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"string",name:"value",type:"string"},{indexed:!0,internalType:"uint256",name:"id",type:"uint256"}],name:"URI",type:"event",details:"Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI. If an {URI} event was emitted for `id`, the standard https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value returned by {IERC1155MetadataURI-uri}."}},methods:{"balanceOf(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"id",type:"uint256"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens of token type `id` owned by `account`. Requirements: - `account` cannot be the zero address."},"balanceOfBatch(address[],uint256[])":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"},{internalType:"uint256[]",name:"ids",type:"uint256[]"}],name:"balanceOfBatch",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",details:"xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}. Requirements: - `accounts` and `ids` must have the same length."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if `operator` is approved to transfer ``account``'s tokens. See {setApprovalForAll}."},"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeBatchTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}. Emits a {TransferBatch} event. Requirements: - `ids` and `amounts` must have the same length. - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value."},"safeTransferFrom(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers `amount` tokens of token type `id` from `from` to `to`. Emits a {TransferSingle} event. Requirements: - `to` cannot be the zero address. - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}. - `from` must have a balance of tokens of type `id` of at least `amount`. - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`, Emits an {ApprovalForAll} event. Requirements: - `operator` cannot be the caller."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."}}},"contracts/solidity/token/IERC20Metadata.sol:IERC20Metadata":{source:"contracts/solidity/token/IERC20Metadata.sol",name:"IERC20Metadata",details:"Interface for the optional metadata functions from the ERC20 standard. _Available since v4.1._",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the decimals places of the token."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}}},"contracts/solidity/token/IERC20Upgradeable.sol:IERC20Upgradeable":{source:"contracts/solidity/token/IERC20Upgradeable.sol",name:"IERC20Upgradeable",details:"Interface of the ERC20 standard as defined in the EIP.",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}}},"contracts/solidity/token/IERC721Enumerable.sol:IERC721Enumerable":{source:"contracts/solidity/token/IERC721Enumerable.sol",name:"IERC721Enumerable",title:"ERC-721 Non-Fungible Token Standard, optional enumeration extension",details:"See https://eips.ethereum.org/EIPS/eip-721",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred. Only a single account can be approved at a time, so approving the zero address clears previous approvals. Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist. Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"balance",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of tokens in ``owner``'s account."},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"operator",type:"address"}],stateMutability:"view",type:"function",details:"Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns if the `operator` is allowed to manage all of the assets of `owner`. See {setApprovalForAll}"},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"owner",type:"address"}],stateMutability:"view",type:"function",details:"Returns the owner of the `tokenId` token. Requirements: - `tokenId` must exist."},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"_approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"Approve or remove `operator` as an operator for the caller. Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller. Requirements: - The `operator` cannot be the caller. Emits an {ApprovalForAll} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"tokenByIndex(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenByIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns a token ID at a given `index` of all the tokens stored by the contract. Use along with {totalSupply} to enumerate all tokens."},"tokenOfOwnerByIndex(address,uint256)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenOfOwnerByIndex",outputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns a token ID owned by `owner` at a given `index` of its token list. Use along with {balanceOf} to enumerate all of ``owner``'s tokens."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the total amount of tokens stored by the contract."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers `tokenId` token from `from` to `to`. WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. Emits a {Transfer} event."}}},"contracts/solidity/token/IERC721ReceiverUpgradeable.sol:IERC721ReceiverUpgradeable":{source:"contracts/solidity/token/IERC721ReceiverUpgradeable.sol",name:"IERC721ReceiverUpgradeable",title:"ERC721 token receiver interface",details:"Interface for any contract that wants to support safeTransfers from ERC721 asset contracts.",methods:{"onERC721Received(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"from",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"onERC721Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom} by `operator` from `from`, this function is called. It must return its Solidity selector to confirm the token transfer. If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted. The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`."}}},"contracts/solidity/token/IERC721Upgradeable.sol:IERC721Upgradeable":{source:"contracts/solidity/token/IERC721Upgradeable.sol",name:"IERC721Upgradeable",details:"Required interface of an ERC721 compliant contract.",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when `owner` enables `approved` to manage the `tokenId` token."},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event",details:"Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets."},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `tokenId` token is transferred from `from` to `to`."}},methods:{"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred. Only a single account can be approved at a time, so approving the zero address clears previous approvals. Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist. Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"balance",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of tokens in ``owner``'s account."},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"operator",type:"address"}],stateMutability:"view",type:"function",details:"Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns if the `operator` is allowed to manage all of the assets of `owner`. See {setApprovalForAll}"},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"owner",type:"address"}],stateMutability:"view",type:"function",details:"Returns the owner of the `tokenId` token. Requirements: - `tokenId` must exist."},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"_approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"Approve or remove `operator` as an operator for the caller. Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller. Requirements: - The `operator` cannot be the caller. Emits an {ApprovalForAll} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers `tokenId` token from `from` to `to`. WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. Emits a {Transfer} event."}}},"contracts/solidity/token/IWETH.sol:IWETH":{source:"contracts/solidity/token/IWETH.sol",name:"IWETH",methods:{"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"deposit()":{inputs:[],name:"deposit",outputs:[],stateMutability:"payable",type:"function"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/token/RewardDistributionTokenUpgradeable.sol:RewardDistributionTokenUpgradeable":{source:"contracts/solidity/token/RewardDistributionTokenUpgradeable.sol",name:"RewardDistributionTokenUpgradeable",title:"Reward-Paying Token (renamed from Dividend)",author:"Roger Wu (https://github.com/roger-wu)",details:"A mintable ERC20 token that allows anyone to pay and distribute a target token  to token holders as dividends and allows token holders to withdraw their dividends.  Reference: the source code of PoWH3D: https://etherscan.io/address/0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe#code",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"RewardWithdrawn(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"weiAmount",type:"uint256"}],name:"RewardWithdrawn",type:"event",details:"This event MUST emit when an address withdraws their dividend.",params:{to:"The address which withdraws target from this contract.",weiAmount:"The amount of withdrawn target in wei."}},"RewardsDistributed(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!1,internalType:"uint256",name:"weiAmount",type:"uint256"}],name:"RewardsDistributed",type:"event",details:"This event MUST emit when target is distributed to token holders.",params:{from:"The address which sends target to this contract.",weiAmount:"The amount of distributed target in wei."}},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"__RewardDistributionToken_init(address,string,string)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_target",type:"address"},{internalType:"string",name:"_name",type:"string"},{internalType:"string",name:"_symbol",type:"string"}],name:"__RewardDistributionToken_init",outputs:[],stateMutability:"nonpayable",type:"function"},"accumulativeRewardOf(address)":{inputs:[{internalType:"address",name:"_owner",type:"address"}],name:"accumulativeRewardOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"accumulativeRewardOf(_owner) = withdrawableRewardOf(_owner) + withdrawnRewardOf(_owner) = (magnifiedRewardPerShare * balanceOf(_owner) + magnifiedRewardCorrections[_owner]) / magnitude",params:{_owner:"The address of a token holder."},returns:{_0:"The amount of dividend in wei that `_owner` has earned in total."},notice:"View the amount of dividend in wei that an address has earned in total."},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"burnFrom(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burnFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Destroys `amount` tokens from `account`, deducting from the caller's allowance. See {ERC20-_burn} and {ERC20-allowance}. Requirements: - the caller must have allowance for ``accounts``'s tokens of at least `amount`."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless this function is overridden; NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"distributeRewards(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"distributeRewards",outputs:[],stateMutability:"nonpayable",type:"function",details:"It reverts if the total supply of tokens is 0. It emits the `RewardsDistributed` event if the amount of received target is greater than 0. About undistributed target tokens:   In each distribution, there is a small amount of target not distributed,     the magnified amount of which is     `(amount * magnitude) % totalSupply()`.   With a well-chosen `magnitude`, the amount of undistributed target     (de-magnified) in a distribution can be less than 1 wei.   We can actually keep track of the undistributed target in a distribution     and try to distribute it in the next distribution,     but keeping track of such data on-chain costs much more than     the saved target, so we don't do that.",notice:"Distributes target to token holders as dividends."},"dividendOf(address)":{inputs:[{internalType:"address",name:"_owner",type:"address"}],name:"dividendOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_owner:"The address of a token holder."},returns:{_0:"The amount of dividend in wei that `_owner` can withdraw."},notice:"View the amount of dividend in wei that an address can withdraw."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"mint(address,address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"target()":{inputs:[],name:"target",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"withdrawReward(address)":{inputs:[{internalType:"address",name:"user",type:"address"}],name:"withdrawReward",outputs:[],stateMutability:"nonpayable",type:"function",details:"It emits a `RewardWithdrawn` event if the amount of withdrawn target is greater than 0.",notice:"Withdraws the target distributed to the sender."},"withdrawnRewardOf(address)":{inputs:[{internalType:"address",name:"_owner",type:"address"}],name:"withdrawnRewardOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_owner:"The address of a token holder."},returns:{_0:"The amount of dividend in wei that `_owner` has withdrawn."},notice:"View the amount of dividend in wei that an address has withdrawn."}}},"contracts/solidity/token/TimelockRewardDistributionTokenImpl.sol:TimelockRewardDistributionTokenImpl":{source:"contracts/solidity/token/TimelockRewardDistributionTokenImpl.sol",name:"TimelockRewardDistributionTokenImpl",title:"Reward-Paying Token (renamed from Dividend)",author:"Roger Wu (https://github.com/roger-wu)",details:"A mintable ERC20 token that allows anyone to pay and distribute a target token  to token holders as dividends and allows token holders to withdraw their dividends.  Reference: the source code of PoWH3D: https://etherscan.io/address/0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe#code",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"RewardWithdrawn(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"weiAmount",type:"uint256"}],name:"RewardWithdrawn",type:"event",details:"This event MUST emit when an address withdraws their dividend.",params:{to:"The address which withdraws target from this contract.",weiAmount:"The amount of withdrawn target in wei."}},"RewardsDistributed(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!1,internalType:"uint256",name:"weiAmount",type:"uint256"}],name:"RewardsDistributed",type:"event",details:"This event MUST emit when target is distributed to token holders.",params:{from:"The address which sends target to this contract.",weiAmount:"The amount of distributed target in wei."}},"Timelocked(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"until",type:"uint256"}],name:"Timelocked",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"__TimelockRewardDistributionToken_init(address,string,string)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_target",type:"address"},{internalType:"string",name:"_name",type:"string"},{internalType:"string",name:"_symbol",type:"string"}],name:"__TimelockRewardDistributionToken_init",outputs:[],stateMutability:"nonpayable",type:"function"},"accumulativeRewardOf(address)":{inputs:[{internalType:"address",name:"_owner",type:"address"}],name:"accumulativeRewardOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"accumulativeRewardOf(_owner) = withdrawableRewardOf(_owner) + withdrawnRewardOf(_owner) = (magnifiedRewardPerShare * balanceOf(_owner) + magnifiedRewardCorrections[_owner]) / magnitude",params:{_owner:"The address of a token holder."},returns:{_0:"The amount of dividend in wei that `_owner` has earned in total."},notice:"View the amount of dividend in wei that an address has earned in total."},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"burnFrom(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burnFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Destroys `amount` tokens from `account`, without deducting from the caller's allowance. Dangerous. See {ERC20-_burn} and {ERC20-allowance}."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless this function is overridden; NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"distributeRewards(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"distributeRewards",outputs:[],stateMutability:"nonpayable",type:"function",details:"It reverts if the total supply of tokens is 0. It emits the `RewardsDistributed` event if the amount of received target is greater than 0. About undistributed target tokens:   In each distribution, there is a small amount of target not distributed,     the magnified amount of which is     `(amount * magnitude) % totalSupply()`.   With a well-chosen `magnitude`, the amount of undistributed target     (de-magnified) in a distribution can be less than 1 wei.   We can actually keep track of the undistributed target in a distribution     and try to distribute it in the next distribution,     but keeping track of such data on-chain costs much more than     the saved target, so we don't do that.",notice:"Distributes target to token holders as dividends."},"dividendOf(address)":{inputs:[{internalType:"address",name:"_owner",type:"address"}],name:"dividendOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_owner:"The address of a token holder."},returns:{_0:"The amount of dividend in wei that `_owner` can withdraw."},notice:"View the amount of dividend in wei that an address can withdraw."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"target()":{inputs:[],name:"target",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"timelockMint(address,uint256,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"timelockLength",type:"uint256"}],name:"timelockMint",outputs:[],stateMutability:"nonpayable",type:"function"},"timelockUntil(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"timelockUntil",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"withdrawReward(address)":{inputs:[{internalType:"address",name:"user",type:"address"}],name:"withdrawReward",outputs:[],stateMutability:"nonpayable",type:"function",details:"It emits a `RewardWithdrawn` event if the amount of withdrawn target is greater than 0.",notice:"Withdraws the target distributed to the sender."},"withdrawnRewardOf(address)":{inputs:[{internalType:"address",name:"_owner",type:"address"}],name:"withdrawnRewardOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_owner:"The address of a token holder."},returns:{_0:"The amount of dividend in wei that `_owner` has withdrawn."},notice:"View the amount of dividend in wei that an address has withdrawn."}}},"contracts/solidity/token/XTokenUpgradeable.sol:XTokenUpgradeable":{source:"contracts/solidity/token/XTokenUpgradeable.sol",name:"XTokenUpgradeable",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Timelocked(address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"until",type:"uint256"}],name:"Timelocked",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"__XToken_init(address,string,string)":{inputs:[{internalType:"address",name:"_baseToken",type:"address"},{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"symbol",type:"string"}],name:"__XToken_init",outputs:[],stateMutability:"nonpayable",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"baseToken()":{inputs:[],name:"baseToken",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"burnXTokens(address,uint256)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"uint256",name:"_share",type:"uint256"}],name:"burnXTokens",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless this function is overridden; NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"mintXTokens(address,uint256,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"},{internalType:"uint256",name:"timelockLength",type:"uint256"}],name:"mintXTokens",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"timelockAccount(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"timelockLength",type:"uint256"}],name:"timelockAccount",outputs:[],stateMutability:"nonpayable",type:"function"},"timelockUntil(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"timelockUntil",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/solidity/tools/NFTXFlashSwipe.sol:ClaimToken":{source:"contracts/solidity/tools/NFTXFlashSwipe.sol",name:"ClaimToken",methods:{"accumulated(uint256)":{inputs:[{internalType:"uint256",name:"tokenIndex",type:"uint256"}],name:"accumulated",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"claim(uint256[])":{inputs:[{internalType:"uint256[]",name:"ids",type:"uint256[]"}],name:"claim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/tools/NFTXFlashSwipe.sol:NFTXFlashSwipe":{source:"contracts/solidity/tools/NFTXFlashSwipe.sol",name:"NFTXFlashSwipe",methods:{"flashSwipe(address,uint256,uint256,uint256[],uint8)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint256",name:"vaultId",type:"uint256"},{internalType:"uint256",name:"count",type:"uint256"},{internalType:"uint256[]",name:"specificIds",type:"uint256[]"},{internalType:"enum NFTXFlashSwipe.Type",name:"swipeType",type:"uint8"}],name:"flashSwipe",outputs:[],stateMutability:"nonpayable",type:"function"},"flashSwipeNCT(address,uint256,uint256[])":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint256",name:"count",type:"uint256"},{internalType:"uint256[]",name:"specificIds",type:"uint256[]"}],name:"flashSwipeNCT",outputs:[],stateMutability:"nonpayable",type:"function"},"flashSwipeWET(address,uint256,uint256[])":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint256",name:"count",type:"uint256"},{internalType:"uint256[]",name:"specificIds",type:"uint256[]"}],name:"flashSwipeWET",outputs:[],stateMutability:"nonpayable",type:"function"},"nftxFactory()":{inputs:[],name:"nftxFactory",outputs:[{internalType:"contract INFTXVaultFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"onFlashLoan(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"initiator",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"onFlashLoan",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/util/Address.sol:Address":{source:"contracts/solidity/util/Address.sol",name:"Address",details:"Collection of functions related to the address type"},"contracts/solidity/util/ContextUpgradeable.sol:ContextUpgradeable":{source:"contracts/solidity/util/ContextUpgradeable.sol",name:"ContextUpgradeable"},"contracts/solidity/util/Create2.sol:Create2":{source:"contracts/solidity/util/Create2.sol",name:"Create2",details:"Helper to make usage of the `CREATE2` EVM opcode easier and safer. `CREATE2` can be used to compute in advance the address where a smart contract will be deployed, which allows for interesting new mechanisms known as 'counterfactual interactions'. See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more information."},"contracts/solidity/util/ERC165Upgradeable.sol:ERC165Upgradeable":{source:"contracts/solidity/util/ERC165Upgradeable.sol",name:"ERC165Upgradeable",details:"Implementation of the {IERC165} interface. Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check for the additional interface id that will be supported. For example: ```solidity function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId); } ``` Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.",methods:{"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."}}},"contracts/solidity/util/EnumerableMapUpgradeable.sol:EnumerableSetUpgradeable":{source:"contracts/solidity/util/EnumerableMapUpgradeable.sol",name:"EnumerableSetUpgradeable",details:"Library for managing https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive types. Sets have the following properties: - Elements are added, removed, and checked for existence in constant time (O(1)). - Elements are enumerated in O(n). No guarantees are made on the ordering. ``` contract Example {     // Add the library methods     using EnumerableSet for EnumerableSet.AddressSet;     // Declare a set state variable     EnumerableSet.AddressSet private mySet; } ``` As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) and `uint256` (`UintSet`) are supported."},"contracts/solidity/util/EnumerableSetUpgradeable.sol:EnumerableSetUpgradeable":{source:"contracts/solidity/util/EnumerableSetUpgradeable.sol",name:"EnumerableSetUpgradeable",details:"Library for managing https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive types. Sets have the following properties: - Elements are added, removed, and checked for existence in constant time (O(1)). - Elements are enumerated in O(n). No guarantees are made on the ordering. ``` contract Example {     // Add the library methods     using EnumerableSet for EnumerableSet.AddressSet;     // Declare a set state variable     EnumerableSet.AddressSet private mySet; } ``` As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) and `uint256` (`UintSet`) are supported."},"contracts/solidity/util/Ownable.sol:Ownable":{source:"contracts/solidity/util/Ownable.sol",name:"Ownable",details:"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. By default, the owner account will be the one that deploys the contract. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.",events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/solidity/util/OwnableUpgradeable.sol:OwnableUpgradeable":{source:"contracts/solidity/util/OwnableUpgradeable.sol",name:"OwnableUpgradeable",details:"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. By default, the owner account will be the one that deploys the contract. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.",events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/solidity/util/PausableUpgradeable.sol:PausableUpgradeable":{source:"contracts/solidity/util/PausableUpgradeable.sol",name:"PausableUpgradeable",events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"SetIsGuardian(address,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"addr",type:"address"},{indexed:!1,internalType:"bool",name:"isGuardian",type:"bool"}],name:"SetIsGuardian",type:"event"},"SetPaused(uint256,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"lockId",type:"uint256"},{indexed:!1,internalType:"bool",name:"paused",type:"bool"}],name:"SetPaused",type:"event"}},methods:{"isGuardian(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isGuardian",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isPaused(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"isPaused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"onlyOwnerIfPaused(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"onlyOwnerIfPaused",outputs:[],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"pause(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setIsGuardian(address,bool)":{inputs:[{internalType:"address",name:"addr",type:"address"},{internalType:"bool",name:"_isGuardian",type:"bool"}],name:"setIsGuardian",outputs:[],stateMutability:"nonpayable",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"unpause(uint256)":{inputs:[{internalType:"uint256",name:"lockId",type:"uint256"}],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/solidity/util/ReentrancyGuard.sol:ReentrancyGuard":{source:"contracts/solidity/util/ReentrancyGuard.sol",name:"ReentrancyGuard"},"contracts/solidity/util/ReentrancyGuardUpgradeable.sol:ReentrancyGuardUpgradeable":{source:"contracts/solidity/util/ReentrancyGuardUpgradeable.sol",name:"ReentrancyGuardUpgradeable",details:"Contract module that helps prevent reentrant calls to a function. Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier available, which can be applied to functions to make sure there are no nested (reentrant) calls to them. Note that because there is a single `nonReentrant` guard, functions marked as `nonReentrant` may not call one another. This can be worked around by making those functions `private`, and then adding `external` `nonReentrant` entry points to them. TIP: If you would like to learn more about reentrancy and alternative ways to protect against it, check out our blog post https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]."},"contracts/solidity/util/SafeERC20Upgradeable.sol:SafeERC20Upgradeable":{source:"contracts/solidity/util/SafeERC20Upgradeable.sol",name:"SafeERC20Upgradeable",title:"SafeERC20",details:"Wrappers around ERC20 operations that throw on failure (when the token contract returns false). Tokens that return no value (and instead revert or throw on failure) are also supported, non-reverting calls are assumed to be successful. To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, which allows you to call the safe operations as `token.safeTransfer(...)`, etc."},"contracts/solidity/util/SafeMathInt.sol:SafeMathInt":{source:"contracts/solidity/util/SafeMathInt.sol",name:"SafeMathInt",title:"SafeMathInt",details:"Math operations with safety checks that revert on errorSafeMath adapted for int256 Based on code of  https://github.com/RequestNetwork/requestNetwork/blob/master/packages/requestNetworkSmartContracts/contracts/base/math/SafeMathInt.sol"},"contracts/solidity/util/SafeMathUpgradeable.sol:SafeMathUpgradeable":{source:"contracts/solidity/util/SafeMathUpgradeable.sol",name:"SafeMathUpgradeable",details:"Wrappers over Solidity's arithmetic operations. NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler now has built in overflow checking."}};new jn({el:"#app",router:new vp({routes:[{path:"/",component:Vp,props:()=>({json:Lp})},{path:"*",component:Pp,props:e=>({json:Lp[e.path.slice(1)]})}]}),mounted(){document.dispatchEvent(new Event("render-event"))},render:e=>e(kp)})})()})();