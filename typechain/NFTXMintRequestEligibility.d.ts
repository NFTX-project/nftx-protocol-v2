/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import type { TypedEventFilter, TypedEvent, TypedListener } from "./common";

interface NFTXMintRequestEligibilityInterface extends ethers.utils.Interface {
  functions: {
    "__NFTXEligibility_init(address,address,bool,uint256[])": FunctionFragment;
    "__NFTXEligibility_init_bytes(bytes)": FunctionFragment;
    "afterMintHook(uint256[])": FunctionFragment;
    "afterRedeemHook(uint256[])": FunctionFragment;
    "allowTrustedApprovals()": FunctionFragment;
    "approveMintRequests(uint256[],address[],bool)": FunctionFragment;
    "beforeMintHook(uint256[])": FunctionFragment;
    "beforeRedeemHook(uint256[])": FunctionFragment;
    "checkAllEligible(uint256[])": FunctionFragment;
    "checkAllIneligible(uint256[])": FunctionFragment;
    "checkEligible(uint256[])": FunctionFragment;
    "checkIsEligible(uint256)": FunctionFragment;
    "claimUnminted(uint256[],address[])": FunctionFragment;
    "finalizeEligibility()": FunctionFragment;
    "finalized()": FunctionFragment;
    "is1155()": FunctionFragment;
    "isGuardian(address)": FunctionFragment;
    "isInitialized()": FunctionFragment;
    "isPaused(uint256)": FunctionFragment;
    "isUniqueEligible(uint256)": FunctionFragment;
    "name()": FunctionFragment;
    "negateEligOnRedeem()": FunctionFragment;
    "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": FunctionFragment;
    "onERC1155Received(address,address,uint256,uint256,bytes)": FunctionFragment;
    "onERC721Received(address,address,uint256,bytes)": FunctionFragment;
    "onlyOwnerIfPaused(uint256)": FunctionFragment;
    "owner()": FunctionFragment;
    "pause(uint256)": FunctionFragment;
    "reclaimRequestedMint(uint256[])": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "requestMint(uint256[],uint256[])": FunctionFragment;
    "setEligibilityPreferences(bool)": FunctionFragment;
    "setIsGuardian(address,bool)": FunctionFragment;
    "setUniqueEligibilities(uint256[],bool)": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "targetAsset()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "unpause(uint256)": FunctionFragment;
    "vault()": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "__NFTXEligibility_init",
    values: [string, string, boolean, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "__NFTXEligibility_init_bytes",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "afterMintHook",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "afterRedeemHook",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "allowTrustedApprovals",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "approveMintRequests",
    values: [BigNumberish[], string[], boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "beforeMintHook",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "beforeRedeemHook",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "checkAllEligible",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "checkAllIneligible",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "checkEligible",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "checkIsEligible",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claimUnminted",
    values: [BigNumberish[], string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "finalizeEligibility",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "finalized", values?: undefined): string;
  encodeFunctionData(functionFragment: "is1155", values?: undefined): string;
  encodeFunctionData(functionFragment: "isGuardian", values: [string]): string;
  encodeFunctionData(
    functionFragment: "isInitialized",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isPaused",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "isUniqueEligible",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "negateEligOnRedeem",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "onERC1155BatchReceived",
    values: [string, string, BigNumberish[], BigNumberish[], BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC1155Received",
    values: [string, string, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC721Received",
    values: [string, string, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "onlyOwnerIfPaused",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "pause", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "reclaimRequestedMint",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "requestMint",
    values: [BigNumberish[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "setEligibilityPreferences",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setIsGuardian",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setUniqueEligibilities",
    values: [BigNumberish[], boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "targetAsset",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "unpause",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "vault", values?: undefined): string;

  decodeFunctionResult(
    functionFragment: "__NFTXEligibility_init",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "__NFTXEligibility_init_bytes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "afterMintHook",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "afterRedeemHook",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "allowTrustedApprovals",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveMintRequests",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "beforeMintHook",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "beforeRedeemHook",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "checkAllEligible",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "checkAllIneligible",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "checkEligible",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "checkIsEligible",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimUnminted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "finalizeEligibility",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "finalized", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "is1155", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isGuardian", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isInitialized",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isPaused", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isUniqueEligible",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "negateEligOnRedeem",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155BatchReceived",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155Received",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC721Received",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onlyOwnerIfPaused",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "reclaimRequestedMint",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "requestMint",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setEligibilityPreferences",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsGuardian",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setUniqueEligibilities",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "targetAsset",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "vault", data: BytesLike): Result;

  events: {
    "AllowTrustedApprovalsSet(bool)": EventFragment;
    "Approve(uint256[])": EventFragment;
    "NFTXEligibilityInit(address,uint256[])": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "Request(address,uint256[],uint256[])": EventFragment;
    "SetIsGuardian(address,bool)": EventFragment;
    "SetPaused(uint256,bool)": EventFragment;
    "UniqueEligibilitiesSet(uint256[],bool)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AllowTrustedApprovalsSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Approve"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NFTXEligibilityInit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Request"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetIsGuardian"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetPaused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UniqueEligibilitiesSet"): EventFragment;
}

export type AllowTrustedApprovalsSetEvent = TypedEvent<
  [boolean] & { allow: boolean }
>;

export type ApproveEvent = TypedEvent<[BigNumber[]] & { nftIds: BigNumber[] }>;

export type NFTXEligibilityInitEvent = TypedEvent<
  [string, BigNumber[]] & { owner: string; tokenIds: BigNumber[] }
>;

export type OwnershipTransferredEvent = TypedEvent<
  [string, string] & { previousOwner: string; newOwner: string }
>;

export type RequestEvent = TypedEvent<
  [string, BigNumber[], BigNumber[]] & {
    sender: string;
    nftIds: BigNumber[];
    amounts: BigNumber[];
  }
>;

export type SetIsGuardianEvent = TypedEvent<
  [string, boolean] & { addr: string; isGuardian: boolean }
>;

export type SetPausedEvent = TypedEvent<
  [BigNumber, boolean] & { lockId: BigNumber; paused: boolean }
>;

export type UniqueEligibilitiesSetEvent = TypedEvent<
  [BigNumber[], boolean] & { tokenIds: BigNumber[]; isEligible: boolean }
>;

export class NFTXMintRequestEligibility extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: NFTXMintRequestEligibilityInterface;

  functions: {
    __NFTXEligibility_init(
      _owner: string,
      vaultAddress: string,
      _negateEligOnRedeem: boolean,
      tokenIds: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    __NFTXEligibility_init_bytes(
      _configData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    afterMintHook(
      tokenIds: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    afterRedeemHook(
      tokenIds: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    allowTrustedApprovals(overrides?: CallOverrides): Promise<[boolean]>;

    approveMintRequests(
      tokenIds: BigNumberish[],
      addresses: string[],
      mint: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    beforeMintHook(
      tokenIds: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    beforeRedeemHook(
      tokenIds: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    checkAllEligible(
      tokenIds: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    checkAllIneligible(
      tokenIds: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    checkEligible(
      tokenIds: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[boolean[]]>;

    checkIsEligible(
      tokenId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    claimUnminted(
      tokenIds: BigNumberish[],
      addresses: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    finalizeEligibility(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    finalized(overrides?: CallOverrides): Promise<[boolean]>;

    is1155(overrides?: CallOverrides): Promise<[boolean]>;

    isGuardian(arg0: string, overrides?: CallOverrides): Promise<[boolean]>;

    isInitialized(overrides?: CallOverrides): Promise<[boolean]>;

    isPaused(arg0: BigNumberish, overrides?: CallOverrides): Promise<[boolean]>;

    isUniqueEligible(
      tokenId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    name(overrides?: CallOverrides): Promise<[string]>;

    negateEligOnRedeem(overrides?: CallOverrides): Promise<[boolean]>;

    onERC1155BatchReceived(
      arg0: string,
      arg1: string,
      arg2: BigNumberish[],
      arg3: BigNumberish[],
      arg4: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    onERC1155Received(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    onERC721Received(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    onlyOwnerIfPaused(
      lockId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pause(
      lockId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    reclaimRequestedMint(
      tokenIds: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    requestMint(
      tokenIds: BigNumberish[],
      amounts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setEligibilityPreferences(
      _allowTrustedApprovals: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setIsGuardian(
      addr: string,
      _isGuardian: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setUniqueEligibilities(
      tokenIds: BigNumberish[],
      _isEligible: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    targetAsset(overrides?: CallOverrides): Promise<[string]>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    unpause(
      lockId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    vault(overrides?: CallOverrides): Promise<[string]>;
  };

  __NFTXEligibility_init(
    _owner: string,
    vaultAddress: string,
    _negateEligOnRedeem: boolean,
    tokenIds: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  __NFTXEligibility_init_bytes(
    _configData: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  afterMintHook(
    tokenIds: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  afterRedeemHook(
    tokenIds: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  allowTrustedApprovals(overrides?: CallOverrides): Promise<boolean>;

  approveMintRequests(
    tokenIds: BigNumberish[],
    addresses: string[],
    mint: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  beforeMintHook(
    tokenIds: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  beforeRedeemHook(
    tokenIds: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  checkAllEligible(
    tokenIds: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<boolean>;

  checkAllIneligible(
    tokenIds: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<boolean>;

  checkEligible(
    tokenIds: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<boolean[]>;

  checkIsEligible(
    tokenId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  claimUnminted(
    tokenIds: BigNumberish[],
    addresses: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  finalizeEligibility(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  finalized(overrides?: CallOverrides): Promise<boolean>;

  is1155(overrides?: CallOverrides): Promise<boolean>;

  isGuardian(arg0: string, overrides?: CallOverrides): Promise<boolean>;

  isInitialized(overrides?: CallOverrides): Promise<boolean>;

  isPaused(arg0: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

  isUniqueEligible(
    tokenId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  name(overrides?: CallOverrides): Promise<string>;

  negateEligOnRedeem(overrides?: CallOverrides): Promise<boolean>;

  onERC1155BatchReceived(
    arg0: string,
    arg1: string,
    arg2: BigNumberish[],
    arg3: BigNumberish[],
    arg4: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  onERC1155Received(
    arg0: string,
    arg1: string,
    arg2: BigNumberish,
    arg3: BigNumberish,
    arg4: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  onERC721Received(
    arg0: string,
    arg1: string,
    arg2: BigNumberish,
    arg3: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  onlyOwnerIfPaused(
    lockId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  owner(overrides?: CallOverrides): Promise<string>;

  pause(
    lockId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  reclaimRequestedMint(
    tokenIds: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  requestMint(
    tokenIds: BigNumberish[],
    amounts: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setEligibilityPreferences(
    _allowTrustedApprovals: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setIsGuardian(
    addr: string,
    _isGuardian: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setUniqueEligibilities(
    tokenIds: BigNumberish[],
    _isEligible: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  supportsInterface(
    interfaceId: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  targetAsset(overrides?: CallOverrides): Promise<string>;

  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  unpause(
    lockId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  vault(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    __NFTXEligibility_init(
      _owner: string,
      vaultAddress: string,
      _negateEligOnRedeem: boolean,
      tokenIds: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    __NFTXEligibility_init_bytes(
      _configData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    afterMintHook(
      tokenIds: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    afterRedeemHook(
      tokenIds: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    allowTrustedApprovals(overrides?: CallOverrides): Promise<boolean>;

    approveMintRequests(
      tokenIds: BigNumberish[],
      addresses: string[],
      mint: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    beforeMintHook(
      tokenIds: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    beforeRedeemHook(
      tokenIds: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    checkAllEligible(
      tokenIds: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<boolean>;

    checkAllIneligible(
      tokenIds: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<boolean>;

    checkEligible(
      tokenIds: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<boolean[]>;

    checkIsEligible(
      tokenId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    claimUnminted(
      tokenIds: BigNumberish[],
      addresses: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    finalizeEligibility(overrides?: CallOverrides): Promise<void>;

    finalized(overrides?: CallOverrides): Promise<boolean>;

    is1155(overrides?: CallOverrides): Promise<boolean>;

    isGuardian(arg0: string, overrides?: CallOverrides): Promise<boolean>;

    isInitialized(overrides?: CallOverrides): Promise<boolean>;

    isPaused(arg0: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

    isUniqueEligible(
      tokenId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    name(overrides?: CallOverrides): Promise<string>;

    negateEligOnRedeem(overrides?: CallOverrides): Promise<boolean>;

    onERC1155BatchReceived(
      arg0: string,
      arg1: string,
      arg2: BigNumberish[],
      arg3: BigNumberish[],
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    onERC1155Received(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    onERC721Received(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    onlyOwnerIfPaused(
      lockId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    owner(overrides?: CallOverrides): Promise<string>;

    pause(lockId: BigNumberish, overrides?: CallOverrides): Promise<void>;

    reclaimRequestedMint(
      tokenIds: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    requestMint(
      tokenIds: BigNumberish[],
      amounts: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    setEligibilityPreferences(
      _allowTrustedApprovals: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    setIsGuardian(
      addr: string,
      _isGuardian: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    setUniqueEligibilities(
      tokenIds: BigNumberish[],
      _isEligible: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    targetAsset(overrides?: CallOverrides): Promise<string>;

    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    unpause(lockId: BigNumberish, overrides?: CallOverrides): Promise<void>;

    vault(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    "AllowTrustedApprovalsSet(bool)"(
      allow?: null
    ): TypedEventFilter<[boolean], { allow: boolean }>;

    AllowTrustedApprovalsSet(
      allow?: null
    ): TypedEventFilter<[boolean], { allow: boolean }>;

    "Approve(uint256[])"(
      nftIds?: null
    ): TypedEventFilter<[BigNumber[]], { nftIds: BigNumber[] }>;

    Approve(
      nftIds?: null
    ): TypedEventFilter<[BigNumber[]], { nftIds: BigNumber[] }>;

    "NFTXEligibilityInit(address,uint256[])"(
      owner?: null,
      tokenIds?: null
    ): TypedEventFilter<
      [string, BigNumber[]],
      { owner: string; tokenIds: BigNumber[] }
    >;

    NFTXEligibilityInit(
      owner?: null,
      tokenIds?: null
    ): TypedEventFilter<
      [string, BigNumber[]],
      { owner: string; tokenIds: BigNumber[] }
    >;

    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): TypedEventFilter<
      [string, string],
      { previousOwner: string; newOwner: string }
    >;

    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): TypedEventFilter<
      [string, string],
      { previousOwner: string; newOwner: string }
    >;

    "Request(address,uint256[],uint256[])"(
      sender?: null,
      nftIds?: null,
      amounts?: null
    ): TypedEventFilter<
      [string, BigNumber[], BigNumber[]],
      { sender: string; nftIds: BigNumber[]; amounts: BigNumber[] }
    >;

    Request(
      sender?: null,
      nftIds?: null,
      amounts?: null
    ): TypedEventFilter<
      [string, BigNumber[], BigNumber[]],
      { sender: string; nftIds: BigNumber[]; amounts: BigNumber[] }
    >;

    "SetIsGuardian(address,bool)"(
      addr?: null,
      isGuardian?: null
    ): TypedEventFilter<
      [string, boolean],
      { addr: string; isGuardian: boolean }
    >;

    SetIsGuardian(
      addr?: null,
      isGuardian?: null
    ): TypedEventFilter<
      [string, boolean],
      { addr: string; isGuardian: boolean }
    >;

    "SetPaused(uint256,bool)"(
      lockId?: null,
      paused?: null
    ): TypedEventFilter<
      [BigNumber, boolean],
      { lockId: BigNumber; paused: boolean }
    >;

    SetPaused(
      lockId?: null,
      paused?: null
    ): TypedEventFilter<
      [BigNumber, boolean],
      { lockId: BigNumber; paused: boolean }
    >;

    "UniqueEligibilitiesSet(uint256[],bool)"(
      tokenIds?: null,
      isEligible?: null
    ): TypedEventFilter<
      [BigNumber[], boolean],
      { tokenIds: BigNumber[]; isEligible: boolean }
    >;

    UniqueEligibilitiesSet(
      tokenIds?: null,
      isEligible?: null
    ): TypedEventFilter<
      [BigNumber[], boolean],
      { tokenIds: BigNumber[]; isEligible: boolean }
    >;
  };

  estimateGas: {
    __NFTXEligibility_init(
      _owner: string,
      vaultAddress: string,
      _negateEligOnRedeem: boolean,
      tokenIds: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    __NFTXEligibility_init_bytes(
      _configData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    afterMintHook(
      tokenIds: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    afterRedeemHook(
      tokenIds: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    allowTrustedApprovals(overrides?: CallOverrides): Promise<BigNumber>;

    approveMintRequests(
      tokenIds: BigNumberish[],
      addresses: string[],
      mint: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    beforeMintHook(
      tokenIds: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    beforeRedeemHook(
      tokenIds: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    checkAllEligible(
      tokenIds: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    checkAllIneligible(
      tokenIds: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    checkEligible(
      tokenIds: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    checkIsEligible(
      tokenId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimUnminted(
      tokenIds: BigNumberish[],
      addresses: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    finalizeEligibility(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    finalized(overrides?: CallOverrides): Promise<BigNumber>;

    is1155(overrides?: CallOverrides): Promise<BigNumber>;

    isGuardian(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    isInitialized(overrides?: CallOverrides): Promise<BigNumber>;

    isPaused(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    isUniqueEligible(
      tokenId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    negateEligOnRedeem(overrides?: CallOverrides): Promise<BigNumber>;

    onERC1155BatchReceived(
      arg0: string,
      arg1: string,
      arg2: BigNumberish[],
      arg3: BigNumberish[],
      arg4: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    onERC1155Received(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    onERC721Received(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    onlyOwnerIfPaused(
      lockId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pause(
      lockId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    reclaimRequestedMint(
      tokenIds: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    requestMint(
      tokenIds: BigNumberish[],
      amounts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setEligibilityPreferences(
      _allowTrustedApprovals: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setIsGuardian(
      addr: string,
      _isGuardian: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setUniqueEligibilities(
      tokenIds: BigNumberish[],
      _isEligible: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    targetAsset(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    unpause(
      lockId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    vault(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    __NFTXEligibility_init(
      _owner: string,
      vaultAddress: string,
      _negateEligOnRedeem: boolean,
      tokenIds: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    __NFTXEligibility_init_bytes(
      _configData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    afterMintHook(
      tokenIds: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    afterRedeemHook(
      tokenIds: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    allowTrustedApprovals(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    approveMintRequests(
      tokenIds: BigNumberish[],
      addresses: string[],
      mint: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    beforeMintHook(
      tokenIds: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    beforeRedeemHook(
      tokenIds: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    checkAllEligible(
      tokenIds: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    checkAllIneligible(
      tokenIds: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    checkEligible(
      tokenIds: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    checkIsEligible(
      tokenId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    claimUnminted(
      tokenIds: BigNumberish[],
      addresses: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    finalizeEligibility(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    finalized(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    is1155(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isGuardian(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isInitialized(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isPaused(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isUniqueEligible(
      tokenId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    negateEligOnRedeem(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    onERC1155BatchReceived(
      arg0: string,
      arg1: string,
      arg2: BigNumberish[],
      arg3: BigNumberish[],
      arg4: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    onERC1155Received(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    onERC721Received(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    onlyOwnerIfPaused(
      lockId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pause(
      lockId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    reclaimRequestedMint(
      tokenIds: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    requestMint(
      tokenIds: BigNumberish[],
      amounts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setEligibilityPreferences(
      _allowTrustedApprovals: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setIsGuardian(
      addr: string,
      _isGuardian: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setUniqueEligibilities(
      tokenIds: BigNumberish[],
      _isEligible: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    targetAsset(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    unpause(
      lockId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    vault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
